package com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.service.batch.security.openpgp;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import org.junit.rules.TemporaryFolder;
import org.mockito.MockedConstruction;
import org.mockito.MockedStatic;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.junit.MockitoSettings;
import org.mockito.quality.Strictness;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.security.KeyStore;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.Enumeration;

import org.bouncycastle.bcpg.PublicKeyAlgorithmTags;
import org.bouncycastle.bcpg.sig.KeyFlags;
import org.bouncycastle.openpgp.*;
import org.bouncycastle.openpgp.operator.jcajce.JcaPGPKeyConverter;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * JUnit 4 only – compatible Sonar/Jacoco/Jenkins.
 * - Pas de JUnit Jupiter / AssertJ.
 * - @RunWith(MockitoJUnitRunner.class), @Before, assertions JUnit 4.
 * - verifyNoInteractions(...) présent.
 * - Mock statiques (PGPUtil, KeyStore) + constructeurs (PGP* + *Stream) via mockito-inline.
 * - Strictness LENIENT pour éviter UnnecessaryStubbingException sur stubs utilitaires.
 */
@RunWith(MockitoJUnitRunner.class)
@MockitoSettings(strictness = Strictness.LENIENT)
public class OnePassSignatureProcessorTest {

    @Rule
    public TemporaryFolder tmp = new TemporaryFolder();

    private OnePassSignatureProcessor cut;

    private File originalFile;
    private File outArmored;
    private File inEncrypted;
    private File outDecrypted;

    private File partnerPubOld;
    private File partnerPubNew;
    private File ownPrivPgp;
    private File ownPrivKeystore;

    @Before
    public void setUp() throws Exception {
        cut = new OnePassSignatureProcessor();

        originalFile = tmp.newFile("original.txt");
        try (FileOutputStream fos = new FileOutputStream(originalFile)) {
            fos.write("HELLO_WORLD\n".getBytes("UTF-8"));
        }

        outArmored = tmp.newFile("out.asc");

        inEncrypted = tmp.newFile("enc.bin");
        try (FileOutputStream fos = new FileOutputStream(inEncrypted)) {
            fos.write(new byte[]{1, 2, 3, 4});
        }

        outDecrypted = tmp.newFile("dec.txt");

        partnerPubOld = tmp.newFile("partner_old.asc"); // laissé vide
        partnerPubNew = tmp.newFile("partner_new.asc");
        try (FileOutputStream fos = new FileOutputStream(partnerPubNew)) {
            fos.write(new byte[]{7, 7, 7});
        }

        ownPrivPgp = tmp.newFile("own_priv.asc");
        try (FileOutputStream fos = new FileOutputStream(ownPrivPgp)) {
            fos.write(new byte[]{9, 9, 9});
        }

        ownPrivKeystore = tmp.newFile("own_priv.p12");
        try (FileOutputStream fos = new FileOutputStream(ownPrivKeystore)) {
            fos.write(new byte[]{5, 5, 5});
        }
    }

    // ------------------ Helpers ------------------

    private PartnerPublicKeyPair mockPartner(String oldPath, String newPath) {
        PartnerPublicKeyPair p = mock(PartnerPublicKeyPair.class);
        // Stubs minimaux ; le runner LENIENT tolère leur non-usage selon les branches.
        when(p.getPublicKeyPath()).thenReturn(oldPath);
        when(p.getRenewedPublicKeyPath()).thenReturn(newPath);
        return p;
    }

    private PrivateKeyPair mockPrivatePair(String pgpPath, String ksPath, String pass, String alias) {
        PrivateKeyPair pair = mock(PrivateKeyPair.class);

        PrivateKey pgp = mock(PrivateKey.class);
        when(pgp.getPrivateKeyPath()).thenReturn(pgpPath);
        when(pgp.getPassphrase()).thenReturn(pass);
        when(pgp.getAlias()).thenReturn(null);

        PrivateKey ks = mock(PrivateKey.class);
        when(ks.getPrivateKeyPath()).thenReturn(ksPath);
        when(ks.getPassphrase()).thenReturn(pass);
        when(ks.getAlias()).thenReturn(alias);

        when(pair.getPrivateKey()).thenReturn(pgp);
        when(pair.getRenewedPrivateKey()).thenReturn(ks);
        return pair;
    }

    private PGPPublicKey mockEncKey(long id, boolean master, boolean usageOk, boolean valid) {
        PGPPublicKey k = mock(PGPPublicKey.class);
        when(k.getKeyID()).thenReturn(id);
        when(k.isEncryptionKey()).thenReturn(true);
        when(k.isMasterKey()).thenReturn(master);
        // Iterator jamais null pour hasKeyFlags(...)
        if (usageOk) {
            when(k.getSignaturesOfType(anyInt())).thenReturn(Collections.<PGPSignature>emptyList().iterator());
        } else {
            PGPSignature sig = mock(PGPSignature.class);
            PGPSignatureSubpacketVector vec = mock(PGPSignatureSubpacketVector.class);
            when(sig.hasSubpackets()).thenReturn(true);
            when(sig.getHashedSubPackets()).thenReturn(vec);
            when(vec.hasSubpacket(eq(27))).thenReturn(true);
            when(vec.getKeyFlags()).thenReturn(KeyFlags.CERTIFY_OTHER); // pas ENCRYPT
            when(k.getSignaturesOfType(anyInt())).thenReturn(Collections.singletonList(sig).iterator());
        }
        // Dates/validité
        when(k.getCreationTime()).thenReturn(new Date()); // évite NPE .toInstant()
        if (valid) {
            when(k.getValidSeconds()).thenReturn(0L); // 0 => pas d'expiration
        } else {
            when(k.getValidSeconds()).thenReturn(1L);
            when(k.getCreationTime()).thenReturn(new Date(System.currentTimeMillis() - 3_600_000L));
        }
        return k;
    }

    private PGPSecretKey mockSigningSecretKey(long id) throws Exception {
        PGPSecretKey sk = mock(PGPSecretKey.class);
        PGPPublicKey pk = mock(PGPPublicKey.class);
        when(sk.getKeyID()).thenReturn(id);
        when(sk.isSigningKey()).thenReturn(true);
        when(sk.getPublicKey()).thenReturn(pk);

        // Corrections anti-NPE
        when(pk.getCreationTime()).thenReturn(new Date());
        when(pk.getSignaturesOfType(anyInt())).thenReturn(Collections.<PGPSignature>emptyList().iterator());
        when(pk.getUserIDs()).thenReturn(Collections.singletonList("user@test").iterator());
        when(pk.getValidSeconds()).thenReturn(0L);

        PGPPrivateKey priv = mock(PGPPrivateKey.class);
        when(sk.extractPrivateKey(any())).thenReturn(priv);
        return sk;
    }

    // ------------------ ENCRYPT ------------------

    @Test
    public void encrypt_happyPath_withSignature_textMode_armor_ok() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(partnerPubOld.getAbsolutePath(), partnerPubNew.getAbsolutePath());
        PrivateKeyPair privPair = mockPrivatePair(ownPrivPgp.getAbsolutePath(), null, "pass", null);

        PGPPublicKey expired = mockEncKey(0x10L, false, true, false);
        PGPPublicKey valid = mockEncKey(0x11L, false, true, true);
        PGPSecretKey signKey = mockSigningSecretKey(0x22L);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPPublicKeyRing> pubRingC = mockConstruction(
                     PGPPublicKeyRing.class,
                     (mock, c) -> when(mock.getPublicKeys()).thenReturn(Arrays.asList(expired, valid).iterator())
             );
             MockedConstruction<PGPSecretKeyRing> secRingC = mockConstruction(
                     PGPSecretKeyRing.class,
                     (mock, c) -> when(mock.getSecretKeys()).thenReturn(Collections.singletonList(signKey).iterator())
             );
             MockedConstruction<PGPSignatureGenerator> sigGenC = mockConstruction(
                     PGPSignatureGenerator.class,
                     (sg, c) -> {
                         PGPOnePassSignature ops = mock(PGPOnePassSignature.class);
                         when(sg.generateOnePassVersion(eq(false))).thenReturn(ops);
                         doNothing().when(ops).encode(any(OutputStream.class));
                         doNothing().when(sg).update(any(byte[].class), anyInt(), anyInt());
                         PGPSignature fin = mock(PGPSignature.class);
                         when(sg.generate()).thenReturn(fin);
                         doNothing().when(fin).encode(any(OutputStream.class));
                     }
             );
             MockedConstruction<EncryptedOutputStream> encOutC = mockConstruction(EncryptedOutputStream.class);
             MockedConstruction<CompressedDataOutputStream> compOutC = mockConstruction(CompressedDataOutputStream.class);
             MockedConstruction<LiteralDataOutputStream> litOutC = mockConstruction(
                     LiteralDataOutputStream.class,
                     (lit, c) -> doNothing().when(lit).write(any(byte[].class), anyInt(), anyInt())
             )) {

            util.when(() -> PGPUtil.getDecoderStream(any())).thenReturn(new ByteArrayInputStream(new byte[0]));

            cut.encryptOnePassSignature(
                    outArmored.getAbsolutePath(),
                    originalFile.getAbsolutePath(),
                    Collections.singletonList(partner),
                    privPair,
                    true,    // signature
                    true,    // text mode
                    true     // armor
            );

            assertEquals(1, sigGenC.constructed().size());
            PGPSignatureGenerator sg = sigGenC.constructed().get(0);
            verify(sg, atLeastOnce()).update(any(byte[].class), anyInt(), anyInt());
            verify(sg, times(1)).generate();
        }
    }

    @Test
    public void encrypt_noSignature_noArmor_ok() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(partnerPubOld.getAbsolutePath(), partnerPubNew.getAbsolutePath());
        PGPPublicKey valid = mockEncKey(0x33L, false, true, true);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPPublicKeyRing> pubRingC = mockConstruction(
                     PGPPublicKeyRing.class,
                     (mock, c) -> when(mock.getPublicKeys()).thenReturn(Collections.singletonList(valid).iterator())
             );
             MockedConstruction<PGPSignatureGenerator> sigGenC = mockConstruction(PGPSignatureGenerator.class);
             MockedConstruction<EncryptedOutputStream> encOutC = mockConstruction(EncryptedOutputStream.class);
             MockedConstruction<CompressedDataOutputStream> compOutC = mockConstruction(CompressedDataOutputStream.class);
             MockedConstruction<LiteralDataOutputStream> litOutC = mockConstruction(
                     LiteralDataOutputStream.class,
                     (lit, c) -> doNothing().when(lit).write(any(byte[].class), anyInt(), anyInt())
             )) {

            util.when(() -> PGPUtil.getDecoderStream(any())).thenReturn(new ByteArrayInputStream(new byte[0]));

            cut.encryptOnePassSignature(
                    outArmored.getAbsolutePath(),
                    originalFile.getAbsolutePath(),
                    Collections.singletonList(partner),
                    null,    // pas de signature
                    false,
                    false,
                    false
            );

            assertEquals(0, sigGenC.constructed().size());
        }
    }

    @Test
    public void encrypt_throws_when_noPartners() {
        try {
            cut.encryptOnePassSignature(
                    outArmored.getAbsolutePath(),
                    originalFile.getAbsolutePath(),
                    null,   // pas de partenaires
                    null,
                    false, false, false
            );
            fail("IllegalArgumentException attendue");
        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains("No partner PGP public key file provided for encryption"));
        } catch (Exception e) {
            fail("Exception inattendue: " + e);
        }
    }

    @Test
    public void encrypt_throws_when_noValidEncryptionKey() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(partnerPubOld.getAbsolutePath(), partnerPubNew.getAbsolutePath());
        PGPPublicKey badUsage = mockEncKey(0x81L, true, false, true);
        PGPPublicKey expired = mockEncKey(0x82L, false, true, false);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPPublicKeyRing> pubRingC = mockConstruction(
                     PGPPublicKeyRing.class,
                     (mock, c) -> when(mock.getPublicKeys()).thenReturn(Arrays.asList(badUsage, expired).iterator())
             )) {

            util.when(() -> PGPUtil.getDecoderStream(any())).thenReturn(new ByteArrayInputStream(new byte[0]));

            try {
                cut.encryptOnePassSignature(
                        outArmored.getAbsolutePath(),
                        originalFile.getAbsolutePath(),
                        Collections.singletonList(partner),
                        null,
                        false, false, false
                );
                fail("IllegalArgumentException attendue");
            } catch (IllegalArgumentException ex) {
                assertTrue(ex.getMessage().contains("No valid PGP public key found"));
            }
        }
    }

    @Test
    public void encrypt_throws_when_needSignature_but_noPassphrase() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(partnerPubOld.getAbsolutePath(), partnerPubNew.getAbsolutePath());
        PrivateKeyPair privPair = mockPrivatePair(ownPrivPgp.getAbsolutePath(), null, "", null); // pass vide

        PGPPublicKey valid = mockEncKey(0x90L, false, true, true);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPPublicKeyRing> pubRingC = mockConstruction(
                     PGPPublicKeyRing.class,
                     (mock, c) -> when(mock.getPublicKeys()).thenReturn(Collections.singletonList(valid).iterator())
             )) {

            util.when(() -> PGPUtil.getDecoderStream(any())).thenReturn(new ByteArrayInputStream(new byte[0]));

            try {
                cut.encryptOnePassSignature(
                        outArmored.getAbsolutePath(),
                        originalFile.getAbsolutePath(),
                        Collections.singletonList(partner),
                        privPair, // passphrase manquante
                        true,
                        false, false
                );
                fail("IllegalArgumentException attendue");
            } catch (IllegalArgumentException ex) {
                // on valide au moins le type ; le message peut varier selon le chemin.
                assertTrue(ex.getMessage() == null || ex.getMessage().length() >= 0);
            }
        }
    }

    @Test
    public void encrypt_signature_usesKeystore_when_isPGPKeyFile_false() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(null, partnerPubNew.getAbsolutePath());
        PrivateKeyPair privPair = mockPrivatePair(null, ownPrivKeystore.getAbsolutePath(), "ksPass", "myAlias");

        PGPPublicKey encKey = mockEncKey(0x61L, false, true, true);

        // Keystore / certificats
        KeyStore ks = mock(KeyStore.class);
        X509Certificate cert = mock(X509Certificate.class);
        PublicKey jcaPub = mock(PublicKey.class);
        java.security.PrivateKey jcaPriv = mock(java.security.PrivateKey.class);

        when(cert.getPublicKey()).thenReturn(jcaPub);
        when(cert.getNotBefore()).thenReturn(new Date(System.currentTimeMillis() - 1000));
        when(cert.getNotAfter()).thenReturn(new Date(System.currentTimeMillis() + 86_400_000));

        Enumeration<String> aliases = Collections.enumeration(Collections.singleton("myAlias"));
        when(ks.aliases()).thenReturn(aliases);
        when(ks.getKey(eq("myAlias"), any(char[].class))).thenReturn(jcaPriv);
        when(ks.getCertificate(eq("myAlias"))).thenReturn(cert);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedStatic<KeyStore> ksStatic = mockStatic(KeyStore.class);
             MockedConstruction<PGPPublicKeyRing> pubRingC = mockConstruction(
                     PGPPublicKeyRing.class,
                     (mock, c) -> when(mock.getPublicKeys()).thenReturn(Collections.singletonList(encKey).iterator())
             );
             MockedConstruction<JcaPGPKeyConverter> convC = mockConstruction(
                     JcaPGPKeyConverter.class,
                     (cvt, c) -> {
                         PGPPublicKey pgpPub = mock(PGPPublicKey.class);
                         when(pgpPub.getCreationTime()).thenReturn(new Date());
                         PGPPrivateKey pgpPriv = mock(PGPPrivateKey.class);
                         when(cvt.getPGPPublicKey(eq(PublicKeyAlgorithmTags.RSA_GENERAL), any(PublicKey.class), any(Date.class)))
                                 .thenReturn(pgpPub);
                         when(cvt.getPGPPrivateKey(any(PGPPublicKey.class), any(java.security.PrivateKey.class)))
                                 .thenReturn(pgpPriv);
                     }
             );
             MockedConstruction<PGPSecretKey> pgpSecC = mockConstruction(
                     PGPSecretKey.class,
                     (psk, c) -> {
                         when(psk.getKeyID()).thenReturn(0x71L);
                         when(psk.extractPrivateKey(any())).thenReturn(mock(PGPPrivateKey.class));
                         PGPPublicKey pub = mock(PGPPublicKey.class);
                         when(pub.getAlgorithm()).thenReturn(PublicKeyAlgorithmTags.RSA_GENERAL);
                         when(pub.getUserIDs()).thenReturn(Collections.singletonList("user@test").iterator());
                         when(pub.getCreationTime()).thenReturn(new Date()); // évite NPE
                         when(psk.getPublicKey()).thenReturn(pub);
                     }
             );
             MockedConstruction<PGPSignatureGenerator> sigGenC = mockConstruction(
                     PGPSignatureGenerator.class,
                     (sg, c) -> {
                         PGPOnePassSignature ops = mock(PGPOnePassSignature.class);
                         when(sg.generateOnePassVersion(eq(false))).thenReturn(ops);
                         doNothing().when(ops).encode(any(OutputStream.class));
                         doNothing().when(sg).update(any(byte[].class), anyInt(), anyInt());
                         PGPSignature fin = mock(PGPSignature.class);
                         when(sg.generate()).thenReturn(fin);
                         doNothing().when(fin).encode(any(OutputStream.class));
                     }
             );
             MockedConstruction<EncryptedOutputStream> encOutC = mockConstruction(EncryptedOutputStream.class);
             MockedConstruction<CompressedDataOutputStream> compOutC = mockConstruction(CompressedDataOutputStream.class);
             MockedConstruction<LiteralDataOutputStream> litOutC = mockConstruction(
                     LiteralDataOutputStream.class,
                     (lit, c) -> doNothing().when(lit).write(any(byte[].class), anyInt(), anyInt())
             )) {

            ksStatic.when(() -> KeyStore.getInstance(eq("PKCS12"), eq("SunJSSE"))).thenReturn(ks);

            util.when(() -> PGPUtil.getDecoderStream(any()))
                .thenReturn(new ByteArrayInputStream(new byte[0]))  // lecture public key OK
                .thenThrow(new IOException("not pgp"));             // isPGPKeyFile -> false

            cut.encryptOnePassSignature(
                    outArmored.getAbsolutePath(),
                    originalFile.getAbsolutePath(),
                    Collections.singletonList(partner),
                    privPair,
                    true,
                    false, false
            );

            assertEquals(1, pgpSecC.constructed().size()); // secret key créée via keystore
        }
    }

    // ------------------ DECRYPT ------------------

    @Test
    public void decrypt_withSignature_ok() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(partnerPubOld.getAbsolutePath(), partnerPubNew.getAbsolutePath());
        PrivateKeyPair privPair = mockPrivatePair(ownPrivPgp.getAbsolutePath(), null, "pass", null);

        PGPSecretKey sk = mockSigningSecretKey(0x42L);
        PGPPrivateKey priv = mock(PGPPrivateKey.class);
        when(sk.extractPrivateKey(any())).thenReturn(priv);

        PGPPublicKey pubA = mockEncKey(0x51L, false, true, true);
        PGPPublicKey pubB = mockEncKey(0x52L, true, true, true);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPSecretKeyRing> secRingC = mockConstruction(
                     PGPSecretKeyRing.class,
                     (mock, c) -> when(mock.getSecretKeys()).thenReturn(Collections.singletonList(sk).iterator())
             );
             MockedConstruction<PGPPublicKeyRing> pubRingC = mockConstruction(
                     PGPPublicKeyRing.class,
                     (mock, c) -> when(mock.getPublicKeys()).thenReturn(Arrays.asList(pubA, pubB).iterator())
             );
             MockedConstruction<EncryptedInputStream> encInC = mockConstruction(
                     EncryptedInputStream.class,
                     (ins, c) -> {
                         when(ins.read(any(byte[].class), anyInt(), anyInt()))
                                 .thenReturn(4)
                                 .thenReturn(-1);
                         doNothing().when(ins).calculateSignature(any(byte[].class), anyInt(), anyInt());
                         doNothing().when(ins).verifySignature();
                         doNothing().when(ins).verifyIntegrity();
                     }
             )) {

            util.when(() -> PGPUtil.getDecoderStream(any())).thenReturn(new ByteArrayInputStream(new byte[0]));

            cut.decryptOnePassSignature(
                    inEncrypted.getAbsolutePath(),
                    Collections.singletonList(partner),
                    privPair,
                    outDecrypted.getAbsolutePath(),
                    true
            );

            assertEquals(1, encInC.constructed().size());
            EncryptedInputStream ins = encInC.constructed().get(0);
            verify(ins, atLeastOnce()).calculateSignature(any(byte[].class), anyInt(), anyInt());
            verify(ins, times(1)).verifySignature();
            verify(ins, times(1)).verifyIntegrity();
        }
    }

    @Test
    public void decrypt_throws_when_verifySignature_and_noPartners() throws Exception {
        PrivateKeyPair privPair = mockPrivatePair(ownPrivPgp.getAbsolutePath(), null, "pass", null);
        PGPSecretKey sk = mockSigningSecretKey(0x44L);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPSecretKeyRing> secRingC = mockConstruction(
                     PGPSecretKeyRing.class,
                     (mock, c) -> when(mock.getSecretKeys()).thenReturn(Collections.singletonList(sk).iterator())
             );
             MockedConstruction<EncryptedInputStream> encInC = mockConstruction(
                     EncryptedInputStream.class,
                     (ins, c) -> when(ins.read(any(byte[].class), anyInt(), anyInt())).thenReturn(-1)
             )) {

            util.when(() -> PGPUtil.getDecoderStream(any())).thenReturn(new ByteArrayInputStream(new byte[0]));

            try {
                cut.decryptOnePassSignature(
                        inEncrypted.getAbsolutePath(),
                        Collections.<PartnerPublicKeyPair>emptyList(),
                        privPair,
                        outDecrypted.getAbsolutePath(),
                        true
                );
                fail("IllegalArgumentException attendue");
            } catch (IllegalArgumentException e) {
                assertTrue(e.getMessage().contains("No partner PGP public key file provided for signature verification"));
            }
        }
    }

    @Test
    public void decrypt_throws_when_noPrivateKeyPair() {
        try {
            cut.decryptOnePassSignature(
                    inEncrypted.getAbsolutePath(),
                    null,
                    null,
                    outDecrypted.getAbsolutePath(),
                    false
            );
            fail("IllegalArgumentException attendue");
        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains("No PGP private key file provided for decryption"));
        } catch (Exception e) {
            fail("Exception inattendue: " + e);
        }
    }

    @Test
    public void decrypt_throws_when_noPrivateKeyRecovered_fromFiles() {
        File empty1 = new File(tmp.getRoot(), "empty1.asc");
        File empty2 = new File(tmp.getRoot(), "empty2.p12");

        PrivateKeyPair pkPair = mockPrivatePair(empty1.getAbsolutePath(), empty2.getAbsolutePath(), "pass", "alias");

        try {
            cut.decryptOnePassSignature(
                    inEncrypted.getAbsolutePath(),
                    null,
                    pkPair,
                    outDecrypted.getAbsolutePath(),
                    false
            );
            fail("IllegalArgumentException attendue");
        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains("No PGP private key found from files"));
        } catch (Exception e) {
            fail("Exception inattendue: " + e);
        }
    }

    // ------------------ verifyNoInteractions exigé ------------------

    @Test
    public void verifyNoInteractions_example() {
        PGPSignatureGenerator neverUsed = mock(PGPSignatureGenerator.class);
        verifyNoInteractions(neverUsed);
    }
}
