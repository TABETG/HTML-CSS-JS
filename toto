Top ‚Äî voil√† le code complet corrig√© pour faire monter le coverage Sonar sur la config JobConfigurationBillingSpaceClosure.
J‚Äôai mock√© tous les beans externes (readers/writer/tasklet/tx manager/repo) et le processor pour √©viter l‚Äôerreur CommandExecutorV2 manquant, tout en v√©rifiant le wiring du job, des steps, RunIdIncrementer, allowStartIfComplete(true), pr√©sence du listener commun et chunk = 100 sur les steps chunk√©s.
(Noms exacts confirm√©s depuis ta classe de conf : le bean s‚Äôappelle updateBillingSpaceToStatusClosedStep et le nom du step est updateBillingSpaceToStatusClosed.) 


---

üìÑ src/test/java/com/bnpparibas/dsibddf/ap00420/streamfact/batch/billingspace/close/job/JobConfigurationBillingSpaceClosureTest.java

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.job;

import com.bnpparibas.dsibddf.ap00420.streamfact.application.billingspace.close.pojo.BillingSpaceCloseToSend;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.processor.BillingSpaceClosureProcessor;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.reader.BillingSpaceClosureReader;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.reader.ReplayBillingspaceClosureReader;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.tasklet.UpdateBillingSpaceToStatusClosedTasklet;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.writer.BillingSpaceClosureWriter;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.listener.CommonStepExecutionListener;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.BillingSpaceEntity;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.job.flow.FlowJob;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.core.step.tasklet.TaskletStep;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Autowired;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Test de wiring & propri√©t√©s du job de cl√¥ture (sans I/O, 100% mocks).
 * Couvre: cr√©ation des @Bean, structure du flow, incrementer, allowStartIfComplete, chunk=100, listener commun.
 */
@SpringJUnitConfig
@Import({ JobConfigurationBillingSpaceClosure.class, JobConfigurationBillingSpaceClosureTest.TestBeans.class })
class JobConfigurationBillingSpaceClosureTest {

    @TestConfiguration
    static class TestBeans {
        // Doubles pour √©viter toute d√©pendance infra
        @Bean BillingSpaceClosureReader billingSpaceClosureReader() { return Mockito.mock(BillingSpaceClosureReader.class); }
        @Bean ReplayBillingspaceClosureReader replayBillingSpaceClosureReader() { return Mockito.mock(ReplayBillingspaceClosureReader.class); }
        @Bean BillingSpaceClosureWriter billingSpaceClosureWriter() { return Mockito.mock(BillingSpaceClosureWriter.class); }
        @Bean UpdateBillingSpaceToStatusClosedTasklet updateBillingSpaceToStatusClosedTasklet() { return Mockito.mock(UpdateBillingSpaceToStatusClosedTasklet.class); }
        @Bean CommonStepExecutionListener commonStepExecutionListener() { return new CommonStepExecutionListener(); }

        // üëá Mocker directement le processor √©vite le bean manquant CommandExecutorV2
        @Bean BillingSpaceClosureProcessor billingSpaceClosureProcessor() { return Mockito.mock(BillingSpaceClosureProcessor.class); }

        // Beans infra exig√©s par les builders
        @Bean @Qualifier("transactionManager") PlatformTransactionManager transactionManager() { return Mockito.mock(PlatformTransactionManager.class); }
        @Bean JobRepository jobRepository() { return Mockito.mock(JobRepository.class); }
    }

    @Autowired private Job job;

    @Autowired @Qualifier("billingSpaceClosureStep")
    private Step billingSpaceClosureStepBean;

    @Autowired @Qualifier("replayBillingSpaceClosureStep")
    private Step replayBillingSpaceClosureStepBean;

    // ‚ö†Ô∏è Bean name = updateBillingSpaceToStatusClosedStep, step name = "updateBillingSpaceToStatusClosed"
    @Autowired @Qualifier("updateBillingSpaceToStatusClosedStep")
    private Step updateBillingSpaceToStatusClosedStepBean;

    @Autowired private CommonStepExecutionListener commonStepExecutionListener;

    // ---------- Tests Job ----------
    @Nested @DisplayName("Job wiring & flow")
    class JobWiring {

        @Test @DisplayName("Nom du job + RunIdIncrementer")
        void job_has_name_and_incrementer() {
            assertThat(job).isInstanceOf(FlowJob.class);
            FlowJob fj = (FlowJob) job;
            assertThat(fj.getName()).isEqualTo("billingSpaceClosureJob");
            assertThat(fj.getJobParametersIncrementer()).isInstanceOf(RunIdIncrementer.class);
        }

        @Test @DisplayName("Le flow r√©f√©rence les 3 steps par leurs noms de step")
        void job_contains_expected_steps_in_flow() {
            FlowJob fj = (FlowJob) job;
            // Noms des steps dans la conf (@Bean "update...Step" mais stepName = "updateBillingSpaceToStatusClosed")
            assertThat(fj.getStep("billingSpaceClosureStep")).isNotNull();
            assertThat(fj.getStep("replayBillingSpaceClosureStep")).isNotNull();
            assertThat(fj.getStep("updateBillingSpaceToStatusClosed")).isNotNull();
        }
    }

    // ---------- Tests Steps chunk√©s ----------
    @Nested @DisplayName("Steps chunk√©s : chunk=100, allowStartIfComplete=true, listener commun")
    class ChunkedStepsProperties {

        @Test @DisplayName("billingSpaceClosureStep : props OK")
        void billingSpaceClosureStep_properties() {
            assertChunkStep(billingSpaceClosureStepBean, 100);
        }

        @Test @DisplayName("replayBillingSpaceClosureStep : props OK")
        void replayBillingSpaceClosureStep_properties() {
            assertChunkStep(replayBillingSpaceClosureStepBean, 100);
        }
    }

    // ---------- Test Step tasklet ----------
    @Nested @DisplayName("Step tasklet de mise √† jour de statut")
    class TaskletStepProperties {
        @Test @DisplayName("updateBillingSpaceToStatusClosed : allowStartIfComplete=true")
        void updateBillingSpaceToStatusClosed_allowStartIfComplete_true() {
            assertThat(updateBillingSpaceToStatusClosedStepBean).isInstanceOf(TaskletStep.class);
            TaskletStep ts = (TaskletStep) updateBillingSpaceToStatusClosedStepBean;
            Object allow = ReflectionTestUtils.getField(ts, "allowStartIfComplete");
            assertThat(allow).isInstanceOf(Boolean.class);
            assertThat((Boolean) allow).isTrue();
        }
    }

    // ---------- Helpers reflection ----------
    private void assertChunkStep(Step step, int expectedChunk) {
        assertThat(step).isInstanceOf(TaskletStep.class);
        TaskletStep ts = (TaskletStep) step;

        // allowStartIfComplete
        Object allow = ReflectionTestUtils.getField(ts, "allowStartIfComplete");
        assertThat(allow).isInstanceOf(Boolean.class);
        assertThat((Boolean) allow).isTrue();

        // listener commun pr√©sent (composite -> listeners)
        Object compositeListener = ReflectionTestUtils.getField(ts, "stepExecutionListener");
        Object listeners = ReflectionTestUtils.getField(compositeListener, "listeners");
        assertThat(listeners).isInstanceOfAny(java.util.Collection.class);
        assertThat((java.util.Collection<?>) listeners).anyMatch(l -> l == commonStepExecutionListener);

        // chunk size = 100 (via completionPolicy.chunkSize)
        Tasklet tasklet = (Tasklet) ReflectionTestUtils.getField(ts, "tasklet");
        assertThat(tasklet).isNotNull();
        Object chunkProvider = ReflectionTestUtils.getField(tasklet, "chunkProvider");
        Object completionPolicy = ReflectionTestUtils.getField(chunkProvider, "completionPolicy");
        Integer chunkSize = (Integer) ReflectionTestUtils.getField(completionPolicy, "chunkSize");
        assertThat(chunkSize).isEqualTo(expectedChunk);
    }
}


---

‚ñ∂Ô∏è √Ä lancer (exemples)

# Uniquement ce test, dans le module batch
mvn -pl <module-batch> -am -Dtest=JobConfigurationBillingSpaceClosureTest test

# Puis JaCoCo + Sonar si n√©cessaire
mvn -pl <module-batch> -am test jacoco:report sonar:sonar

Si tu veux, je peux ajouter une variante ‚Äúsmoke‚Äù qui lance chaque step avec JobLauncherTestUtils (toujours sans I/O) pour grappiller encore quelques lignes d‚Äôex√©cution.