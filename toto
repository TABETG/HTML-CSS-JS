package com.bnpparibas.dsibddf.ap00420.streamfact.exposition.rest.support;

import com.bnpparibas.bddf.config.SpringProfileConstants;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.core.env.Environment;

import java.lang.reflect.Field;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.mockito.Mockito.when;

/** Couverture 100% pour AbstractSpringBootLauncher. */
class AbstractSpringBootLauncherTest {

    /** Implémentation concrète minimale pour la classe abstraite. */
    static class TestLauncher extends AbstractSpringBootLauncher { }

    /** Mini app Spring Boot “neutre” pour tester launch(...). */
    @SpringBootApplication
    static class DummyApp { }

    /** Injecte un Environment mocké dans le champ 'env' via réflexion. */
    private static void injectEnv(AbstractSpringBootLauncher launcher, Environment env) throws Exception {
        Field f = AbstractSpringBootLauncher.class.getDeclaredField("env");
        f.setAccessible(true);
        f.set(launcher, env);
    }

    @Test
    void initApplication_withNonConflictingProfiles_logsInfoOnly() throws Exception {
        TestLauncher launcher = new TestLauncher();
        Environment env = Mockito.mock(Environment.class);
        when(env.getActiveProfiles()).thenReturn(new String[] {"dev"}); // aucun conflit
        injectEnv(launcher, env);

        launcher.initApplication(); // branche “info”
    }

    @Test
    void initApplication_withMqAndActiveMq_logsErrorBranch() throws Exception {
        TestLauncher launcher = new TestLauncher();
        Environment env = Mockito.mock(Environment.class);
        when(env.getActiveProfiles()).thenReturn(new String[] {
                SpringProfileConstants.SPRING_PROFILE_MQ,
                SpringProfileConstants.SPRING_PROFILE_ACTIVE_MQ
        });
        injectEnv(launcher, env);

        launcher.initApplication(); // branche “error”
    }

    @Test
    void launch_runsHeadless_withoutVault_or_Bootstrap() {
        // IMPORTANT : PAS de spring.autoconfigure.exclude ici !
        String[] args = new String[] {
                "--spring.main.web-application-type=NONE",
                "--spring.main.lazy-initialization=true",
                "--spring.application.name=test-app",
                "--server.port=0",

                // on coupe le Bootstrap context et Vault
                "--spring.cloud.bootstrap.enabled=false",
                "--spring.cloud.vault.enabled=false",

                // “calme” le système d’imports de config pour éviter toute source externe
                "--spring.config.import="
        };

        assertDoesNotThrow(() ->
                AbstractSpringBootLauncher.launch(DummyApp.class, args)
        );
    }
}