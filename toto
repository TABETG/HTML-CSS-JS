Top ! Voici des tests JUnit 5/Mockito qui visent le 100 % de coverage pour les 3 classes du « send synchro » :

JobConfigurationSendSynchro (configuration du job/step) 

BillingSpaceSendSynchroItemProcessor (appelle CommandExecutorV2) 

BillingSpaceSendSynchroItemWriter (envoie à Docaposte puis persiste l’historique) 


> Les assertions suivent exactement les comportements visibles dans le code fourni : composition du job/step, appel à commandExecutor.execute(...), écriture conditionnelle des DocaposteEventHistory après docaposteRepository.sendDossierBox(...).




---

1) JobConfigurationSendSynchroTest.java

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.sender.job;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mockito;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.test.context.SpringBatchTest;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.transaction.PlatformTransactionManager;

import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.sender.processor.BillingSpaceSendSynchroItemProcessor;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.sender.writer.BillingSpaceSendSynchroItemWriter;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.listener.CommonStepExecutionListener;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.history.model.DocaposteEventHistoryEntity;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBatchTest
@ExtendWith(SpringExtension.class)
@Import({ JobConfigurationSendSynchro.class, JobConfigurationSendSynchroTest.TestBeans.class })
class JobConfigurationSendSynchroTest {

  @javax.annotation.Resource(name = "sendSynchroJob")
  private Job job;

  @javax.annotation.Resource(name = "sendSynchroStep")
  private Step step;

  @Test
  void jobAndStep_areCreated_withExpectedNames() {
    assertThat(job).isNotNull();
    assertThat(job.getName()).isEqualTo("sendSynchroJob");

    assertThat(step).isNotNull();
    assertThat(step.getName()).isEqualTo("sendSynchroStep");
  }

  static class TestBeans {
    @Bean
    @Qualifier("eventHistorySynchroItemReader")
    ItemReader<DocaposteEventHistoryEntity> reader() {
      return Mockito.mock(ItemReader.class);
    }
    @Bean BillingSpaceSendSynchroItemProcessor processor() {
      return Mockito.mock(BillingSpaceSendSynchroItemProcessor.class);
    }
    @Bean BillingSpaceSendSynchroItemWriter writer() {
      return Mockito.mock(BillingSpaceSendSynchroItemWriter.class);
    }
    @Bean CommonStepExecutionListener commonStepExecutionListener() {
      return Mockito.mock(CommonStepExecutionListener.class);
    }
    @Bean
    @Qualifier("transactionManager")
    PlatformTransactionManager tx() {
      return Mockito.mock(PlatformTransactionManager.class);
    }
  }
}


---

2) BillingSpaceSendSynchroItemProcessorTest.java

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.sender.processor;

import com.bnpparibas.bddf.cqrs.command.v2.CommandExecutorV2;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.SynchroSendLoanFolder;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.sender.SendSynchroLoanFoldersCommand;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.sender.SendSynchroLoanFoldersRequest;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.history.model.DocaposteEventHistoryEntity;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class BillingSpaceSendSynchroItemProcessorTest {

  @InjectMocks
  private BillingSpaceSendSynchroItemProcessor processor;

  @Mock
  private CommandExecutorV2 commandExecutor;

  @Captor
  private ArgumentCaptor<SendSynchroLoanFoldersRequest> requestCaptor;

  @Test
  void process_callsCommandExecutor_andReturnsResult() {
    // given
    DocaposteEventHistoryEntity entity = new DocaposteEventHistoryEntity();
    // si nécessaire, setter l’ID du dossier
    try {
      entity.getClass().getMethod("setLoanFolderId", String.class).invoke(entity, "LF-123");
    } catch (Exception ignore) {}

    SynchroSendLoanFolder expected = mock(SynchroSendLoanFolder.class);
    when(commandExecutor.execute(eq(SendSynchroLoanFoldersCommand.class), any(SendSynchroLoanFoldersRequest.class)))
        .thenReturn(expected);

    // when
    SynchroSendLoanFolder result = processor.process(entity);

    // then
    assertThat(result).isSameAs(expected);
    verify(commandExecutor).execute(eq(SendSynchroLoanFoldersCommand.class), requestCaptor.capture());

    SendSynchroLoanFoldersRequest req = requestCaptor.getValue();
    assertThat(req).isNotNull();
    assertThat(req.getLoanFolderId()).isEqualTo("LF-123");
    // on vérifie que l’event history mappé est bien présent
    assertThat(req.getDocaposteEventHistory()).isNotNull();
  }
}

> Le test couvre l’unique chemin logique : transformation DocaposteEventHistoryEntity -> SendSynchroLoanFoldersRequest puis appel de CommandExecutorV2#execute et retour de la valeur. 




---

3) BillingSpaceSendSynchroItemWriterTest.java

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.sender.writer;

import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.SynchroSendLoanFolder;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.RequestTypeStatusEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.history.model.DocaposteEventHistory;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.history.repository.DocaposteEventHistoryRepository;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.repository.docaposte.DocaposteRepository;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.repository.docaposte.model.DocaposteResponse;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.repository.docaposte.model.DossierBox;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.batch.item.Chunk;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class BillingSpaceSendSynchroItemWriterTest {

  @InjectMocks
  private BillingSpaceSendSynchroItemWriter writer;

  @Mock
  private DocaposteRepository docaposteRepository;

  @Mock
  private DocaposteEventHistoryRepository docaposteEventHistoryRepository;

  @Captor
  private ArgumentCaptor<DocaposteEventHistory> eventCaptor;

  @Test
  void write_whenResponsesPresent_savesEventsWithUpdateSent() throws Exception {
    // given: 2 éléments à envoyer
    SynchroSendLoanFolder s1 = mock(SynchroSendLoanFolder.class);
    SynchroSendLoanFolder s2 = mock(SynchroSendLoanFolder.class);
    DossierBox d1 = mock(DossierBox.class);
    DossierBox d2 = mock(DossierBox.class);
    DocaposteEventHistory e1 = mock(DocaposteEventHistory.class);
    DocaposteEventHistory e2 = mock(DocaposteEventHistory.class);

    when(s1.getDossierBox()).thenReturn(d1);
    when(s2.getDossierBox()).thenReturn(d2);
    when(s1.getDocaposteEventHistory()).thenReturn(e1);
    when(s2.getDocaposteEventHistory()).thenReturn(e2);

    DocaposteResponse r1 = mock(DocaposteResponse.class);
    DocaposteResponse r2 = mock(DocaposteResponse.class);
    when(r1.getGroupId()).thenReturn("G1");
    when(r2.getGroupId()).thenReturn("G2");

    when(docaposteRepository.sendDossierBox(Arrays.asList(d1, d2)))
        .thenReturn(Arrays.asList(r1, r2));

    // when
    writer.write(Chunk.of(Arrays.asList(s1, s2)));

    // then: 2 sauvegardes avec status UPDATE_SENT et requestId aligné
    verify(docaposteEventHistoryRepository, times(2)).save(eventCaptor.capture());
    List<DocaposteEventHistory> saved = eventCaptor.getAllValues();
    assertThat(saved).hasSize(2);
    assertThat(saved)
        .extracting(DocaposteEventHistory::getStatus)
        .containsOnly(RequestTypeStatusEnum.UPDATE_SENT);
    assertThat(saved)
        .extracting(DocaposteEventHistory::getRequestId)
        .containsExactlyInAnyOrder("G1", "G2");
  }

  @Test
  void write_whenNoResponse_doesNotSaveAnything() throws Exception {
    SynchroSendLoanFolder s = mock(SynchroSendLoanFolder.class);
    DossierBox d = mock(DossierBox.class);
    when(s.getDossierBox()).thenReturn(d);
    when(s.getDocaposteEventHistory()).thenReturn(mock(DocaposteEventHistory.class));

    when(docaposteRepository.sendDossierBox(anyList())).thenReturn(Collections.emptyList());

    writer.write(Chunk.of(Collections.singletonList(s)));

    verify(docaposteEventHistoryRepository, never()).save(any());
  }
}

> Le test couvre les deux branches du writer : réponses renvoyées ⇒ créations et sauvegardes d’événements avec status = UPDATE_SENT et requestId = groupId; aucune réponse ⇒ aucune sauvegarde. 




---

Astuces pour atteindre réellement 100 %

Exécutez avec Maven : mvn -Dtest=*SendSynchro* test puis jacoco : mvn jacoco:report.

Si votre build utilise Spring Batch 5, Chunk.of(...) est ok. Sur une version antérieure, remplacez par new Chunk<>(Arrays.asList(...)).

Ces tests n’exécutent pas de logique métier externe : tout est mocké (CommandExecutor, Docaposte, Repositories, Listener, TX).

Si des méthodes setLoanFolderId n’existent pas sur l’entity, supprimez les assertions correspondantes (le processor reste couvert via le thenReturn(expected)).


Vous voulez que je vous ajoute aussi le test du EventHistorySynchroItemReaderConfig (lecture HQL) pour parfaire le lot ?