<#
utf8_to_ansi.ps1
Usage:
  .\utf8_to_ansi.ps1 -InFile "C:\path\input.sql" -OutFile "C:\path\output.sql"
#>

param(
  [Parameter(Mandatory=$true)]
  [string]$InFile,

  [Parameter(Mandatory=$true)]
  [string]$OutFile
)

if (-not (Test-Path $InFile)) {
  Write-Error "Fichier introuvable: $InFile"
  exit 1
}

# Lire en bytes (gère UTF-8 avec ou sans BOM)
$bytes = [IO.File]::ReadAllBytes($InFile)

# Détecter BOM UTF-8 (EF BB BF)
$hasUtf8Bom = ($bytes.Length -ge 3 -and $bytes[0] -eq 0xEF -and $bytes[1] -eq 0xBB -and $bytes[2] -eq 0xBF)

# Décoder UTF-8
if ($hasUtf8Bom) {
  $utf8NoBom = New-Object System.Text.UTF8Encoding($false)
  $text = $utf8NoBom.GetString($bytes, 3, $bytes.Length - 3)
} else {
  $text = [Text.Encoding]::UTF8.GetString($bytes)
}

# Encoder en ANSI Windows (CP1252)
$ansi = [Text.Encoding]::GetEncoding(1252)
$outBytes = $ansi.GetBytes($text)

# Écrire en bytes (=> pas d'UTF-8 possible)
[IO.File]::WriteAllBytes($OutFile, $outBytes)

# Checks rapides
$head = [IO.File]::ReadAllBytes($OutFile)
$first3 = if ($head.Length -ge 3) { $head[0..2] } else { $head }
$hasBomOut = ($head.Length -ge 3 -and $head[0] -eq 0xEF -and $head[1] -eq 0xBB -and $head[2] -eq 0xBF)

$nonAsciiSample = ($head | Where-Object { $_ -ge 128 } | Select-Object -First 1)

Write-Host "OK: Conversion terminée"
Write-Host "Input : $InFile"
Write-Host "Output: $OutFile"
Write-Host "Input BOM UTF-8 détecté : $hasUtf8Bom"
Write-Host "Output BOM UTF-8 présent  : $hasBomOut"
Write-Host ("Output first bytes        : " + ($first3 -join " "))
if ($null -eq $nonAsciiSample) {
  Write-Host "Note: le fichier de sortie semble ASCII-only (ANSI et UTF-8 identiques)."
} else {
  Write-Host "Output contient des octets >=128 (non-ASCII) => encodage ANSI visible."
}