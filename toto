package com.bnpparibas.dsibddf.ap00420.streamfact.batch.paymentrequestpaid.writer;

import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.RequestTypeEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.RequestTypeStatusEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.engines.UpdatePaymentRequestResult;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.billingspace.model.PaymentRequest;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.history.model.DocaposteEventHistory;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.history.repository.DocaposteEventHistoryRepository;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.repository.docaposte.DocaposteRepository;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.repository.docaposte.model.DocaposteResponse;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.BillingSpaceEntity;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mockito;
import org.springframework.batch.item.Chunk;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

class PaymentRequestPaidWriterTest {

    @Test
    void write_whenChunkEmpty_doesNothing() throws Exception {
        PaymentRequestPaidWriter writer = new PaymentRequestPaidWriter();

        DocaposteRepository docaposteRepository = Mockito.mock(DocaposteRepository.class);
        DocaposteEventHistoryRepository historyRepo = Mockito.mock(DocaposteEventHistoryRepository.class);

        inject(writer, "docaposteRepository", docaposteRepository);
        inject(writer, "docaposteEventHistoryRepository", historyRepo);
        inject(writer, "serialNumber", "SER-001");

        Chunk<UpdatePaymentRequestResult> chunk = new Chunk<>(Collections.emptyList());

        writer.write(chunk);

        Mockito.verifyNoInteractions(docaposteRepository);
        Mockito.verifyNoInteractions(historyRepo);
    }

    @Test
    void write_whenItemAndDocaposteOk_updatesToSentAndSaves() throws Exception {
        PaymentRequestPaidWriter writer = new PaymentRequestPaidWriter();

        DocaposteRepository docaposteRepository = Mockito.mock(DocaposteRepository.class);
        DocaposteEventHistoryRepository historyRepo = Mockito.mock(DocaposteEventHistoryRepository.class);

        inject(writer, "docaposteRepository", docaposteRepository);
        inject(writer, "docaposteEventHistoryRepository", historyRepo);
        inject(writer, "serialNumber", "SER-001");

        // Mock domain objects
        UpdatePaymentRequestResult uprr = Mockito.mock(UpdatePaymentRequestResult.class);
        PaymentRequest pr = Mockito.mock(PaymentRequest.class);
        Mockito.when(pr.getPaymentRequestId()).thenReturn("PR-1");

        BillingSpaceEntity bse = new BillingSpaceEntity();
        // on suppose le setter présent dans l'entité
        try {
            bse.getClass().getMethod("setLoanFolderId", String.class).invoke(bse, "LF-1");
        } catch (NoSuchMethodException e) {
            // si pas de setter, ignorer : le test vérifiera les autres champs
        }

        Mockito.when(uprr.getPaymentRequestPaidList()).thenReturn(List.of(pr));
        Mockito.when(uprr.getBillingSpace()).thenReturn(bse);

        // Docaposte OK -> retourne un groupId
        DocaposteResponse resp = Mockito.mock(DocaposteResponse.class);
        Mockito.when(resp.getGroupId()).thenReturn("G-123");
        Mockito.when(docaposteRepository.sendDossierBox(Mockito.anyList()))
                .thenReturn(List.of(resp));

        Chunk<UpdatePaymentRequestResult> chunk = new Chunk<>(List.of(uprr));

        writer.write(chunk);

        Mockito.verify(docaposteRepository, Mockito.times(1)).sendDossierBox(Mockito.anyList());

        ArgumentCaptor<DocaposteEventHistory> captor = ArgumentCaptor.forClass(DocaposteEventHistory.class);
        Mockito.verify(historyRepo, Mockito.times(1)).save(captor.capture());

        DocaposteEventHistory saved = captor.getValue();
        Assertions.assertEquals(RequestTypeEnum.PAYMENT_REQUEST_PAID, saved.getRequestType());
        Assertions.assertEquals(RequestTypeStatusEnum.PAYMENT_REQUEST_PAID_SENT, saved.getStatus());
        Assertions.assertEquals("PR-1", saved.getRequestPaymentId());

        // Si l'entité expose le loanFolderId / requestId, vérifie-les
        try {
            Method getLoanFolderId = saved.getClass().getMethod("getLoanFolderId");
            Object lf = getLoanFolderId.invoke(saved);
            Assertions.assertTrue(lf == null || "LF-1".equals(lf)); // tolérant si l'entité ne l’expose pas
        } catch (NoSuchMethodException ignored) { /* champ non exposé => OK */ }

        try {
            Method getRequestId = saved.getClass().getMethod("getRequestId");
            Object rid = getRequestId.invoke(saved);
            Assertions.assertEquals("G-123", rid);
        } catch (NoSuchMethodException ignored) { /* champ non exposé => OK */ }
    }

    @Test
    void write_whenDocaposteThrows_keepsToSendAndSaves() throws Exception {
        PaymentRequestPaidWriter writer = new PaymentRequestPaidWriter();

        DocaposteRepository docaposteRepository = Mockito.mock(DocaposteRepository.class);
        DocaposteEventHistoryRepository historyRepo = Mockito.mock(DocaposteEventHistoryRepository.class);

        inject(writer, "docaposteRepository", docaposteRepository);
        inject(writer, "docaposteEventHistoryRepository", historyRepo);
        inject(writer, "serialNumber", "SER-001");

        UpdatePaymentRequestResult uprr = Mockito.mock(UpdatePaymentRequestResult.class);
        PaymentRequest pr = Mockito.mock(PaymentRequest.class);
        Mockito.when(pr.getPaymentRequestId()).thenReturn("PR-ERR");

        BillingSpaceEntity bse = new BillingSpaceEntity();
        try {
            bse.getClass().getMethod("setLoanFolderId", String.class).invoke(bse, "LF-ERR");
        } catch (NoSuchMethodException ignored) {}

        Mockito.when(uprr.getPaymentRequestPaidList()).thenReturn(List.of(pr));
        Mockito.when(uprr.getBillingSpace()).thenReturn(bse);

        Mockito.when(docaposteRepository.sendDossierBox(Mockito.anyList()))
                .thenThrow(new RuntimeException("BOOM"));

        Chunk<UpdatePaymentRequestResult> chunk = new Chunk<>(Arrays.asList(uprr));

        // Ne doit pas propager l'exception
        writer.write(chunk);

        ArgumentCaptor<DocaposteEventHistory> captor = ArgumentCaptor.forClass(DocaposteEventHistory.class);
        Mockito.verify(historyRepo, Mockito.times(1)).save(captor.capture());

        DocaposteEventHistory saved = captor.getValue();
        Assertions.assertEquals(RequestTypeEnum.PAYMENT_REQUEST_PAID, saved.getRequestType());
        Assertions.assertEquals(RequestTypeStatusEnum.PAYMENT_REQUEST_PAID_TO_SEND, saved.getStatus());
        Assertions.assertEquals("PR-ERR", saved.getRequestPaymentId());
    }

    @Test
    void private_buildDocaposteEventHistory_isCorrect() throws Exception {
        PaymentRequestPaidWriter writer = new PaymentRequestPaidWriter();
        PaymentRequest pr = Mockito.mock(PaymentRequest.class);
        Mockito.when(pr.getPaymentRequestId()).thenReturn("PR-X");

        Method m = PaymentRequestPaidWriter.class.getDeclaredMethod(
                "buildDocaposteEventHistory",
                String.class, PaymentRequest.class, RequestTypeStatusEnum.class
        );
        m.setAccessible(true);

        Object obj = m.invoke(writer, "LF-X", pr, RequestTypeStatusEnum.PAYMENT_REQUEST_PAID_SENT);
        Assertions.assertTrue(obj instanceof DocaposteEventHistory);
        DocaposteEventHistory h = (DocaposteEventHistory) obj;

        Assertions.assertEquals(RequestTypeEnum.PAYMENT_REQUEST_PAID, h.getRequestType());
        Assertions.assertEquals(RequestTypeStatusEnum.PAYMENT_REQUEST_PAID_SENT, h.getStatus());
        Assertions.assertEquals("PR-X", h.getRequestPaymentId());

        // Vérifie (si exposé) le loanFolderId et l’eventId non nul
        try {
            Method getLoanFolderId = h.getClass().getMethod("getLoanFolderId");
            Object lf = getLoanFolderId.invoke(h);
            Assertions.assertTrue(lf == null || "LF-X".equals(lf));
        } catch (NoSuchMethodException ignored) {}

        try {
            Method getEventId = h.getClass().getMethod("getEventId");
            Object eid = getEventId.invoke(h);
            Assertions.assertNotNull(eid);
        } catch (NoSuchMethodException ignored) {}
    }

    // --- helpers ---

    private static void inject(Object target, String field, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(field);
            f.setAccessible(true);
            f.set(target, value);
        } catch (Exception e) {
            throw new RuntimeException("Injection failed for field: " + field, e);
        }
    }
}
