package com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.service.batch.security.openpgp;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import org.junit.rules.TemporaryFolder;
import org.mockito.MockedConstruction;
import org.mockito.MockedStatic;
import org.mockito.junit.MockitoJUnitRunner;

import java.io.*;
import java.security.KeyStore;
import java.security.PrivateKey as JcaPrivateKey; // alias not allowed in Java; remove this line
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.time.Instant;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

import org.bouncycastle.bcpg.sig.KeyFlags;
import org.bouncycastle.openpgp.*;
import org.bouncycastle.openpgp.operator.jcajce.JcaKeyFingerprintCalculator;
import org.bouncycastle.openpgp.operator.jcajce.JcaPGPKeyConverter;
import org.bouncycastle.openpgp.operator.jcajce.JcaPGPContentSignerBuilder;
import org.bouncycastle.openpgp.operator.jcajce.JcePBESecretKeyDecryptorBuilder;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * JUnit 4 only – compatible Sonar/Jacoco/Jenkins.
 * - Pas de JUnit Jupiter ni AssertJ.
 * - @RunWith(MockitoJUnitRunner.class), @Before, assertions JUnit 4.
 * - Mock de PGPUtil (static), et des constructeurs PGP* + flux custom (Encrypted*/Compressed*/Literal*).
 */
@RunWith(MockitoJUnitRunner.class)
public class OnePassSignatureProcessorTest {

    @Rule
    public TemporaryFolder tmp = new TemporaryFolder();

    private OnePassSignatureProcessor cut;

    private File originalFile;
    private File encryptedOutArmored;
    private File encryptedIn;
    private File decryptedOut;
    private File partnerPubRenewed;
    private File partnerPubOld;
    private File ownPrivPgp;
    private File ownPrivKs;         // PKCS12 factice

    @Before
    public void setUp() throws Exception {
        cut = new OnePassSignatureProcessor();

        originalFile = tmp.newFile("original.txt");
        try (FileOutputStream fos = new FileOutputStream(originalFile)) {
            fos.write("HELLO_WORLD\n".getBytes("UTF-8"));
        }
        encryptedOutArmored = tmp.newFile("out.asc");
        encryptedIn = tmp.newFile("enc.bin"); // simulé comme "chiffré"
        try (FileOutputStream fos = new FileOutputStream(encryptedIn)) {
            fos.write(new byte[]{1,2,3,4}); // juste pour que length>0
        }
        decryptedOut = tmp.newFile("dec.out");

        partnerPubRenewed = tmp.newFile("partner_renewed.asc");
        try (FileOutputStream fos = new FileOutputStream(partnerPubRenewed)) {
            fos.write(new byte[]{7,7,7});
        }
        partnerPubOld = tmp.newFile("partner_old.asc"); // vide -> non utilisé
        // laisser vide pour couvrir existsAndNotEmptyContent=false

        ownPrivPgp = tmp.newFile("own_priv.asc");
        try (FileOutputStream fos = new FileOutputStream(ownPrivPgp)) {
            fos.write(new byte[]{9,9,9});
        }
        ownPrivKs = tmp.newFile("own_keystore.p12");
        try (FileOutputStream fos = new FileOutputStream(ownPrivKs)) {
            fos.write(new byte[]{5,5,5});
        }
    }

    // ---------- UTILITAIRES DE MOCK ----------

    private PGPPublicKey mockEncryptKey(long id, boolean master, boolean matchUsage, boolean valid) {
        PGPPublicKey k = mock(PGPPublicKey.class);
        when(k.getKeyID()).thenReturn(id);
        when(k.isEncryptionKey()).thenReturn(true);
        when(k.isMasterKey()).thenReturn(master);
        if (valid) {
            when(k.getValidSeconds()).thenReturn(0L); // toujours valide
        } else {
            when(k.getValidSeconds()).thenReturn(60L);
            Date creation = Date.from(Instant.now().minusSeconds(3600));
            when(k.getCreationTime()).thenReturn(creation);
        }
        // hasKeyFlags(...) -> true si signatures iterator vide, false si une signature non conforme
        if (matchUsage) {
            when(k.getSignaturesOfType(anyInt())).thenReturn(Collections.<PGPSignature>emptyList().iterator());
        } else {
            PGPSignature sig = mock(PGPSignature.class);
            PGPSignatureSubpacketVector vec = mock(PGPSignatureSubpacketVector.class);
            when(sig.hasSubpackets()).thenReturn(true);
            when(sig.getHashedSubPackets()).thenReturn(vec);
            // KEY_FLAGS présent mais ne contient pas le bit usage -> provoque false
            when(vec.hasSubpacket(eq(27))).thenReturn(true);
            when(vec.getKeyFlags()).thenReturn(KeyFlags.CERTIFY_OTHER); // pas ENCRYPT ni SIGN
            when(k.getSignaturesOfType(anyInt())).thenReturn(Collections.singletonList(sig).iterator());
        }
        return k;
    }

    private PGPSecretKey mockSigningSecretKey(long id) throws PGPException {
        PGPSecretKey sk = mock(PGPSecretKey.class);
        PGPPublicKey pk = mock(PGPPublicKey.class);
        when(sk.getKeyID()).thenReturn(id);
        when(sk.isSigningKey()).thenReturn(true);
        when(sk.getPublicKey()).thenReturn(pk);
        when(pk.getValidSeconds()).thenReturn(0L);
        @SuppressWarnings("unchecked")
        Iterator<String> uids = Collections.singletonList("user@test").iterator();
        when(pk.getUserIDs()).thenReturn(uids);

        PGPPrivateKey priv = mock(PGPPrivateKey.class);
        when(sk.extractPrivateKey(any())).thenReturn(priv);
        return sk;
    }

    private PrivateKeyPair mockPrivateKeyPair(String pgpPath, String ksPath, String pass, String alias) {
        PrivateKeyPair pkPair = mock(PrivateKeyPair.class);
        PrivateKey pgp = mock(PrivateKey.class);
        when(pgp.getPrivateKeyPath()).thenReturn(pgpPath);
        when(pgp.getPassphrase()).thenReturn(pass);
        when(pgp.getAlias()).thenReturn(null);

        PrivateKey ks = mock(PrivateKey.class);
        when(ks.getPrivateKeyPath()).thenReturn(ksPath);
        when(ks.getPassphrase()).thenReturn(pass);
        when(ks.getAlias()).thenReturn(alias);

        when(pkPair.getPrivateKey()).thenReturn(pgp);
        when(pkPair.getRenewedPrivateKey()).thenReturn(ks);
        return pkPair;
    }

    private PartnerPublicKeyPair mockPartner(String oldPath, String renewedPath) {
        PartnerPublicKeyPair p = mock(PartnerPublicKeyPair.class);
        when(p.getPublicKeyPath()).thenReturn(oldPath);
        when(p.getRenewedPublicKeyPath()).thenReturn(renewedPath);
        return p;
    }

    // ---------- TESTS ----------

    /**
     * Chemin "happy path" chiffrement + signature + armor + textMode :
     * - clé publique partenaire trouvée (la renouvelée)
     * - signature initialisée, update pendant l'écriture, puis generate()
     * - toutes les couches de flux construites et fermées
     */
    @Test
    public void encrypt_with_signature_armor_textmode_success() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(partnerPubOld.getAbsolutePath(), partnerPubRenewed.getAbsolutePath());
        PrivateKeyPair privateKeyPair = mockPrivateKeyPair(ownPrivPgp.getAbsolutePath(), null, "pass", null);

        // Compteur pour distinguer les appels à PGPUtil.getDecoderStream
        AtomicInteger decCalls = new AtomicInteger(0);

        // Mocks des anneaux public/privé
        PGPPublicKey validEncKey = mockEncryptKey(0x11L, false, true, true);
        PGPPublicKey expiredEncKey = mockEncryptKey(0x10L, false, true, false); // exercera isValidPGPPublicKey -> false

        PGPSecretKey signKey = mockSigningSecretKey(0x22L);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPPublicKeyRing> pubRingCons = mockConstruction(PGPPublicKeyRing.class, (mock, ctx) -> {
                 when(mock.getPublicKeys()).thenReturn(Arrays.asList(expiredEncKey, validEncKey).iterator());
             });
             MockedConstruction<PGPSecretKeyRing> secRingCons = mockConstruction(PGPSecretKeyRing.class, (mock, ctx) -> {
                 when(mock.getSecretKeys()).thenReturn(Collections.singletonList(signKey).iterator());
             });
             MockedConstruction<JcaPGPKeyConverter> convCons = mockConstruction(JcaPGPKeyConverter.class);
             MockedConstruction<PGPSignatureGenerator> sigGenCons = mockConstruction(PGPSignatureGenerator.class, (sg, ctx) -> {
                 PGPOnePassSignature ops = mock(PGPOnePassSignature.class);
                 when(sg.generateOnePassVersion(eq(false))).thenReturn(ops);
                 doNothing().when(ops).encode(any(OutputStream.class));
                 PGPSignature fin = mock(PGPSignature.class);
                 when(sg.generate()).thenReturn(fin);
                 doNothing().when(fin).encode(any(OutputStream.class));
             });
             MockedConstruction<EncryptedOutputStream> encOutCons = mockConstruction(EncryptedOutputStream.class);
             MockedConstruction<CompressedDataOutputStream> compOutCons = mockConstruction(CompressedDataOutputStream.class);
             MockedConstruction<LiteralDataOutputStream> litOutCons = mockConstruction(LiteralDataOutputStream.class, (lit, ctx) -> {
                 doNothing().when(lit).write(any(byte[].class), anyInt(), anyInt());
             })
        ) {
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class))).thenAnswer(inv -> {
                decCalls.incrementAndGet();
                return new ByteArrayInputStream(new byte[0]);
            });

            cut.encryptOnePassSignature(
                    encryptedOutArmored.getAbsolutePath(),
                    originalFile.getAbsolutePath(),
                    Collections.singletonList(partner),
                    privateKeyPair,
                    true,   // signature
                    true,   // text mode
                    true    // armor
            );

            // Vérifie que les flux de données ont été utilisés
            assertTrue(encryptedOutArmored.length() >= 0); // simple smoke check

            // Le générateur de signature a bien été construit et utilisé (update + generate)
            PGPSignatureGenerator sg = sigGenCons.constructed().isEmpty() ? null : sigGenCons.constructed().get(0);
            assertNotNull(sg);
            verify(sg, atLeastOnce()).update(any(byte[].class), anyInt(), anyInt());
            verify(sg, times(1)).generate();
        }
    }

    /**
     * Chiffrement SANS signature (armor=false), doit éviter toute construction de PGPSignatureGenerator.
     */
    @Test
    public void encrypt_without_signature_no_armor_success() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(partnerPubOld.getAbsolutePath(), partnerPubRenewed.getAbsolutePath());

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPPublicKeyRing> pubRingCons = mockConstruction(PGPPublicKeyRing.class, (mock, ctx) -> {
                 PGPPublicKey validEncKey = mockEncryptKey(0x33L, false, true, true);
                 when(mock.getPublicKeys()).thenReturn(Collections.singletonList(validEncKey).iterator());
             });
             MockedConstruction<PGPSignatureGenerator> sigGenCons = mockConstruction(PGPSignatureGenerator.class);
             MockedConstruction<EncryptedOutputStream> encOutCons = mockConstruction(EncryptedOutputStream.class);
             MockedConstruction<CompressedDataOutputStream> compOutCons = mockConstruction(CompressedDataOutputStream.class);
             MockedConstruction<LiteralDataOutputStream> litOutCons = mockConstruction(LiteralDataOutputStream.class, (lit, ctx) -> {
                 doNothing().when(lit).write(any(byte[].class), anyInt(), anyInt());
             })
        ) {
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class)))
                .thenReturn(new ByteArrayInputStream(new byte[0]));

            cut.encryptOnePassSignature(
                    encryptedOutArmored.getAbsolutePath(),
                    originalFile.getAbsolutePath(),
                    Collections.singletonList(partner),
                    null,   // privateKeyPair non utilisé
                    false,  // pas de signature
                    false,  // pas text mode
                    false   // pas armor
            );

            // Aucune construction de PGPSignatureGenerator ne doit avoir eu lieu
            assertEquals(0, sigGenCons.constructed().size());
        }
    }

    /** Pas de partenaires -> IAE */
    @Test
    public void encrypt_no_partners_throws_IAE() {
        try {
            cut.encryptOnePassSignature(
                    encryptedOutArmored.getAbsolutePath(),
                    originalFile.getAbsolutePath(),
                    Collections.<PartnerPublicKeyPair>emptyList(),
                    null,
                    false, false, false
            );
            fail("Expected IllegalArgumentException");
        } catch (Exception ex) {
            assertTrue(ex instanceof IllegalArgumentException);
            assertTrue(ex.getMessage().contains("No partner PGP public key file provided for encryption"));
        }
    }

    /**
     * Chemin déchiffrement + vérification de signature :
     * - Private keys collectées depuis fichier PGP
     * - Public keys partenaires collectées (2 fichiers)
     * - EncryptedInputStream mocké : read->calculateSignature->verifySignature->verifyIntegrity
     */
    @Test
    public void decrypt_with_signature_success() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(partnerPubOld.getAbsolutePath(), partnerPubRenewed.getAbsolutePath());
        PrivateKeyPair privateKeyPair = mockPrivateKeyPair(ownPrivPgp.getAbsolutePath(), null, "pass", null);

        PGPPrivateKey priv1 = mock(PGPPrivateKey.class);
        when(priv1.getKeyID()).thenReturn(0x41L);

        PGPSecretKey sk = mockSigningSecretKey(0x42L);
        when(sk.extractPrivateKey(any())).thenReturn(priv1);

        // Public keys pour vérification
        PGPPublicKey pubA = mockEncryptKey(0x51L, false, true, true);
        PGPPublicKey pubB = mockEncryptKey(0x52L, true, true, true);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPSecretKeyRing> secRingCons = mockConstruction(PGPSecretKeyRing.class, (mock, ctx) -> {
                 when(mock.getSecretKeys()).thenReturn(Collections.singletonList(sk).iterator());
             });
             MockedConstruction<PGPPublicKeyRing> pubRingCons = mockConstruction(PGPPublicKeyRing.class, (mock, ctx) -> {
                 when(mock.getPublicKeys()).thenReturn(Arrays.asList(pubA, pubB).iterator());
             });
             MockedConstruction<EncryptedInputStream> encInCons = mockConstruction(EncryptedInputStream.class, (ins, ctx) -> {
                 when(ins.read(any(byte[].class), anyInt(), anyInt())).thenReturn(4).thenReturn(-1);
                 doNothing().when(ins).calculateSignature(any(byte[].class), anyInt(), anyInt());
                 doNothing().when(ins).verifySignature();
                 doNothing().when(ins).verifyIntegrity();
             })
        ) {
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class)))
                .thenReturn(new ByteArrayInputStream(new byte[0]));

            cut.decryptOnePassSignature(
                    encryptedIn.getAbsolutePath(),
                    Collections.singletonList(partner),
                    privateKeyPair,
                    decryptedOut.getAbsolutePath(),
                    true // verify signature
            );

            // EncryptedInputStream construit et utilisé
            assertEquals(1, encInCons.constructed().size());
            EncryptedInputStream ins = encInCons.constructed().get(0);
            verify(ins, atLeastOnce()).calculateSignature(any(byte[].class), anyInt(), anyInt());
            verify(ins, times(1)).verifySignature();
            verify(ins, times(1)).verifyIntegrity();
        }
    }

    /** Déchiffrement avec verifySignature=true mais aucun partner -> IAE */
    @Test
    public void decrypt_with_signature_no_partners_throws_IAE() {
        PrivateKeyPair privateKeyPair = mockPrivateKeyPair(ownPrivPgp.getAbsolutePath(), null, "pass", null);
        try {
            cut.decryptOnePassSignature(
                    encryptedIn.getAbsolutePath(),
                    Collections.<PartnerPublicKeyPair>emptyList(),
                    privateKeyPair,
                    decryptedOut.getAbsolutePath(),
                    true
            );
            fail("Expected IllegalArgumentException");
        } catch (Exception ex) {
            assertTrue(ex instanceof IllegalArgumentException);
            assertTrue(ex.getMessage().contains("No partner PGP public key file provided for signature verification"));
        }
    }

    /** Déchiffrement sans privateKeyPair -> IAE */
    @Test
    public void decrypt_without_private_key_pair_throws_IAE() {
        try {
            cut.decryptOnePassSignature(
                    encryptedIn.getAbsolutePath(),
                    null,
                    null,
                    decryptedOut.getAbsolutePath(),
                    false
            );
            fail("Expected IllegalArgumentException");
        } catch (Exception ex) {
            assertTrue(ex instanceof IllegalArgumentException);
            assertTrue(ex.getMessage().contains("No PGP private key file provided for decryption"));
        }
    }

    /**
     * Forcer le chemin keystore (isPGPKeyFile=false) pour couvrir readSecretKeyFromKeystore :
     * - 1er getDecoderStream OK (public key)
     * - 2e getDecoderStream lève IOException (isPGPKeyFile -> false)
     * - KeyStore statique mocké, conversion JCA->PGP mockée, PGPSecretKey construit (mockConstruction)
     */
    @Test
    public void encrypt_signature_uses_keystore_when_pgp_check_fails() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(null, partnerPubRenewed.getAbsolutePath());
        PrivateKeyPair privateKeyPair = mockPrivateKeyPair(null, ownPrivKs.getAbsolutePath(), "passKs", "myAlias");

        PGPPublicKey validEncKey = mockEncryptKey(0x61L, false, true, true);

        // Keystore / Certificats mockés
        KeyStore ks = mock(KeyStore.class);
        X509Certificate cert = mock(X509Certificate.class);
        PublicKey jcaPub = mock(PublicKey.class);
        JcaPrivateKey jcaPriv = mock(JcaPrivateKey.class); // cannot import alias; use java.security.PrivateKey

        when(cert.getPublicKey()).thenReturn(jcaPub);
        when(cert.getNotBefore()).thenReturn(new Date(System.currentTimeMillis() - 1000));
        when(cert.getNotAfter()).thenReturn(new Date(System.currentTimeMillis() + 86_400_000));

        Enumeration<String> aliases = Collections.enumeration(Collections.singleton("myAlias"));
        when(ks.aliases()).thenReturn(aliases);
        when(ks.getKey(eq("myAlias"), any(char[].class))).thenReturn(jcaPriv);
        when(ks.getCertificate(eq("myAlias"))).thenReturn(cert);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedStatic<KeyStore> ksStatic = mockStatic(KeyStore.class);
             MockedConstruction<PGPPublicKeyRing> pubRingCons = mockConstruction(PGPPublicKeyRing.class, (mock, ctx) -> {
                 when(mock.getPublicKeys()).thenReturn(Collections.singletonList(validEncKey).iterator());
             });
             MockedConstruction<JcaPGPKeyConverter> convCons = mockConstruction(JcaPGPKeyConverter.class, (cvt, ctx) -> {
                 PGPPublicKey pgpPub = mock(PGPPublicKey.class);
                 PGPPrivateKey pgpPriv = mock(PGPPrivateKey.class);
                 when(cvt.getPGPPublicKey(anyInt(), any(PublicKey.class), any(Date.class))).thenReturn(pgpPub);
                 when(cvt.getPGPPrivateKey(any(PGPPublicKey.class), any(JcaPrivateKey.class))).thenReturn(pgpPriv);
             });
             MockedConstruction<PGPSecretKey> pgpSecCons = mockConstruction(PGPSecretKey.class, (psk, ctx) -> {
                 when(psk.getKeyID()).thenReturn(0x71L);
             });
             MockedConstruction<EncryptedOutputStream> encOutCons = mockConstruction(EncryptedOutputStream.class);
             MockedConstruction<CompressedDataOutputStream> compOutCons = mockConstruction(CompressedDataOutputStream.class);
             MockedConstruction<LiteralDataOutputStream> litOutCons = mockConstruction(LiteralDataOutputStream.class, (lit, ctx) -> {
                 doNothing().when(lit).write(any(byte[].class), anyInt(), anyInt());
             })
        ) {
            // getInstance("PKCS12","SunJSSE") -> renvoie notre mock keystore
            ksStatic.when(() -> KeyStore.getInstance(eq("PKCS12"), eq("SunJSSE"))).thenReturn(ks);

            // 1er appel pour clé publique -> OK; 2e (isPGPKeyFile sur keystore) -> IOException => false
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class)))
                .thenReturn(new ByteArrayInputStream(new byte[0]))
                .thenThrow(new IOException("not a pgp key"));

            cut.encryptOnePassSignature(
                    encryptedOutArmored.getAbsolutePath(),
                    originalFile.getAbsolutePath(),
                    Collections.singletonList(partner),
                    privateKeyPair,
                    true,  // signature -> utilisera keystore
                    false,
                    false
            );

            // PGPSecretKey créé via keystore
            assertEquals(1, pgpSecCons.constructed().size());
        }
    }

    /** Couvrir branche "aucune clé chiffrage valide" (hasKeyFlags faux + clé expirée) -> IAE */
    @Test
    public void encrypt_no_valid_encryption_key_throws_IAE() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(null, partnerPubRenewed.getAbsolutePath());

        // Clé master avec usage incompatible -> hasKeyFlags false
        PGPPublicKey badUsage = mockEncryptKey(0x81L, true, false, true);
        // Puis clé expirée -> isValidPGPPublicKey false
        PGPPublicKey expired = mockEncryptKey(0x82L, false, true, false);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPPublicKeyRing> pubRingCons = mockConstruction(PGPPublicKeyRing.class, (mock, ctx) -> {
                 when(mock.getPublicKeys()).thenReturn(Arrays.asList(badUsage, expired).iterator());
             })
        ) {
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class))).thenReturn(new ByteArrayInputStream(new byte[0]));

            try {
                cut.encryptOnePassSignature(
                        encryptedOutArmored.getAbsolutePath(),
                        originalFile.getAbsolutePath(),
                        Collections.singletonList(partner),
                        null,
                        false, false, false
                );
                fail("Expected IllegalArgumentException");
            } catch (IllegalArgumentException ex) {
                assertTrue(ex.getMessage().contains("No valid PGP public key found"));
            }
        }
    }

    /**
     * Déchiffrement : aucun private key récupéré (fichiers vides) -> IAE explicite.
     * Exerce existsAndNotEmptyContent -> false et le message agrégé.
     */
    @Test
    public void decrypt_no_private_key_found_throws_IAE() {
        // Construit un couple de private keys pointant sur des fichiers vides
        File empty1 = new File(tmp.getRoot(), "empty1.asc");
        File empty2 = new File(tmp.getRoot(), "empty2.p12");
        // ne pas écrire dedans -> length=0

        PrivateKeyPair pkPair = mockPrivateKeyPair(empty1.getAbsolutePath(), empty2.getAbsolutePath(), "pass", "alias");

        try {
            cut.decryptOnePassSignature(
                    encryptedIn.getAbsolutePath(),
                    null,
                    pkPair,
                    decryptedOut.getAbsolutePath(),
                    false
            );
            fail("Expected IllegalArgumentException");
        } catch (IllegalArgumentException ex) {
            assertTrue(ex.getMessage().contains("No PGP private key found from files"));
        }
    }

    /**
     * Exemple d’usage de verifyNoInteractions(...) (exigence): on s’assure
     * qu’aucune interaction n’a eu lieu avec un mock volontairement hors-flux.
     */
    @Test
    public void noop_verifyNoInteractions_example() {
        PGPSignatureGenerator neverUsed = mock(PGPSignatureGenerator.class);
        verifyNoInteractions(neverUsed);
    }
}
