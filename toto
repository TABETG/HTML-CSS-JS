Top — on garde le pom.xml tel quel. Voilà un plan court + concret avec des tests prêts à coller pour booster la couverture > 80 % en ciblant les classes à logique. J’utilise uniquement JUnit5/Mockito/Spring Boot Test (normalement déjà présents dans ton projet).


---

Où gagner vite (priorité)

LoadDailyMeteorFileTasklet (parsing + archivage).  

PurgeDpoTableTasklet (calcul de date + repository). 

SendMailDPOTasklet (filtrage par nature + appel service mail). 

LoanFolderSynchroItemWriter (filtre + saveAll). 

EventHistorySynchroItemWriter (règle “commercialRelationShip only”). 



---

Exemples de tests (copie/colle)

> Place-les sous src/test/java/... en respectant les packages réels.



1) LoadDailyMeteorFileTaskletTest

Couvre: parsing ligne “02…”, convertIdProtToContractType, archivage quand succès, et cas “no file”.

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.dailymeteorintegration.tasklet;

import org.junit.jupiter.api.*;
import org.mockito.*;
import java.io.*;
import java.math.BigDecimal;
import java.nio.file.Files;
import java.time.LocalDateTime;
import java.util.*;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

class LoadDailyMeteorFileTaskletTest {

  @Mock private com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.meteorflux.repository.MeteorFluxRepository repo;
  @Mock private com.bnpparibas.dsibddf.ap00420.streamfact.batch.dailymeteorintegration.manager.FileManager fileManager;

  private LoadDailyMeteorFileTasklet tasklet;

  @BeforeEach
  void init() {
    MockitoAnnotations.openMocks(this);
    tasklet = new LoadDailyMeteorFileTasklet(repo, fileManager); // 6
  }

  @Test
  void execute_shouldArchive_whenParseOk_andNotExistsInDb() throws Exception {
    // ligne commençant par "02", avec les sous-chaînes aux index utilisés par le parser (cf. code source) 7
    StringBuilder line = new StringBuilder("02");
    line.append(pad("LOADACCOUNT1234567890123", 23)); // [2,25)
    line.append(pad("", 63));                          // [25,88)
    line.append("001");                                // idProt [88,91) -> PRI
    line.append(pad("0000000000000123", 16));          // personalContribution [91,107)
    line.append(pad("0000000000000456", 16));          // purchase [107,123)
    line.append(pad("0000000000000789", 16));          // renovation [123,139)
    line.append(pad("", 32));                          // [139,171)
    line.append(pad("0000000000000123", 16));          // land [171,187)
    line.append(pad("", 370));                         // [187,557)
    line.append(pad("LOANFOLDER_ID_ABCDEF", 23));      // [557,580)

    File tmp = File.createTempFile("meteor", ".txt");
    Files.writeString(tmp.toPath(), line.toString() + System.lineSeparator());

    com.bnpparibas.dsibddf.ap00420.streamfact.batch.dailymeteorintegration.model.MeteorFile mf =
        new com.bnpparibas.dsibddf.ap00420.streamfact.batch.dailymeteorintegration.model.MeteorFile(tmp, "name");
    when(fileManager.getFiles()).thenReturn(List.of(mf));
    when(repo.existsByLoanAccountNumber("LOADACCOUNT1234567890123")).thenReturn(false);

    var rs = tasklet.execute(null, null);
    assertNotNull(rs);
    verify(repo).saveAll(anyList());
    verify(fileManager).archiveFile(mf);
  }

  @Test
  void execute_shouldWarn_whenNoFile() throws Exception {
    when(fileManager.getFiles()).thenReturn(Collections.emptyList());
    var rs = tasklet.execute(null, null);
    assertNotNull(rs);
    verifyNoInteractions(repo);
  }

  // util
  private static String pad(String v, int len) {
    String s = v == null ? "" : v;
    if (s.length() > len) return s.substring(0, len);
    return s + " ".repeat(len - s.length());
  }
}

> Référence: parsing des champs (indices + types) et appel archiveFile après succès.  




---

2) PurgeDpoTableTaskletTest

Couvre: purgeNumberOfDays, calcul date et appel repo. 

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.dpo.tasklet;

import org.junit.jupiter.api.*;
import org.mockito.*;
import org.springframework.test.util.ReflectionTestUtils;
import java.time.LocalDate;
import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

class PurgeDpoTableTaskletTest {

  @Mock private com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.history.repository.DPOMailToSendRepository repo;
  private PurgeDpoTableTasklet tasklet;

  @BeforeEach
  void init() {
    MockitoAnnotations.openMocks(this);
    tasklet = new PurgeDpoTableTasklet();
    ReflectionTestUtils.setField(tasklet, "dpoMailToSendRepository", repo);
    ReflectionTestUtils.setField(tasklet, "purgeNumberOfDays", 15); // default du code 11
  }

  @Test
  void execute_shouldDeleteWithComputedDate() throws Exception {
    var rs = tasklet.execute(null, null);
    assertNotNull(rs);
    verify(repo, times(1)).deleteWithSendTrueAndSendDate(LocalDate.now().minusDays(15));
  }

  @Test
  void execute_shouldFail_whenPurgeDaysNull() {
    ReflectionTestUtils.setField(tasklet, "purgeNumberOfDays", null);
    assertThrows(IllegalArgumentException.class, () -> tasklet.execute(null, null)); // Assert.notNull(...) 12
  }
}


---

3) SendMailDPOTaskletTest

Couvre: filtrage par ProblemNatureEnum + appel service mail. 

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.dpo.tasklet;

import org.junit.jupiter.api.*;
import org.mockito.*;
import java.util.*;
import static org.mockito.Mockito.*;

class SendMailDPOTaskletTest {

  @Mock private com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.history.repository.DPOMailToSendRepository repo;
  @Mock private com.bnpparibas.dsibddf.ap00420.streamfact.application.dpo.DPOMailSenderServiceImpl sender;
  private SendMailDPOTasklet tasklet;

  @BeforeEach
  void init() {
    MockitoAnnotations.openMocks(this);
    tasklet = new SendMailDPOTasklet();
    org.springframework.test.util.ReflectionTestUtils.setField(tasklet, "dpoMailToSendRepository", repo);
    org.springframework.test.util.ReflectionTestUtils.setField(tasklet, "dpoMailSenderService", sender);
  }

  @Test
  void execute_shouldSend_whenListsNotEmpty() throws Exception {
    var mail = new com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.history.model.DPOMailToSend();
    // on simule une liste non envoyée (flag false) renvoyée par le repo 14
    when(repo.findByIsSend(false)).thenReturn(List.of(mail));
    // le service `execute` sera appelé pour les listes filtrées par nature (TECHNICAL / FUNCTIONAL)
    doNothing().when(sender).execute(anyList());

    var rs = tasklet.execute(null, null);
    assertNotNull(rs);
    verify(sender, atLeastOnce()).execute(anyList());
  }
}


---

4) LoanFolderSynchroItemWriterTest

Couvre: filtre hasSynchronisation + saveAll. 

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.update.writer;

import org.junit.jupiter.api.*;
import org.mockito.*;
import org.springframework.batch.item.Chunk;
import java.util.*;
import static org.mockito.Mockito.*;

class LoanFolderSynchroItemWriterTest {

  @Mock private com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.loanfolder.repository.LoanFolderAnswerJpaRepository jpaRepo;
  private LoanFolderSynchroItemWriter writer;

  @BeforeEach
  void init() {
    MockitoAnnotations.openMocks(this);
    writer = new LoanFolderSynchroItemWriter();
    org.springframework.test.util.ReflectionTestUtils.setField(writer, "loanFolderAnswerJpaRepository", jpaRepo);
  }

  @Test
  void write_shouldSaveAll_onlyWhenSynchroResultPresent() {
    var withSynchro = new com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.SynchroResult();
    var lr = new com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.LoanFolderSynchroResult();
    lr.setLoanFolder(new com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.LoanFolder());
    withSynchro.setLoanFolderSynchroResult(lr);

    var withoutSynchro = new com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.SynchroResult();

    writer.write(Chunk.of(withSynchro, withoutSynchro)); // .filter(...) + saveAll(...) 16
    verify(jpaRepo, times(1)).saveAll(anyList());
  }
}


---

5) EventHistorySynchroItemWriterTest

Couvre: règle “si uniquement commercialRelationShip, ne pas créer d’événement” (la méthode retourne false quand la liste filtrée n’est pas vide). 

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.update.writer;

import org.junit.jupiter.api.*;
import org.mockito.*;
import org.springframework.batch.item.Chunk;
import java.util.*;
import static org.mockito.Mockito.*;

class EventHistorySynchroItemWriterTest {

  @Mock private com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.history.repository.DocaposteEventHistoryJpaRepository histRepo;
  private EventHistorySynchroItemWriter writer;

  @BeforeEach
  void init() {
    MockitoAnnotations.openMocks(this);
    writer = new EventHistorySynchroItemWriter();
    org.springframework.test.util.ReflectionTestUtils.setField(writer, "docaposteEventHistoryJpaRepository", histRepo);
  }

  @Test
  void write_shouldSkip_whenOnlyCommercialRelationShipUpdated() {
    var contract = new com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.ContractLoandFolderAnalysis();
    var data = new com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.SynchroAnalysisData();
    data.setFiledName("commercialRelationShip");
    contract.setSynchroAnalysisDatas(List.of(data));

    var lfa = new com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.LoanFolderSynchroAnalysis();
    lfa.setContractLoandFolderAnalysisList(List.of(contract));

    var lfr = new com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.LoanFolderSynchroResult();
    lfr.setLoanFolderSynchroAnalysis(lfa);

    var sr = new com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.SynchroResult();
    sr.setLoanFolderSynchroResult(lfr);

    writer.write(Chunk.of(sr)); // checkContractUpdateOnlyCommercialRelationShip(...) => pas d'insert 18
    verify(histRepo, never()).save(any());
  }
}


---

Lancer et lire la couverture (sans toucher au pom)

IntelliJ: Run > Run Tests with Coverage puis ouvre le rapport JaCoCo d’IntelliJ.

CLI: mvn -Dtest=*Test test (le JaCoCo du projet/IntelliJ générera le rapport).

Vise d’abord ces 5 classes : tu devrais déjà prendre +30–50 pts de couverture globale.

Ajoute ensuite des tests “faciles” sur:

DeleteDpoTableImageTasklet (appel repo). 

La conf JobConfigurationBillingSpaceSynchro via un smoke test de contexte (bean présent). 




---

Pourquoi ça monte vite

Chaque test tape de la logique réelle du code cité (parsing, filtres, règles de métier) : unitairement, peu de lignes, beaucoup de branches couvertes.

Les Tasklet/ItemWriter sont idéaux: pas de contexte Spring complet requis (mocks suffisent).


Si tu veux, je te fournis d’autres tests ciblés (ex: EncryptedInputStream avec faux blocs PGP pour couvrir le parcours “marker” + “encrypted list”).  

Tu peux commencer avec ces 5 fichiers, lancer la couverture, et on complète au besoin pour dépasser les 80 %.