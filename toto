package com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.tasklet;

import com.bnpparibas.dsibddf.ap00420.streamfact.application.cft.TransfertManager;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.cft.TransferDetails;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.cft.TransferRequestResult;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.cft.TransferRequestResultLinks;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.cft.TransferRequestSendFileBody;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.UnexpectedJobExecutionException;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.web.client.HttpClientErrorException;

import java.net.URI;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

/**
 * Tests JUnit 4 pour SendToBMDSendCFTTasklet.
 *
 * Couverture:
 *  - mock=true : FINISHED, aucun appel CFT
 *  - create phase : succès 2xx → CONTINUABLE et transfertURI en contexte
 *  - create phase : HTTP non 2xx → contribution FAILED + FINISHED
 *  - create phase : HttpClientErrorException → FINISHED
 *  - check phase : diagi=0 → FINISHED
 *  - check phase : diagi=144 → CONTINUABLE (pause)
 *  - check phase : diagi autre → contribution FAILED + FINISHED
 *  - utilitaires isTransferComplete/isTransferBusy + setters
 *
 * Contraintes: JUnit4 uniquement, MockitoJUnitRunner, pas d’AssertJ, verifyNoInteractions(...)
 */
@RunWith(MockitoJUnitRunner.class)
public class SendToBMDSendCFTTaskletTest {

    @InjectMocks
    private SendToBMDSendCFTTasklet tasklet;

    @Mock
    private TransfertManager transfertManager;

    private StepExecution stepExecution;
    private StepContribution contribution;

    @Before
    public void setUp() {
        JobExecution jobExecution = new JobExecution(1L);
        stepExecution = new StepExecution("sendToBMDSendCFT", jobExecution);
        contribution = new StepContribution(stepExecution);

        tasklet.setPart("PART");
        tasklet.setIdf("IDF");
        tasklet.setApiTimeout(30);
        tasklet.setTransfertManager(transfertManager);

        putEncryptedFileName("file.enc");
        // utilisé par la classe pour composer fname
        ReflectionTestUtils.setField(tasklet, "objectKeyNewToSend", "obj/new");
    }

    /** Branche mock=true : pas d'appel réseau, FINISHED. */
    @Test
    public void execute_when_mock_true_should_finish_without_cft_calls() throws Exception {
        tasklet.setMock(true);

        RepeatStatus status = tasklet.execute(contribution, new ChunkContext(new StepContext(stepExecution)));

        assertEquals(RepeatStatus.FINISHED, status);
        verifyNoInteractions(transfertManager);
    }

    /**
     * 1er passage (create) : succès 2xx.
     * Correction clé: getLinks() doit renvoyer un TransferRequestResultLinks, pas un Object.
     */
    @Test
    public void execute_create_phase_success_should_be_continuable_and_set_transfer_uri() throws Exception {
        tasklet.setMock(false);

        TransferRequestResult result = mock(TransferRequestResult.class);
        // Mock typé pour résoudre l'erreur "no suitable method found for thenReturn(java.lang.Object)"
        TransferRequestResultLinks links = mock(TransferRequestResultLinks.class);

        when(result.getLinks()).thenReturn(links);
        // Si getHref() retourne une String :
        when(links.getHref()).thenReturn("http://cft/transfer/123");
        // Si dans ton modèle getHref() retourne un URI, remplace la ligne ci-dessus par :
        // when(links.getHref()).thenReturn(URI.create("http://cft/transfer/123"));

        ArgumentCaptor<TransferRequestSendFileBody> bodyCaptor =
                ArgumentCaptor.forClass(TransferRequestSendFileBody.class);

        when(transfertManager.transfersFiles(eq("PART"), eq("IDF"), eq(30), bodyCaptor.capture()))
                .thenReturn(new ResponseEntity<TransferRequestResult>(result, HttpStatus.OK));

        RepeatStatus status = tasklet.execute(contribution, new ChunkContext(new StepContext(stepExecution)));

        // Le fname envoyé = objectKeyNewToSend + "/" + encryptedFileName
        assertEquals("obj/new/file.enc", bodyCaptor.getValue().getFname());
        assertEquals(RepeatStatus.CONTINUABLE, status);

        // La classe pose transfertURI dans le contexte
        String uri = stepExecution.getJobExecution().getExecutionContext().getString("transfertURI", null);
        assertNotNull(uri);
        // Optionnel : assertEquals("http://cft/transfer/123", uri);
    }

    /** 1er passage (create) : HTTP non 2xx → FAILED + FINISHED. */
    @Test
    public void execute_create_phase_non2xx_should_mark_failed_and_return_finished() throws Exception {
        tasklet.setMock(false);

        TransferRequestResult result = mock(TransferRequestResult.class);
        when(transfertManager.transfersFiles(anyString(), anyString(), anyInt(), any(TransferRequestSendFileBody.class)))
                .thenReturn(new ResponseEntity<TransferRequestResult>(result, HttpStatus.INTERNAL_SERVER_ERROR));

        RepeatStatus status = tasklet.execute(contribution, new ChunkContext(new StepContext(stepExecution)));

        assertEquals(RepeatStatus.FINISHED, status);
        assertEquals(ExitStatus.FAILED.getExitCode(), contribution.getExitStatus().getExitCode());
        assertEquals("", stepExecution.getJobExecution().getExecutionContext().getString("transfertURI", ""));
    }

    /** 1er passage (create) : HttpClientErrorException → FINISHED, pas de transfertURI. */
    @Test
    public void execute_create_phase_client_error_should_be_finished_and_no_uri() throws Exception {
        tasklet.setMock(false);

        when(transfertManager.transfersFiles(anyString(), anyString(), anyInt(), any(TransferRequestSendFileBody.class)))
                .thenThrow(new HttpClientErrorException(HttpStatus.BAD_REQUEST, "bad"));

        RepeatStatus status = tasklet.execute(contribution, new ChunkContext(new StepContext(stepExecution)));

        assertEquals(RepeatStatus.FINISHED, status);
        assertEquals("", stepExecution.getJobExecution().getExecutionContext().getString("transfertURI", ""));
    }

    /** 2e passage (check) : diagi = 0 → FINISHED. */
    @Test
    public void execute_check_phase_complete_should_finish() throws Exception {
        tasklet.setMock(false);
        stepExecution.getJobExecution().getExecutionContext().putString("transfertURI", "http://cft/transfer/999");

        TransferDetails details = mock(TransferDetails.class);
        when(details.getDiagi()).thenReturn(SendToBMDSendCFTTasklet.SUCCESSFULL_DIAG_INDICATOR);
        when(transfertManager.transfersId(new URI("http://cft/transfer/999")))
                .thenReturn(new ResponseEntity<TransferDetails>(details, HttpStatus.OK));

        RepeatStatus status = tasklet.execute(contribution, new ChunkContext(new StepContext(stepExecution)));
        assertEquals(RepeatStatus.FINISHED, status);
    }

    /** 2e passage (check) : diagi = 144 → CONTINUABLE. */
    @Test
    public void execute_check_phase_busy_should_be_continuable() throws Exception {
        tasklet.setMock(false);
        stepExecution.getJobExecution().getExecutionContext().putString("transfertURI", "http://cft/transfer/777");

        TransferDetails details = mock(TransferDetails.class);
        when(details.getDiagi()).thenReturn(SendToBMDSendCFTTasklet.TRANSFER_BUSY_DIAG_INDICATOR);
        when(transfertManager.transfersId(new URI("http://cft/transfer/777")))
                .thenReturn(new ResponseEntity<TransferDetails>(details, HttpStatus.OK));

        long t0 = System.currentTimeMillis();
        RepeatStatus status = tasklet.execute(contribution, new ChunkContext(new StepContext(stepExecution)));
        long t1 = System.currentTimeMillis();

        assertEquals(RepeatStatus.CONTINUABLE, status);
        assertTrue((t1 - t0) >= 900L); // tolère le sleep ~1s
    }

    /** 2e passage (check) : diagi inconnu → FAILED + FINISHED. */
    @Test
    public void execute_check_phase_other_diagi_should_mark_failed_and_finish() throws Exception {
        tasklet.setMock(false);
        stepExecution.getJobExecution().getExecutionContext().putString("transfertURI", "http://cft/transfer/888");

        TransferDetails details = mock(TransferDetails.class);
        when(details.getDiagi()).thenReturn("999");
        when(transfertManager.transfersId(new URI("http://cft/transfer/888")))
                .thenReturn(new ResponseEntity<TransferDetails>(details, HttpStatus.OK));

        RepeatStatus status = tasklet.execute(contribution, new ChunkContext(new StepContext(stepExecution)));
        assertEquals(RepeatStatus.FINISHED, status);
        assertEquals(ExitStatus.FAILED.getExitCode(), contribution.getExitStatus().getExitCode());
    }

    /** isTransferComplete() : true pour "0". */
    @Test
    public void isTransferComplete_should_match_zero_only() {
        assertTrue(tasklet.isTransferComplete("0"));
        assertFalse(tasklet.isTransferComplete("144"));
        assertFalse(tasklet.isTransferComplete("999"));
        assertFalse(tasklet.isTransferComplete(""));
    }

    /** isTransferBusy() : true pour "144" uniquement. */
    @Test
    public void isTransferBusy_should_match_144_only() {
        assertTrue(tasklet.isTransferBusy("144"));
        assertFalse(tasklet.isTransferBusy("0"));
        assertFalse(tasklet.isTransferBusy("999"));
        assertFalse(tasklet.isTransferBusy(""));
    }

    /** Couvre les setters publics. */
    @Test
    public void setters_should_update_fields() {
        tasklet.setPart("PX");
        tasklet.setIdf("IDX");
        tasklet.setMock(false);
        tasklet.setApiTimeout(12);
        tasklet.setTransfertManager(transfertManager);

        assertEquals("PX", ReflectionTestUtils.getField(tasklet, "part"));
        assertEquals("IDX", ReflectionTestUtils.getField(tasklet, "idf"));
        assertEquals(false, ReflectionTestUtils.getField(tasklet, "mock"));
        assertEquals(12, ReflectionTestUtils.getField(tasklet, "apiTimeout"));
        assertSame(transfertManager, ReflectionTestUtils.getField(tasklet, "transfertManager"));
    }

    /** Place 'encryptedFileName' dans le JobExecutionContext. */
    private void putEncryptedFileName(String fileName) {
        stepExecution.getJobExecution().getExecutionContext().put("encryptedFileName", fileName);
    }
}