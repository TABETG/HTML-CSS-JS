Parfait ‚Äî objectif augmenter le coverage Sonar sur la conf JobConfigurationBillingSpaceClosure.
Voici des tests unitaires rapides (JUnit 5) qui couvrent la cr√©ation des @Beans, la structure du job, l‚Äôordre des steps, l‚Äôincrementer, allowStartIfComplete(true), le chunk=100 sur les steps chunk√©s, et la pr√©sence du listener commun ‚Äî exactement comme d√©fini dans ta classe de conf.


---

üìÅ O√π placer le test

src/test/java/
  com/bnpparibas/dsibddf/ap00420/streamfact/batch/billingspace/close/job/
    JobConfigurationBillingSpaceClosureTest.java

‚úÖ Test pr√™t √† l‚Äôemploi (structure + propri√©t√©s)

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.job;

import com.bnpparibas.dsibddf.ap00420.streamfact.application.billingspace.close.pojo.BillingSpaceCloseToSend;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.processor.BillingSpaceClosureProcessor;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.reader.BillingSpaceClosureReader;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.reader.ReplayBillingspaceClosureReader;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.tasklet.UpdateBillingSpaceToStatusClosedTasklet;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.writer.BillingSpaceClosureWriter;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.listener.CommonStepExecutionListener;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.BillingSpaceEntity;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.job.flow.FlowJob;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.core.step.tasklet.TaskletStep;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.transaction.PlatformTransactionManager;

import static org.assertj.core.api.Assertions.assertThat;

@SpringJUnitConfig
@Import({JobConfigurationBillingSpaceClosureTest.TestBeans.class, JobConfigurationBillingSpaceClosure.class})
class JobConfigurationBillingSpaceClosureTest {

    @TestConfiguration
    static class TestBeans {
        // Doubles pour √©viter toute I/O r√©elle
        @Bean BillingSpaceClosureReader billingSpaceClosureReader() { return Mockito.mock(BillingSpaceClosureReader.class); }
        @Bean ReplayBillingspaceClosureReader replayBillingSpaceClosureReader() { return Mockito.mock(ReplayBillingspaceClosureReader.class); }
        @Bean BillingSpaceClosureProcessor billingSpaceClosureProcessor() { return Mockito.mock(BillingSpaceClosureProcessor.class); }
        @Bean BillingSpaceClosureWriter billingSpaceClosureWriter() { return Mockito.mock(BillingSpaceClosureWriter.class); }
        @Bean UpdateBillingSpaceToStatusClosedTasklet updateBillingSpaceToStatusClosedTasklet() { return Mockito.mock(UpdateBillingSpaceToStatusClosedTasklet.class); }
        @Bean CommonStepExecutionListener commonStepExecutionListener() { return new CommonStepExecutionListener(); }
        // Beans infra minimaux requis par les builders
        @Bean PlatformTransactionManager transactionManager() { return Mockito.mock(PlatformTransactionManager.class); }
        @Bean JobRepository jobRepository() { return Mockito.mock(JobRepository.class); }
    }

    @javax.annotation.Resource(name = "billingSpaceClosureJob")
    private Job job;

    // Attention: noms de beans = noms des m√©thodes @Bean
    @javax.annotation.Resource(name = "billingSpaceClosureStep")
    private Step billingSpaceClosureStepBean;

    @javax.annotation.Resource(name = "replayBillingSpaceClosureStep")
    private Step replayBillingSpaceClosureStepBean;

    @javax.annotation.Resource(name = "updateBillingSpaceToStatusClosedStep")
    private Step updateBillingSpaceToStatusClosedStepBean;

    @javax.annotation.Resource
    private CommonStepExecutionListener commonStepExecutionListener;

    @Nested
    @DisplayName("Job wiring & flow")
    class JobWiring {

        @Test
        @DisplayName("Le job porte le bon nom et utilise RunIdIncrementer")
        void job_has_name_and_incrementer() {
            assertThat(job).isInstanceOf(FlowJob.class);
            FlowJob fj = (FlowJob) job;
            assertThat(fj.getName()).isEqualTo("billingSpaceClosureJob");
            assertThat(fj.getJobParametersIncrementer()).isInstanceOf(RunIdIncrementer.class);
        }

        @Test
        @DisplayName("Le job contient les steps par leurs noms de step (flow)")
        void job_contains_expected_steps_in_flow() {
            FlowJob fj = (FlowJob) job;
            // Noms des steps internes (cf. StepBuilder dans la conf)
            assertThat(fj.getStep("billingSpaceClosureStep")).isNotNull();
            assertThat(fj.getStep("replayBillingSpaceClosureStep")).isNotNull();
            assertThat(fj.getStep("updateBillingSpaceToStatusClosed")).isNotNull();
        }
    }

    @Nested
    @DisplayName("Steps chunk√©s : chunk=100, allowStartIfComplete=true, listener commun")
    class ChunkedStepsProperties {

        @Test
        void billingSpaceClosureStep_properties() {
            assertChunkStep(billingSpaceClosureStepBean, 100);
        }

        @Test
        void replayBillingSpaceClosureStep_properties() {
            assertChunkStep(replayBillingSpaceClosureStepBean, 100);
        }
    }

    @Nested
    @DisplayName("Step tasklet de mise √† jour de statut")
    class TaskletStepProperties {

        @Test
        void updateBillingSpaceToStatusClosed_allowStartIfComplete_true() {
            assertThat(updateBillingSpaceToStatusClosedStepBean).isInstanceOf(TaskletStep.class);
            TaskletStep ts = (TaskletStep) updateBillingSpaceToStatusClosedStepBean;
            Object allow = ReflectionTestUtils.getField(ts, "allowStartIfComplete");
            assertThat(allow).isInstanceOf(Boolean.class);
            assertThat((Boolean) allow).isTrue();
        }
    }

    // -------- helpers --------
    private void assertChunkStep(Step step, int expectedChunk) {
        assertThat(step).isInstanceOf(TaskletStep.class);
        TaskletStep ts = (TaskletStep) step;

        // allowStartIfComplete
        Object allow = ReflectionTestUtils.getField(ts, "allowStartIfComplete");
        assertThat(allow).isInstanceOf(Boolean.class);
        assertThat((Boolean) allow).isTrue();

        // listener commun pr√©sent
        Object compositeListener = ReflectionTestUtils.getField(ts, "stepExecutionListener");
        Object listeners = ReflectionTestUtils.getField(compositeListener, "listeners");
        assertThat(listeners).isInstanceOfAny(java.util.Collection.class);
        assertThat((java.util.Collection<?>) listeners).anyMatch(l -> l == commonStepExecutionListener);

        // chunk size = 100 (via completionPolicy.chunkSize)
        Tasklet tasklet = (Tasklet) ReflectionTestUtils.getField(ts, "tasklet");
        Object chunkProvider = ReflectionTestUtils.getField(tasklet, "chunkProvider");
        Object completionPolicy = ReflectionTestUtils.getField(chunkProvider, "completionPolicy");
        Integer chunkSize = (Integer) ReflectionTestUtils.getField(completionPolicy, "chunkSize");
        assertThat(chunkSize).isEqualTo(expectedChunk);
    }
}

Pourquoi √ßa augmente bien le coverage Sonar ?
Ces tests chargent la config, ex√©cutent les m√©thodes @Bean et v√©rifient toutes les propri√©t√©s construites par les StepBuilder/JobBuilder (ordre des steps, incrementer, chunk, listener, flags), couvrant les lignes cl√©s de billingSpaceClosureJob, billingSpaceClosureStep, replayBillingSpaceClosureStep et updateBillingSpaceToStatusClosedStep telles qu‚Äôelles sont √©crites dans ta classe.


---

üß© D√©pendances test (si besoin)

Assure-toi d‚Äôavoir (test scope) :

<dependency>
  <groupId>org.springframework.batch</groupId>
  <artifactId>spring-batch-test</artifactId>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.assertj</groupId>
  <artifactId>assertj-core</artifactId>
  <version>3.25.3</version>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.mockito</groupId>
  <artifactId>mockito-core</artifactId>
  <version>5.12.0</version>
  <scope>test</scope>
</dependency>


---

‚ñ∂Ô∏è Commandes utiles

Lancer uniquement ces tests dans ton module Maven :


mvn -pl <ton-module-batch> -am -Dtest=JobConfigurationBillingSpaceClosureTest test

Si Jacoco + Sonar : v√©rifie que ton build g√©n√®re le rapport jacoco.exec/jacoco.xml (plugin jacoco-maven-plugin attach√© √† test + report), puis lance ton sonar:sonar.



---

Si tu veux encore gratter quelques %, je peux te donner une variante ‚Äúsmoke‚Äù qui lance le job et chaque step via JobLauncherTestUtils avec des doubles ‚Äúno-op‚Äù (reader ‚Üí null, tasklet ‚Üí RepeatStatus.FINISHED). √áa ne touche aucune I/O et reste ultra-rapide, tout en cochant des lignes d‚Äôex√©cution suppl√©mentaires.