Yes — l’erreur vient du fait que Spring essaye d’instancier le vrai BillingSpaceClosureProcessor, qui a un @Autowired CommandExecutorV2, alors qu’aucun bean de ce type n’est fourni dans le contexte de test. Résultat : NoSuchBeanDefinitionException sur CommandExecutorV2. On le voit dans le processor (champ commandExecutor) et le job l’injecte bien dans les steps.  

Voici deux correctifs simples qui font passer les tests et augmentent le coverage Sonar.


---

Option A (recommandée) — mocker CommandExecutorV2 dans la config de test

@SpringJUnitConfig
@Import({ JobConfigurationBillingSpaceClosure.class, JobConfigurationBillingSpaceClosureTest.TestBeans.class })
class JobConfigurationBillingSpaceClosureTest {

  @Autowired Job billingSpaceClosureJob;
  @Autowired Step billingSpaceClosureStep;
  @Autowired Step replayBillingSpaceClosureStep;
  @Autowired Step updateBillingSpaceToStatusClosedStep;

  @Test
  void contextLoads_and_WiresAllSteps() {
    assertNotNull(billingSpaceClosureJob);
    assertEquals("billingSpaceClosureStep", billingSpaceClosureStep.getName());
    assertEquals("replayBillingSpaceClosureStep", replayBillingSpaceClosureStep.getName());
    assertEquals("updateBillingSpaceToStatusClosed", updateBillingSpaceToStatusClosedStep.getName());
  }

  @TestConfiguration
  static class TestBeans {
    // Mocks nécessaires aux @Autowired du JobConfiguration
    @Bean BillingSpaceClosureReader billingSpaceClosureReader() { return Mockito.mock(BillingSpaceClosureReader.class); }
    @Bean ReplayBillingspaceClosureReader replayBillingSpaceClosureReader() { return Mockito.mock(ReplayBillingspaceClosureReader.class); }
    @Bean BillingSpaceClosureWriter billingSpaceClosureWriter() { return Mockito.mock(BillingSpaceClosureWriter.class); }
    @Bean UpdateBillingSpaceToStatusClosedTasklet updateBillingSpaceToStatusClosedTasklet() { return Mockito.mock(UpdateBillingSpaceToStatusClosedTasklet.class); }
    @Bean CommonStepExecutionListener commonStepExecutionListener() { return Mockito.mock(CommonStepExecutionListener.class); }
    @Bean @Qualifier("transactionManager") PlatformTransactionManager transactionManager() { return Mockito.mock(PlatformTransactionManager.class); }

    // ✅ Le mock qui manquait : satisfait l’@Autowired du vrai BillingSpaceClosureProcessor
    @Bean CommandExecutorV2 commandExecutorV2() {
      CommandExecutorV2 mock = Mockito.mock(CommandExecutorV2.class);
      Mockito.when(mock.execute(Mockito.eq(CloseBillingSpaceCommand.class), Mockito.any(CloseBillingSpaceRequest.class)))
             .thenReturn(BillingSpaceCloseToSend.builder().build());
      return mock;
    }
  }
}

> Pourquoi ça marche : on laisse Spring créer le vrai BillingSpaceClosureProcessor, mais on lui fournit un CommandExecutorV2 mocké pour satisfaire son @Autowired. 




---

Option B — mocker directement le BillingSpaceClosureProcessor

Alternative si tu préfères n’avoir aucun bean “réel” du processor dans le contexte :

@TestConfiguration
static class TestBeans {
  // … mêmes beans mock que ci-dessus …
  @Bean BillingSpaceClosureProcessor billingSpaceClosureProcessor() {
    return Mockito.mock(BillingSpaceClosureProcessor.class);
  }
  // Dans ce cas, pas besoin de CommandExecutorV2
}


---

Bonus coverage : test unitaire du processor

Pour gratter du coverage facilement côté Sonar, ajoute un test unitaire ciblé :

@ExtendWith(MockitoExtension.class)
class BillingSpaceClosureProcessorTest {

  @Mock CommandExecutorV2 commandExecutor;
  @InjectMocks BillingSpaceClosureProcessor processor;

  @Test
  void process_callsCommandExecutor_andReturnsResult() throws Exception {
    BillingSpaceEntity entity = new BillingSpaceEntity();
    // TODO: set entity.setLoanFolder(…); selon ton modèle

    BillingSpaceCloseToSend expected = BillingSpaceCloseToSend.builder().build();
    Mockito.when(commandExecutor.execute(Mockito.eq(CloseBillingSpaceCommand.class), Mockito.any(CloseBillingSpaceRequest.class)))
           .thenReturn(expected);

    BillingSpaceCloseToSend out = processor.process(entity);

    assertSame(expected, out);
    Mockito.verify(commandExecutor).execute(Mockito.eq(CloseBillingSpaceCommand.class), Mockito.any(CloseBillingSpaceRequest.class));
  }
}


---

Si tu appliques Option A (ou B), l’erreur disparaît et tes tests de wiring du job/steps passeront, tout en ajoutant un test “pur” du processor pour booster le coverage.