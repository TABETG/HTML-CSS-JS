package com.bnpparibas.dsibddf.ap10530.incident.application;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import com.bnpparibas.dsibddf.ap10530.incident.domain.dto.StatisticsRequestDto;
import com.bnpparibas.dsibddf.ap10530.incident.domain.rest.StatisticsService;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.bnpparibas.dsibddf.ap10530.incident.domain.dto.IncidentMoralRequestDto;
import com.bnpparibas.dsibddf.ap10530.incident.domain.dto.IncidentMoralResponseDto;
import com.bnpparibas.dsibddf.ap10530.incident.domain.mappers.BciFicpRequestMapper;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentBciFicpResult;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentsCharacteristics;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentsCharacteristics.OriginEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.MSG_IN;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.Personne;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.ZCON_FONC_IN;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.CTypeImmatEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.LegalNameEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.pm.ZCON_N_FAM;
import com.bnpparibas.dsibddf.ap10530.incident.domain.rest.BciFicpRestService;
import com.bnpparibas.dsibddf.ap10530.incident.domain.rest.PersoneMoraleRestService;
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.BDFKeyGenerator;
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.DebuggingUtils;
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.ISOBirthDateConverter;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.service.FCCService;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.ficp.service.FICPService;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.RequestTypeEnum;

/**
 * Orchestrator service : perform Business logic.
 * (Refactor lisible, sans changement de signatures ni de noms de méthodes)
 */
@Component
public class IncidentService {

    private static final Logger LOGGER = LoggerFactory.getLogger(IncidentService.class);
    private static final int MAX_BNPP_BATCH = 5;

    @Autowired private StatisticsService statisticsService;
    @Autowired private BciFicpRestService bciFicpService;
    @Autowired private FICPService ficpService;
    @Autowired private FCCService fccService;
    @Autowired private PersoneMoraleRestService pMService;

    private final BciFicpRequestMapper bciFicpMapper = new BciFicpRequestMapper();

    /** Transform incoming requests to BDF keys (used by FICP/FCC). */
    private void generateBDFKeyList(final List<PersonSearchRequest> incidentsSearchRequest) {
        int i = 1;
        final int taille = incidentsSearchRequest.size();
        for (final PersonSearchRequest person : incidentsSearchRequest) {
            final String bdfKey = BDFKeyGenerator.computeBDFKey(
                    person.getLastname(),
                    ISOBirthDateConverter.fromISOString(person.getBirthDate())
            );
            LOGGER.debug("computeBDFKey: name {}, birthDate {} = {}", person.getLastname(), person.getBirthDate(), bdfKey);
            LOGGER.info("Clé Banque de France de l'appel {} sur {} : {}", i, taille, bdfKey);
            i++;
            person.setBdfKey(bdfKey);
        }
    }

    /** Exposeurs inchangés */
    public FCCService getFccService() { return fccService; }
    public FICPService getFicpService() { return ficpService; }

    /**
     * Orchestrateur principal.
     */
    public List<IncidentsCharacteristics> searchIncident(final List<PersonSearchRequest> incidentsSearchRequest,
                                                         final String channel,
                                                         final String caller,
                                                         String userId) throws Exception {

        final List<IncidentsCharacteristics> resultList = new ArrayList<>();

        // Cas PP: personType null ou "0"
        if (isPP(incidentsSearchRequest)) {
            final int typeEntree = determineTypeEntreePP(incidentsSearchRequest);

            // BNPP (BCI / FICP BNPP) selon type d'entrée
            if (typeEntree == 1) {
                handleRPFlowPP(incidentsSearchRequest, resultList);
            } else if (typeEntree == 2) {
                generateBDFKeyList(incidentsSearchRequest);
                handleInfoPersonFlowPP(incidentsSearchRequest, resultList);
            } // typeEntree==0 => données insuffisantes => pas d'appel BNPP

            // FICP & FCC (toujours tentés côté PP)
            addFicpAndFccForPP(incidentsSearchRequest, channel, caller, userId, resultList);

            // Ajoute la vue RP si entrée par RP
            if (typeEntree == 1) {
                resultList.add(new IncidentsCharacteristics(mapPersonnePhysique(incidentsSearchRequest), OriginEnum.RP));
            }

            return resultList;
        }

        // Cas PM: personType == "1"
        final int typeEntreePM = determineTypeEntreePM(incidentsSearchRequest);
        if (typeEntreePM == 2) {
            // Si immat fournie mais clé non préparée, la construire
            for (PersonSearchRequest r : incidentsSearchRequest) {
                if (StringUtils.isNotEmpty(r.getImmatId()) && StringUtils.isNotEmpty(r.getImmatType())) {
                    r.setBdfKey(r.getImmatType() + r.getImmatId());
                }
            }
        }

        if (typeEntreePM == 1) {
            // Construire la "vue RP" PM via le service référentiel
            final List<Personne> listePM = buildPmFromRP(incidentsSearchRequest);
            resultList.add(new IncidentsCharacteristics(listePM, OriginEnum.RP));
        }

        // FCC PM (toujours côté PM)
        final List<Personne> fccPm = fccService.searchIncidentMoral(incidentsSearchRequest, channel, caller, userId);
        LOGGER.debug("{} incident(s) found in FCC BDF database", fccPm.size());
        resultList.add(new IncidentsCharacteristics(fccPm, OriginEnum.FCC_PM));

        return resultList;
    }

    /** Mapping "léger" pour l’onglet RP des PP. */
    private List<Personne> mapPersonnePhysique(final List<PersonSearchRequest> incidentListRPBNPP) {
        final List<Personne> personneIncidentList = new ArrayList<>();
        for (final PersonSearchRequest psr : incidentListRPBNPP) {
            if (psr == null) continue;
            final Personne pp = new Personne();
            pp.setFirstname(psr.getFirstname());
            pp.setLastname(psr.getLastname());
            pp.setCivility(psr.getCivility());
            pp.setBdfkey(psr.getBdfKey());
            pp.setMarriedName(psr.getMarriedName());
            pp.setBirthDate(psr.getBirthDate());
            pp.setBirthCity(psr.getBirthCity());
            pp.setBirthCountry(psr.getBirthCountry());
            pp.setBirthDepartment(psr.getBirthDepartment());
            personneIncidentList.add(pp);
        }
        return personneIncidentList;
    }

    /** Construit la requête PM (RP) telle que dans le code d’origine. */
    private IncidentMoralRequestDto createRestRequest(final PersonSearchRequest input) {
        IncidentMoralRequestDto in = new IncidentMoralRequestDto();
        MSG_IN msgIn = new MSG_IN();
        ZCON_FONC_IN fonc = new ZCON_FONC_IN();
        fonc.setZCON_N_VERSION(1);
        fonc.setZCON_Q_LIST_FAM(4);
        fonc.setZCON_I_SDISTN_MSG("");
        fonc.setZCON_I_ENT_PRSNE("");
        fonc.setZCON_C_ETABL_MSG("");
        fonc.setZCON_C_LANGUE_MSG("");
        fonc.setZCON_C_APPL("");
        List<ZCON_N_FAM> temp = new ArrayList<>();
        temp.add(new ZCON_N_FAM(96));
        temp.add(new ZCON_N_FAM(154));
        temp.add(new ZCON_N_FAM(178));
        temp.add(new ZCON_N_FAM(233));
        fonc.setZCON_G_LIST_FAM(temp);
        fonc.setZCON_I_IDENT(input.getPersonId());
        fonc.setZCON_C_TYPE_IDENT("PE");
        msgIn.setZcon_FONC_IN(fonc);
        in.setMSG_IN(msgIn);
        return in;
    }

    /** Setters conservés */
    public void setFccService(final FCCService fccService) { this.fccService = fccService; }
    public void setFicpService(final FICPService ficpService) { this.ficpService = ficpService; }

    /* ========================== Helpers privés (refactor) ========================== */

    private static boolean isPP(List<PersonSearchRequest> reqs) {
        return reqs != null && !reqs.isEmpty() && (reqs.get(0).getPersonType() == null || "0".equals(reqs.get(0).getPersonType()));
    }

    /** typeEntree PP : 1=RP, 2=Infos, 0=insuffisant */
    private int determineTypeEntreePP(List<PersonSearchRequest> reqs) {
        // Par défaut RP
        int typeEntree = 1;

        // S'il manque un personId -> bascule en "Infos personne" (2)
        for (PersonSearchRequest r : reqs) {
            if (StringUtils.isEmpty(r.getPersonId())) {
                typeEntree = 2;
                break;
            }
        }

        // Si "Infos personne", vérifier la complétude
        if (typeEntree == 2) {
            for (PersonSearchRequest r : reqs) {
                if (r.getBirthDepartment() == null || r.getBirthDate() == null
                        || r.getFirstname() == null || r.getLastname() == null
                        || r.getCivility() == null) {
                    return 0;
                }
            }
        }
        return typeEntree;
    }

    /** typeEntree PM : 1=RP (personId), 2=Infos (immat), 0=insuffisant */
    private int determineTypeEntreePM(List<PersonSearchRequest> reqs) {
        int typeEntree = 1;
        for (PersonSearchRequest r : reqs) {
            if (StringUtils.isEmpty(r.getPersonId())) {
                typeEntree = 2; // pas d’ID → on vise les infos d’immat
                break;
            }
        }
        if (typeEntree == 2) {
            for (PersonSearchRequest r : reqs) {
                if (r.getImmatId() == null || r.getImmatType() == null) {
                    return 0;
                }
            }
        }
        return typeEntree;
    }

    /* ---------- PP : Flot RP (BNPP postRP) ---------- */
    private void handleRPFlowPP(List<PersonSearchRequest> reqs, List<IncidentsCharacteristics> resultList) {
        final IncidentBciFicpResult wrapper = callBnppRP(reqs);
        LOGGER.debug("{} incident(s) found in BCI database by RP", wrapper.getIncidentListBCI().size());
        resultList.add(new IncidentsCharacteristics(wrapper.getIncidentListBCI(), OriginEnum.BCI));
        LOGGER.debug("{} incident(s) found in FICP BNPP database by RP", wrapper.getIncidentListFCIPBNPP().size());
        resultList.add(new IncidentsCharacteristics(wrapper.getIncidentListFCIPBNPP(), OriginEnum.FICP_BNPP));

        // Préparer la nouvelle liste de requêtes (issues du RP BNPP), puis ré-injecter les champs complémentaires
        final List<PersonSearchRequest> rpBnpp = new ArrayList<>(wrapper.getIncidentListRPBNPP());
        copySupplementalFields(reqs, rpBnpp);

        // Empiler les BDF_ONLY originaux en fin de liste
        final List<PersonSearchRequest> bdfOnly = reqs.stream()
                .filter(r -> RequestTypeEnum.BDF_ONLY.equals(r.getRequestType()))
                .collect(Collectors.toList());

        reqs.clear();
        reqs.addAll(rpBnpp);
        reqs.addAll(bdfOnly);
    }

    /* ---------- PP : Flot Info personne (BNPP post) ---------- */
    private void handleInfoPersonFlowPP(List<PersonSearchRequest> reqs, List<IncidentsCharacteristics> resultList) {
        final IncidentBciFicpResult wrapper = callBnppInfo(reqs);
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Incident(s) found : {}", DebuggingUtils.toJSon(wrapper));
        }
        LOGGER.debug("{} incident(s) found in BCI database", wrapper.getIncidentListBCI().size());
        resultList.add(new IncidentsCharacteristics(wrapper.getIncidentListBCI(), OriginEnum.BCI));
        LOGGER.debug("{} incident(s) found in FICP BNPP database", wrapper.getIncidentListFCIPBNPP().size());
        resultList.add(new IncidentsCharacteristics(wrapper.getIncidentListFCIPBNPP(), OriginEnum.FICP_BNPP));
    }

    /* ---------- PP : Ajout FICP BDF + FCC BDF ---------- */
    private void addFicpAndFccForPP(List<PersonSearchRequest> reqs,
                                    String channel, String caller, String userId,
                                    List<IncidentsCharacteristics> resultList) {
        final List<Personne> ficpIncidentList = ficpService.searchIncident(reqs, channel, caller, userId);
        LOGGER.debug("{} incident(s) found in FICP BDF database", ficpIncidentList.size());
        resultList.add(new IncidentsCharacteristics(ficpIncidentList, OriginEnum.FICP_BDF));

        final List<Personne> fccIncidentList = fccService.searchIncident(reqs, channel, caller, userId);
        LOGGER.debug("{} incident(s) found in FCC BDF database", fccIncidentList.size());
        resultList.add(new IncidentsCharacteristics(fccIncidentList, OriginEnum.FCC));
    }

    /* ---------- BNPP : appels & fusion résultats ---------- */
    private IncidentBciFicpResult callBnppRP(List<PersonSearchRequest> reqs) {
        if (reqs.size() > MAX_BNPP_BATCH) {
            final List<PersonSearchRequest> p1 = reqs.subList(0, MAX_BNPP_BATCH);
            final List<PersonSearchRequest> p2 = reqs.subList(MAX_BNPP_BATCH, reqs.size());
            final IncidentBciFicpResult w1 = bciFicpService.postRP(bciFicpMapper.createBciFicpRequestRP(p1), p1);
            final IncidentBciFicpResult w2 = bciFicpService.postRP(bciFicpMapper.createBciFicpRequestRP(p2), p2);
            return mergeWrappers(w1, w2);
        }
        return bciFicpService.postRP(bciFicpMapper.createBciFicpRequestRP(reqs), reqs);
    }

    private IncidentBciFicpResult callBnppInfo(List<PersonSearchRequest> reqs) {
        if (reqs.size() > MAX_BNPP_BATCH) {
            final List<PersonSearchRequest> p1 = reqs.subList(0, MAX_BNPP_BATCH);
            final List<PersonSearchRequest> p2 = reqs.subList(MAX_BNPP_BATCH, reqs.size());
            final IncidentBciFicpResult w1 = bciFicpService.post(bciFicpMapper.createBciFicpRequest(p1));
            final IncidentBciFicpResult w2 = bciFicpService.post(bciFicpMapper.createBciFicpRequest(p2));
            return mergeWrappers(w1, w2);
        }
        return bciFicpService.post(bciFicpMapper.createBciFicpRequest(reqs));
    }

    private static IncidentBciFicpResult mergeWrappers(IncidentBciFicpResult w1, IncidentBciFicpResult w2) {
        w1.getIncidentListBCI().addAll(w2.getIncidentListBCI());
        w1.getIncidentListFCIPBNPP().addAll(w2.getIncidentListFCIPBNPP());
        Optional.ofNullable(w1.getIncidentListRPBNPP()).ifPresent(list -> {
            if (w2.getIncidentListRPBNPP() != null) list.addAll(w2.getIncidentListRPBNPP());
        });
        return w1;
    }

    /** Copie les champs “complémentaires métier” de la liste source vers la liste cible (par indice). */
    private static void copySupplementalFields(List<PersonSearchRequest> from, List<PersonSearchRequest> to) {
        final int size = Math.min(from.size(), to.size());
        for (int i = 0; i < size; i++) {
            PersonSearchRequest src = from.get(i);
            PersonSearchRequest dst = to.get(i);
            if (src == null || dst == null) continue;

            dst.setConservPreuve(src.getConservPreuve());
            dst.setStatutPreuve(src.getStatutPreuve());
            dst.setNbCptesDossier(src.getNbCptesDossier());
            dst.setDureeContrat(src.getDureeContrat());
            dst.setDateDebutCredit(src.getDateDebutCredit());
            dst.setAppEmettrice(src.getAppEmettrice());
            dst.setRefExterne(src.getRefExterne());
            dst.setPersonId(src.getPersonId());
            dst.setNbPersFicp(src.getNbPersFicp());
            dst.setRibEtTypedeCompte(src.getRibEtTypedeCompte());
        }
    }

    /* ---------- PM : construction RP via service référentiel PM ---------- */
    private List<Personne> buildPmFromRP(List<PersonSearchRequest> reqs) {
        List<Personne> liste = new ArrayList<>();
        for (PersonSearchRequest req : reqs) {
            Personne pm = new Personne();
            pm.setPersonId(req.getPersonId());

            IncidentMoralResponseDto rep = pMService.post(createRestRequest(req));

            // Famille 233 : immatriculation (type + numéro)
            if (rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF233().length > 0) {
                String num = rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF233()[0].getcNumImmtrn();
                String type = rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF233()[0].getcTypeImmtrn();
                // normaliser le type
                type = CTypeImmatEnum.fromValue(type).toString();

                req.setImmatId(num);
                req.setImmatType(type);
                req.setBdfKey(type + num);

                pm.setBdfkey(req.getBdfKey());
                pm.setImmatType(type);
                pm.setImmatID(num);
            } else {
                LOGGER.debug("La famille 233 est vide");
            }

            // Famille 154 : adresse fiscale
            if (rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF154().length > 0) {
                pm.setFiscalAdress1(rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF154()[0].getlAdrFisc1());
                pm.setFiscalAdress2(rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF154()[0].getlAdrFisc2());
                pm.setFiscalAdress3(rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF154()[0].getlAdrFisc3());
                pm.setPostalCode(rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF154()[0].getcAdrpFiscCpost());
                pm.setVillePM(rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF154()[0].getlNomComFisc());
            } else {
                LOGGER.debug("La famille 154 est vide");
            }

            // Famille 178 : raison sociale
            if (rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF178().length > 0) {
                pm.setBusinessName(rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF178()[0].getlRsoc());
            } else {
                LOGGER.debug("La famille 178 est vide");
            }

            // Famille 096 : forme juridique
            if (rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF096().length > 0) {
                String code = String.valueOf(rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF096()[0].getcNjurPrsne());
                pm.setCodeLegalName(code);
                pm.setLegalName(LegalNameEnum.fromValue(code).toString());
            } else {
                LOGGER.debug("La famille 096 est vide");
            }

            liste.add(pm);
        }
        return liste;
    }
}