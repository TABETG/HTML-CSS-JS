package com.bnpparibas.dsibddf.ap10530.incident.domain.mappers;

/*
 * Mapper BCI/FICP → Structures Z/OS
 *
 * ⚠️ Demande utilisateur : commenter sans modifier ni supprimer le code.
 *   - Le code d'origine est conservé (y compris doublons, affectations répétées, etc.).
 *   - Seul le formatage et l'ajout de commentaires explicatifs ont été réalisés.
 */

import java.util.ArrayList;
import java.util.List;

import org.springframework.util.StringUtils;

import com.bnpparibas.dsibddf.ap10530.incident.domain.dto.BciFicpRequestDTO;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.MSG_IN;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.ZCON_FONC_IN;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.ZCON_FONC_INOU;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.RequestTypeEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.pphy.G_ECV_PPHY;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.pphy.G_KPI_REF;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.pphy.G_KPI_REF1;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.pphy.G_LIST_I_KPI;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.pphy.G_LIST_KPI;
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.BDFKeyGenerator;
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.ISOBirthDateConverter;

/**
 * @author C98744
 *
 * ASAP 608
 */
public class BciFicpRequestMapper {

    // Délimiteur de date ISO attendu (yyyy-MM-dd)
    private static final String ISO_DATE_DELIMITER = "-";

    // Code d'enregistrement pour indiquer BCI + FICP (valeur "3")
    private static final String BOTH_BCI_FICP = "3";

    /**
     * BciFicpRequestMapper Constructor
     */
    public BciFicpRequestMapper() {
        super();
    }

    /**
     * Mapping d'une liste de PersonSearchRequest vers la trame Z/OS standard.
     *  - Ignore les demandes BDF_ONLY (ne partent pas vers BCI)
     *  - Alimente G_LIST_KPI (liste d'identités) et G_LIST_I_KPI (liste d'IKPI, ici vide)
     *
     * @param incidentsSearchRequest la liste des requêtes métier en entrée
     * @return BciFicpRequestDTO prêt à envoyer vers le mainframe
     */
    public BciFicpRequestDTO createBciFicpRequest(final List<PersonSearchRequest> incidentsSearchRequest) {
        final BciFicpRequestDTO rchIncidRequest = new BciFicpRequestDTO();

        // Enveloppe du message
        MSG_IN in = new MSG_IN();
        ZCON_FONC_IN foncin = new ZCON_FONC_IN();

        // Liste des identités (KPI)
        final G_LIST_KPI gListKpi = new G_LIST_KPI();
        final List<G_KPI_REF> newList = new ArrayList<G_KPI_REF>();

        int i = 0;
        for (final PersonSearchRequest person : incidentsSearchRequest) {
            /** if RequestType = BNP or ALL */
            if (!person.getRequestType().equals(RequestTypeEnum.BDF_ONLY)) {
                // Mappe une personne -> G_KPI_REF (identifiants civils)
                final G_KPI_REF newPerson = mapGKpi(i, person);
                newList.add(newPerson);
                i++;
            }
        }

        // Nombre d'identifiants PI et collection associée
        gListKpi.setQ_KPI_REF(i); // Nombre d’identifiants PI
        gListKpi.setG_KPI_REF(newList);

        // Liste IKPI (ici via méthode dédiée, renvoie une liste vide + Q=0)
        foncin.setG_LIST_I_KPI(mapGIKpi());

        // Bloc IN/OU (autre structure contenant aussi la liste KPI)
        ZCON_FONC_INOU foncInOu = new ZCON_FONC_INOU();
        foncInOu.setG_LIST_KPI(gListKpi);

        // Assemblage du message
        in.setZcon_FONC_IN(foncin);
        in.setZcon_fonc_inou(foncInOu);
        rchIncidRequest.setMSG_IN(in);

        // Traces d'anciennes assignations (laissées en commentaire d'origine)
        // rchIncidRequest.getMSG_IN().getZcon_FONC_IN().setG_LIST_I_KPI(mapGIKpi());
        // rchIncidRequest.getMSG_IN().getZcon_FONC_IN().setG_LIST_KPI(gListKpi);

        return rchIncidRequest;
    }

    /**
     * Variante RP ("Recherche par Person Id" + identifiants civils) :
     *  - Alimente simultanément G_LIST_I_KPI (avec G_KPI_REF1 : type + I_KPI) ET G_LIST_KPI.
     *  - Ignore aussi les BDF_ONLY.
     */
    public BciFicpRequestDTO createBciFicpRequestRP(final List<PersonSearchRequest> incidentsSearchRequest) {
        final BciFicpRequestDTO rchIncidRequest = new BciFicpRequestDTO();

        MSG_IN in = new MSG_IN();
        ZCON_FONC_IN foncin = new ZCON_FONC_IN();

        final G_LIST_KPI gListKpi = new G_LIST_KPI();
        final G_LIST_I_KPI gListIKpi = new G_LIST_I_KPI();

        final List<G_KPI_REF1> newListRP = new ArrayList<G_KPI_REF1>(); // IKPI (par identifiant technique)
        final List<G_KPI_REF> newList = new ArrayList<G_KPI_REF>();     // KPI (identité civile)

        int i = 0;
        for (final PersonSearchRequest person : incidentsSearchRequest) {
            /** if RequestType = BNP or ALL */
            if (!person.getRequestType().equals(RequestTypeEnum.BDF_ONLY)) {
                // IKPI (RP)
                final G_KPI_REF1 newPersonRP = mapGIKpiRP(i, person);
                newListRP.add(newPersonRP);
                // KPI (RP)
                final G_KPI_REF newPerson = mapGKpiRP(i, person);
                newList.add(newPerson);
                i++;
            }
        }

        // Compteurs et collections
        gListIKpi.setQ_KPI_REF1(i); // Nombre d’identifiants PI (IKPI)
        gListIKpi.setG_KPI_REF1(newListRP);

        gListKpi.setQ_KPI_REF(i);   // Nombre d’identifiants PI (KPI)
        gListKpi.setG_KPI_REF(newList);

        foncin.setG_LIST_I_KPI(gListIKpi);

        ZCON_FONC_INOU foncInOu = new ZCON_FONC_INOU();
        foncInOu.setG_LIST_KPI(gListKpi);

        in.setZcon_FONC_IN(foncin);
        in.setZcon_fonc_inou(foncInOu);
        rchIncidRequest.setMSG_IN(in);
        return rchIncidRequest;
    }

    /**
     * Mappe une personne (mode standard) vers G_KPI_REF.
     * i = position 1‑based (N_ORDRE_LIST_REF)
     */
    private G_KPI_REF mapGKpi(final int i, final PersonSearchRequest person) {
        final G_KPI_REF newPerson = new G_KPI_REF();

        // Date ISO → structure G_ECV_PPHY (AAAA/MM/JJ + séparateurs)
        G_ECV_PPHY date = mapDateISO(person.getBirthDate());
        newPerson.setG_ECV_PPHY(date);

        // Nom / Prénoms
        newPerson.setL_CP_NOMPI(person.getLastname());
        newPerson.setL_CP_NOMPI(person.getLastname()); // (doublon présent dans le code d'origine)
        newPerson.setL_CP_NOMPI_PR(person.getFirstname());

        // Clé BDF calculée à partir du nom + date de naissance
        newPerson.setL_CLE_BDF(BDFKeyGenerator.computeBDFKey(person.getLastname(), ISOBirthDateConverter.fromISOString(person.getBirthDate())));

        // Civilité (enum → Integer)
        newPerson.setN_SEXE_REF(Integer.valueOf((person.getCivility().toString())));

        // INSEE + nom marital (si fournis)
        newPerson.setC_INSEE(person.getInseeCode());
        newPerson.setL_CP_NOM_MARIE(person.getMarriedName());

        // Ville de naissance (si null → "")
        if(person.getBirthCity()== null){
            newPerson.setL_NOM_ZGEO_COM("");
        }

        // Département / Pays de naissance
        newPerson.setL_NOM_ZGEO_DEPT(person.getBirthDepartment());
        newPerson.setL_NOM_ZGEO_PAYS(person.getBirthCountry());

        // Enregistrement "BCI+FICP"
        newPerson.setC_ENREG_INCID(BOTH_BCI_FICP);

        // Ordre dans la liste (1‑based)
        newPerson.setN_ORDRE_LIST_REF(i + 1);
        return newPerson;
    }

    /**
     * Construit une liste IKPI vide (Q=0) — conforme à l'appel standard.
     */
    private G_LIST_I_KPI mapGIKpi() {
        final G_LIST_I_KPI newPerson = new G_LIST_I_KPI();
        List<G_KPI_REF1> refKpi = new ArrayList<G_KPI_REF1>();
        newPerson.setQ_KPI_REF1(0);
        newPerson.setG_KPI_REF1(refKpi);
        return newPerson;
    }

    /**
     * Mappe une personne (variante RP) vers G_KPI_REF côté KPI (identité civile).
     */
    private G_KPI_REF mapGKpiRP(final int i, final PersonSearchRequest person) {
        final G_KPI_REF newPerson = new G_KPI_REF();

        newPerson.setC_ENREG_INCID(BOTH_BCI_FICP);
        newPerson.setN_ORDRE_LIST_REF(i + 1);

        // Nom (si null → "")
        if (person.getLastname() == null) {
            newPerson.setL_CP_NOMPI("");
        } else {
            newPerson.setL_CP_NOMPI(person.getLastname());
        }

        // Ville / Département / Pays (null → "")
        if (person.getBirthCity() == null ) {
            newPerson.setL_NOM_ZGEO_COM("");
        } else {
            newPerson.setL_NOM_ZGEO_COM(person.getBirthCity());
        }
        if (person.getBirthDepartment() == null) {
            newPerson.setL_NOM_ZGEO_DEPT("");
        } else {
            newPerson.setL_NOM_ZGEO_DEPT(person.getBirthDepartment());
        }
        if (person.getBirthCountry() == null) {
            newPerson.setL_NOM_ZGEO_PAYS("");
        } else {
            newPerson.setL_NOM_ZGEO_PAYS((person.getBirthCountry()));
        }

        // Prénom, INSEE, nom marital si présents
        if (person.getFirstname() != null) {
            newPerson.setL_CP_NOMPI_PR(person.getFirstname());
        }
        if (person.getInseeCode() != null) {
            newPerson.setC_INSEE(person.getInseeCode());
        }
        if (person.getMarriedName() != null) {
            newPerson.setL_CP_NOM_MARIE(person.getMarriedName());
        }

        // Date de naissance et clé BDF uniquement si les champs requis sont fournis
        if (person.getBirthDate() != null) {
            newPerson.setG_ECV_PPHY(mapDateISO(person.getBirthDate()));
        }
        if (person.getBirthDate() != null && person.getLastname() != null) {
            newPerson.setL_CLE_BDF(BDFKeyGenerator.computeBDFKey(person.getLastname(), ISOBirthDateConverter.fromISOString(person.getBirthDate())));
        }

        // Civilité
        if (person.getCivility() != null) {
            newPerson.setN_SEXE_REF(Integer.valueOf((person.getCivility().toString())));
        }

        return newPerson;
    }

    /**
     * Mappe une personne (variante RP) vers G_KPI_REF1 côté IKPI.
     * - N_TYPE_I_KPI=34 : type d'identifiant utilisé
     * - I_KPI_NON_SIGFT : identifiant non significatif (ici personId)
     */
    private G_KPI_REF1 mapGIKpiRP(final int i, final PersonSearchRequest person) {
        final G_KPI_REF1 newPerson = new G_KPI_REF1();
        newPerson.setN_TYPE_I_KPI(34);
        newPerson.setI_KPI_NON_SIGFT(person.getPersonId());
        return newPerson;
    }

    /**
     * Convertit une date ISO (yyyy-MM-dd) en structure G_ECV_PPHY (ISO AAAA-K1-MM-K2-JJ).
     * Hypothèse : birthDate non nul et bien formé (conforme au code d'origine).
     */
    private G_ECV_PPHY mapDateISO(final String birthDate) {
        final G_ECV_PPHY tdDIso = new G_ECV_PPHY();
        final String[] splittedDate = StringUtils.delimitedListToStringArray(birthDate, ISO_DATE_DELIMITER);
        tdDIso.setN_ISO_AAAA(Integer.parseInt(splittedDate[0]));
        tdDIso.setI_ISO_K1(ISO_DATE_DELIMITER);
        tdDIso.setN_ISO_MM(Integer.parseInt(splittedDate[1]));
        tdDIso.setI_ISO_K2(ISO_DATE_DELIMITER);
        tdDIso.setN_ISO_JJ(Integer.parseInt(splittedDate[2]));
        return tdDIso;
    }
}
