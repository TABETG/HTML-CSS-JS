package com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.service.batch.security.openpgp;

import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.runner.RunWith;

import org.junit.rules.TemporaryFolder;
import org.mockito.MockedConstruction;
import org.mockito.MockedStatic;
import org.mockito.junit.MockitoJUnitRunner;

import java.io.*;
import java.security.KeyStore;
import java.security.PublicKey;
import java.security.cert.X509Certificate;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

import org.bouncycastle.bcpg.ArmoredOutputStream;
import org.bouncycastle.bcpg.HashAlgorithmTags;
import org.bouncycastle.bcpg.PublicKeyAlgorithmTags;
import org.bouncycastle.bcpg.sig.KeyFlags;
import org.bouncycastle.openpgp.*;
import org.bouncycastle.openpgp.operator.jcajce.JcaKeyFingerprintCalculator;
import org.bouncycastle.openpgp.operator.jcajce.JcaPGPContentSignerBuilder;
import org.bouncycastle.openpgp.operator.jcajce.JcaPGPKeyConverter;
import org.bouncycastle.openpgp.operator.jcajce.JcePBESecretKeyDecryptorBuilder;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * JUnit 4 only — pas de Jupiter, pas d’AssertJ.
 * MockitoJUnitRunner + MockedStatic/MockedConstruction pour isoler BouncyCastle/IO.
 */
@RunWith(MockitoJUnitRunner.class)
public class OnePassSignatureProcessorTest {

    @Rule
    public TemporaryFolder tmp = new TemporaryFolder();

    private OnePassSignatureProcessor cut;

    // Fichiers temporaires utilisés par les tests
    private File originalFile;           // fichier source (non vide)
    private File outArmored;             // sortie encryptée ascii-armored
    private File inEncrypted;            // entrée "chiffrée" simulée
    private File outDecrypted;           // sortie déchiffrée

    // Fichiers clés partenaires / privés
    private File partnerPubOld;
    private File partnerPubNew;
    private File ownPrivPgp;
    private File ownPrivKeystore;

    @Before
    public void setUp() throws Exception {
        cut = new OnePassSignatureProcessor();

        originalFile = tmp.newFile("original.txt");
        try (FileOutputStream fos = new FileOutputStream(originalFile)) {
            fos.write("HELLO_WORLD\n".getBytes("UTF-8"));
        }
        outArmored = tmp.newFile("out.asc");
        inEncrypted = tmp.newFile("enc.bin");
        try (FileOutputStream fos = new FileOutputStream(inEncrypted)) {
            fos.write(new byte[]{1,2,3,4});
        }
        outDecrypted = tmp.newFile("dec.txt");

        partnerPubOld = tmp.newFile("partner_old.asc");     // laissé vide quand on veut exists=false
        partnerPubNew = tmp.newFile("partner_new.asc");
        try (FileOutputStream fos = new FileOutputStream(partnerPubNew)) {
            fos.write(new byte[]{7,7,7}); // non vide -> existsAndNotEmptyContent=true
        }

        ownPrivPgp = tmp.newFile("own_priv.asc");
        try (FileOutputStream fos = new FileOutputStream(ownPrivPgp)) {
            fos.write(new byte[]{9,9,9});
        }
        ownPrivKeystore = tmp.newFile("own_priv.p12");
        try (FileOutputStream fos = new FileOutputStream(ownPrivKeystore)) {
            fos.write(new byte[]{5,5,5});
        }
    }

    // ------------------ Utilitaires de mocks ------------------

    private PartnerPublicKeyPair mockPartner(String oldPath, String newPath) {
        PartnerPublicKeyPair p = mock(PartnerPublicKeyPair.class);
        when(p.getPublicKeyPath()).thenReturn(oldPath);
        when(p.getRenewedPublicKeyPath()).thenReturn(newPath);
        when(p.toString()).thenReturn("PartnerPublicKeyPair(" + oldPath + "," + newPath + ")");
        return p;
    }

    private PrivateKeyPair mockPrivatePair(String pgpPath, String ksPath, String pass, String alias) {
        PrivateKeyPair pair = mock(PrivateKeyPair.class);
        PrivateKey pgp = mock(PrivateKey.class);
        when(pgp.getPrivateKeyPath()).thenReturn(pgpPath);
        when(pgp.getPassphrase()).thenReturn(pass);
        when(pgp.getAlias()).thenReturn(null);

        PrivateKey ks = mock(PrivateKey.class);
        when(ks.getPrivateKeyPath()).thenReturn(ksPath);
        when(ks.getPassphrase()).thenReturn(pass);
        when(ks.getAlias()).thenReturn(alias);

        when(pair.getPrivateKey()).thenReturn(pgp);
        when(pair.getRenewedPrivateKey()).thenReturn(ks);
        when(pair.toString()).thenReturn("PrivateKeyPair(" + pgpPath + "," + ksPath + ")");
        return pair;
    }

    private PGPPublicKey mockEncKey(long id, boolean master, boolean usageOk, boolean valid) {
        PGPPublicKey k = mock(PGPPublicKey.class);
        when(k.getKeyID()).thenReturn(id);
        when(k.isEncryptionKey()).thenReturn(true);
        when(k.isMasterKey()).thenReturn(master);
        // hasKeyFlags: si usageOk -> signatures vides => true ; sinon -> signature incompatible
        if (usageOk) {
            when(k.getSignaturesOfType(anyInt())).thenReturn(Collections.<PGPSignature>emptyList().iterator());
        } else {
            PGPSignature sig = mock(PGPSignature.class);
            PGPSignatureSubpacketVector vec = mock(PGPSignatureSubpacketVector.class);
            when(sig.hasSubpackets()).thenReturn(true);
            when(sig.getHashedSubPackets()).thenReturn(vec);
            when(vec.hasSubpacket(eq(27))).thenReturn(true);
            when(vec.getKeyFlags()).thenReturn(KeyFlags.CERTIFY_OTHER); // pas ENCRYPT
            when(k.getSignaturesOfType(anyInt())).thenReturn(Collections.singletonList(sig).iterator());
        }
        if (valid) {
            when(k.getValidSeconds()).thenReturn(0L); // 0 => "toujours valide"
        } else {
            when(k.getValidSeconds()).thenReturn(1L);
            Date creation = new Date(System.currentTimeMillis() - 3600_000L); // déjà expiré
            when(k.getCreationTime()).thenReturn(creation);
        }
        return k;
    }

    private PGPSecretKey mockSigningSecretKey(long id) throws Exception {
        PGPSecretKey sk = mock(PGPSecretKey.class);
        PGPPublicKey pk = mock(PGPPublicKey.class);
        when(sk.getKeyID()).thenReturn(id);
        when(sk.isSigningKey()).thenReturn(true);
        when(sk.getPublicKey()).thenReturn(pk);
        when(pk.getUserIDs()).thenReturn(Collections.singletonList("user@test").iterator());
        when(pk.getValidSeconds()).thenReturn(0L);
        PGPPrivateKey priv = mock(PGPPrivateKey.class);
        when(sk.extractPrivateKey(any())).thenReturn(priv);
        return sk;
    }

    // ------------------ TESTS ENCRYPT ------------------

    @Test
    public void encrypt_happyPath_withSignature_textMode_armor_ok() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(partnerPubOld.getAbsolutePath(), partnerPubNew.getAbsolutePath());
        PrivateKeyPair privPair = mockPrivatePair(ownPrivPgp.getAbsolutePath(), null, "pass", null);

        // Clés publiques partenaires : une expirée (exercera isValidPGPPublicKey false) puis une valide
        PGPPublicKey expired = mockEncKey(0x10L, false, true, false);
        PGPPublicKey valid   = mockEncKey(0x11L, false, true, true);

        // Clé secrète de signature
        PGPSecretKey signKey = mockSigningSecretKey(0x22L);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPPublicKeyRing> pubRingC = mockConstruction(PGPPublicKeyRing.class, (mock, c) -> {
                 when(mock.getPublicKeys()).thenReturn(Arrays.asList(expired, valid).iterator());
             });
             MockedConstruction<PGPSecretKeyRing> secRingC = mockConstruction(PGPSecretKeyRing.class, (mock, c) -> {
                 when(mock.getSecretKeys()).thenReturn(Collections.singletonList(signKey).iterator());
             });
             MockedConstruction<PGPSignatureGenerator> sigGenC = mockConstruction(PGPSignatureGenerator.class, (sg, c) -> {
                 // generateOnePassVersion(false).encode(...)
                 PGPOnePassSignature ops = mock(PGPOnePassSignature.class);
                 when(sg.generateOnePassVersion(eq(false))).thenReturn(ops);
                 doNothing().when(ops).encode(any(OutputStream.class));
                 // update(...) sera appelé dans la boucle
                 doNothing().when(sg).update(any(byte[].class), anyInt(), anyInt());
                 // generate().encode(...)
                 PGPSignature fin = mock(PGPSignature.class);
                 when(sg.generate()).thenReturn(fin);
                 doNothing().when(fin).encode(any(OutputStream.class));
             });
             MockedConstruction<EncryptedOutputStream> encOutC = mockConstruction(EncryptedOutputStream.class);
             MockedConstruction<CompressedDataOutputStream> compOutC = mockConstruction(CompressedDataOutputStream.class);
             MockedConstruction<LiteralDataOutputStream> litOutC = mockConstruction(LiteralDataOutputStream.class, (lit, c) -> {
                 // l’écriture passe ici : on simule l’acceptation des writes
                 doNothing().when(lit).write(any(byte[].class), anyInt(), anyInt());
             })
        ) {
            // Toute détection PGP passe par un flux décodé
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class))).thenReturn(new ByteArrayInputStream(new byte[0]));

            cut.encryptOnePassSignature(
                    outArmored.getAbsolutePath(),
                    originalFile.getAbsolutePath(),
                    Collections.singletonList(partner),
                    privPair,
                    true,   // needSignature
                    true,   // useTextMode
                    true    // armor
            );

            // Le générateur de signature a été construit et mis à jour
            assertEquals(1, sigGenC.constructed().size());
            PGPSignatureGenerator sg = sigGenC.constructed().get(0);
            verify(sg, atLeastOnce()).update(any(byte[].class), anyInt(), anyInt());
            verify(sg, times(1)).generate();
        }
    }

    @Test
    public void encrypt_noSignature_noArmor_ok() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(partnerPubOld.getAbsolutePath(), partnerPubNew.getAbsolutePath());
        PGPPublicKey valid = mockEncKey(0x33L, false, true, true);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPPublicKeyRing> pubRingC = mockConstruction(PGPPublicKeyRing.class, (mock, c) -> {
                 when(mock.getPublicKeys()).thenReturn(Collections.singletonList(valid).iterator());
             });
             MockedConstruction<PGPSignatureGenerator> sigGenC = mockConstruction(PGPSignatureGenerator.class);
             MockedConstruction<EncryptedOutputStream> encOutC = mockConstruction(EncryptedOutputStream.class);
             MockedConstruction<CompressedDataOutputStream> compOutC = mockConstruction(CompressedDataOutputStream.class);
             MockedConstruction<LiteralDataOutputStream> litOutC = mockConstruction(LiteralDataOutputStream.class, (lit, c) -> {
                 doNothing().when(lit).write(any(byte[].class), anyInt(), anyInt());
             })
        ) {
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class))).thenReturn(new ByteArrayInputStream(new byte[0]));

            cut.encryptOnePassSignature(
                    outArmored.getAbsolutePath(),
                    originalFile.getAbsolutePath(),
                    Collections.singletonList(partner),
                    null,   // pas de signature
                    false,
                    false,
                    false
            );

            // Pas de générateur de signature construit
            assertEquals(0, sigGenC.constructed().size());
        }
    }

    @Test
    public void encrypt_throws_when_noPartners() {
        try {
            cut.encryptOnePassSignature(
                    outArmored.getAbsolutePath(),
                    originalFile.getAbsolutePath(),
                    null,   // liste nulle
                    null,
                    false, false, false
            );
            fail("IllegalArgumentException attendue");
        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains("No partner PGP public key file provided for encryption"));
        } catch (Exception e) {
            fail("Exception inattendue: " + e);
        }
    }

    @Test
    public void encrypt_throws_when_noValidEncryptionKey() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(partnerPubOld.getAbsolutePath(), partnerPubNew.getAbsolutePath());

        // Clés non valables : (1) master key avec usage incompatible, (2) expirée
        PGPPublicKey badUsage = mockEncKey(0x81L, true, false, true);
        PGPPublicKey expired  = mockEncKey(0x82L, false, true, false);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPPublicKeyRing> pubRingC = mockConstruction(PGPPublicKeyRing.class, (mock, c) -> {
                 when(mock.getPublicKeys()).thenReturn(Arrays.asList(badUsage, expired).iterator());
             })
        ) {
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class))).thenReturn(new ByteArrayInputStream(new byte[0]));

            try {
                cut.encryptOnePassSignature(
                        outArmored.getAbsolutePath(),
                        originalFile.getAbsolutePath(),
                        Collections.singletonList(partner),
                        null,
                        false, false, false
                );
                fail("IllegalArgumentException attendue");
            } catch (IllegalArgumentException ex) {
                assertTrue(ex.getMessage().contains("No valid PGP public key found"));
            }
        }
    }

    @Test
    public void encrypt_throws_when_needSignature_but_noPassphrase() {
        PartnerPublicKeyPair partner = mockPartner(partnerPubOld.getAbsolutePath(), partnerPubNew.getAbsolutePath());
        // Passphrase manquante -> readValidSigningDataSecretKey lèvera IAE "Passphrase is required for ..."
        PrivateKeyPair privPair = mockPrivatePair(ownPrivPgp.getAbsolutePath(), null, "", null);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPPublicKeyRing> pubRingC = mockConstruction(PGPPublicKeyRing.class, (mock, c) -> {
                 PGPPublicKey valid = mockEncKey(0x90L, false, true, true);
                 when(mock.getPublicKeys()).thenReturn(Collections.singletonList(valid).iterator());
             })
        ) {
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class))).thenReturn(new ByteArrayInputStream(new byte[0]));

            try {
                cut.encryptOnePassSignature(
                        outArmored.getAbsolutePath(),
                        originalFile.getAbsolutePath(),
                        Collections.singletonList(partner),
                        privPair,
                        true,  // needSignature => exigera passphrase
                        false, false
                );
                fail("IllegalArgumentException attendue");
            } catch (IllegalArgumentException ex) {
                assertTrue(ex.getMessage().contains("Passphrase is required for"));
            } catch (Exception ex) {
                fail("Exception inattendue: " + ex);
            }
        }
    }

    @Test
    public void encrypt_signature_usesKeystore_when_isPGPKeyFile_false() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(null, partnerPubNew.getAbsolutePath());
        PrivateKeyPair privPair = mockPrivatePair(null, ownPrivKeystore.getAbsolutePath(), "ksPass", "myAlias");

        PGPPublicKey encKey = mockEncKey(0x61L, false, true, true);

        // Keystore mocks
        KeyStore ks = mock(KeyStore.class);
        X509Certificate cert = mock(X509Certificate.class);
        PublicKey jcaPub = mock(PublicKey.class);
        java.security.PrivateKey jcaPriv = mock(java.security.PrivateKey.class);

        when(cert.getPublicKey()).thenReturn(jcaPub);
        when(cert.getNotBefore()).thenReturn(new Date(System.currentTimeMillis() - 1000));
        when(cert.getNotAfter()).thenReturn(new Date(System.currentTimeMillis() + 86_400_000));

        Enumeration<String> aliases = Collections.enumeration(Collections.singleton("myAlias"));
        when(ks.aliases()).thenReturn(aliases);
        when(ks.getKey(eq("myAlias"), any(char[].class))).thenReturn(jcaPriv);
        when(ks.getCertificate(eq("myAlias"))).thenReturn(cert);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedStatic<KeyStore> ksStatic = mockStatic(KeyStore.class);
             MockedConstruction<PGPPublicKeyRing> pubRingC = mockConstruction(PGPPublicKeyRing.class, (mock, c) -> {
                 when(mock.getPublicKeys()).thenReturn(Collections.singletonList(encKey).iterator());
             });
             MockedConstruction<JcaPGPKeyConverter> convC = mockConstruction(JcaPGPKeyConverter.class, (cvt, c) -> {
                 PGPPublicKey pgpPub = mock(PGPPublicKey.class);
                 PGPPrivateKey pgpPriv = mock(PGPPrivateKey.class);
                 when(cvt.getPGPPublicKey(eq(PublicKeyAlgorithmTags.RSA_GENERAL), any(PublicKey.class), any(Date.class)))
                         .thenReturn(pgpPub);
                 when(cvt.getPGPPrivateKey(any(PGPPublicKey.class), any(java.security.PrivateKey.class)))
                         .thenReturn(pgpPriv);
             });
             MockedConstruction<PGPSecretKey> pgpSecC = mockConstruction(PGPSecretKey.class, (psk, c) -> {
                 when(psk.getKeyID()).thenReturn(0x71L);
                 // utilisé ensuite par intiatePGPSignatureGenerator -> extractPrivateKey(...)
                 when(psk.extractPrivateKey(any())).thenReturn(mock(PGPPrivateKey.class));
                 PGPPublicKey pub = mock(PGPPublicKey.class);
                 when(pub.getAlgorithm()).thenReturn(PublicKeyAlgorithmTags.RSA_GENERAL);
                 when(pub.getUserIDs()).thenReturn(Collections.singletonList("user@test").iterator());
                 when(psk.getPublicKey()).thenReturn(pub);
             });
             MockedConstruction<PGPSignatureGenerator> sigGenC = mockConstruction(PGPSignatureGenerator.class, (sg, c) -> {
                 PGPOnePassSignature ops = mock(PGPOnePassSignature.class);
                 when(sg.generateOnePassVersion(eq(false))).thenReturn(ops);
                 doNothing().when(ops).encode(any(OutputStream.class));
                 doNothing().when(sg).update(any(byte[].class), anyInt(), anyInt());
                 PGPSignature fin = mock(PGPSignature.class);
                 when(sg.generate()).thenReturn(fin);
                 doNothing().when(fin).encode(any(OutputStream.class));
             });
             MockedConstruction<EncryptedOutputStream> encOutC = mockConstruction(EncryptedOutputStream.class);
             MockedConstruction<CompressedDataOutputStream> compOutC = mockConstruction(CompressedDataOutputStream.class);
             MockedConstruction<LiteralDataOutputStream> litOutC = mockConstruction(LiteralDataOutputStream.class, (lit, c) -> {
                 doNothing().when(lit).write(any(byte[].class), anyInt(), anyInt());
             })
        ) {
            ksStatic.when(() -> KeyStore.getInstance(eq("PKCS12"), eq("SunJSSE"))).thenReturn(ks);

            // 1er getDecoderStream (lecture public key) OK ; 2e (test isPGPKeyFile sur keystore) -> IOException => false
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class)))
                .thenReturn(new ByteArrayInputStream(new byte[0]))
                .thenThrow(new IOException("not pgp"));

            cut.encryptOnePassSignature(
                    outArmored.getAbsolutePath(),
                    originalFile.getAbsolutePath(),
                    Collections.singletonList(partner),
                    privPair,
                    true,  // signature
                    false, false
            );

            assertEquals(1, pgpSecC.constructed().size()); // secret key créée via keystore
        }
    }

    // ------------------ TESTS DECRYPT ------------------

    @Test
    public void decrypt_withSignature_ok() throws Exception {
        PartnerPublicKeyPair partner = mockPartner(partnerPubOld.getAbsolutePath(), partnerPubNew.getAbsolutePath());
        PrivateKeyPair privPair = mockPrivatePair(ownPrivPgp.getAbsolutePath(), null, "pass", null);

        // Private key PGP (pour readPGPPrivateKeysFromPGPKeyFile)
        PGPSecretKey sk = mockSigningSecretKey(0x42L);
        PGPPrivateKey priv = mock(PGPPrivateKey.class);
        when(sk.extractPrivateKey(any())).thenReturn(priv);

        // Public keys partenaires pour vérif signature (toutes acceptées)
        PGPPublicKey pubA = mockEncKey(0x51L, false, true, true);
        PGPPublicKey pubB = mockEncKey(0x52L, true, true, true);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPSecretKeyRing> secRingC = mockConstruction(PGPSecretKeyRing.class, (mock, c) -> {
                 when(mock.getSecretKeys()).thenReturn(Collections.singletonList(sk).iterator());
             });
             MockedConstruction<PGPPublicKeyRing> pubRingC = mockConstruction(PGPPublicKeyRing.class, (mock, c) -> {
                 when(mock.getPublicKeys()).thenReturn(Arrays.asList(pubA, pubB).iterator());
             });
             MockedConstruction<EncryptedInputStream> encInC = mockConstruction(EncryptedInputStream.class, (ins, c) -> {
                 when(ins.read(any(byte[].class), anyInt(), anyInt())).thenReturn(4).thenReturn(-1);
                 doNothing().when(ins).calculateSignature(any(byte[].class), anyInt(), anyInt());
                 doNothing().when(ins).verifySignature();
                 doNothing().when(ins).verifyIntegrity();
             })
        ) {
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class))).thenReturn(new ByteArrayInputStream(new byte[0]));

            cut.decryptOnePassSignature(
                    inEncrypted.getAbsolutePath(),
                    Collections.singletonList(partner),
                    privPair,
                    outDecrypted.getAbsolutePath(),
                    true
            );

            assertEquals(1, encInC.constructed().size());
            EncryptedInputStream ins = encInC.constructed().get(0);
            verify(ins, atLeastOnce()).calculateSignature(any(byte[].class), anyInt(), anyInt());
            verify(ins, times(1)).verifySignature();
            verify(ins, times(1)).verifyIntegrity();
        }
    }

    @Test
    public void decrypt_throws_when_verifySignature_and_noPartners() {
        PrivateKeyPair privPair = mockPrivatePair(ownPrivPgp.getAbsolutePath(), null, "pass", null);
        try {
            cut.decryptOnePassSignature(
                    inEncrypted.getAbsolutePath(),
                    Collections.<PartnerPublicKeyPair>emptyList(),
                    privPair,
                    outDecrypted.getAbsolutePath(),
                    true
            );
            fail("IllegalArgumentException attendue");
        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains("No partner PGP public key file provided for signature verification"));
        } catch (Exception e) {
            fail("Exception inattendue: " + e);
        }
    }

    @Test
    public void decrypt_throws_when_noPrivateKeyPair() {
        try {
            cut.decryptOnePassSignature(
                    inEncrypted.getAbsolutePath(),
                    null,
                    null,
                    outDecrypted.getAbsolutePath(),
                    false
            );
            fail("IllegalArgumentException attendue");
        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains("No PGP private key file provided for decryption"));
        } catch (Exception e) {
            fail("Exception inattendue: " + e);
        }
    }

    @Test
    public void decrypt_throws_when_noPrivateKeyRecovered_fromFiles() {
        // Fichiers vides -> existsAndNotEmptyContent=false
        File empty1 = new File(tmp.getRoot(), "empty1.asc");
        File empty2 = new File(tmp.getRoot(), "empty2.p12");

        PrivateKeyPair pkPair = mockPrivatePair(empty1.getAbsolutePath(), empty2.getAbsolutePath(), "pass", "alias");

        try {
            cut.decryptOnePassSignature(
                    inEncrypted.getAbsolutePath(),
                    null,
                    pkPair,
                    outDecrypted.getAbsolutePath(),
                    false
            );
            fail("IllegalArgumentException attendue");
        } catch (IllegalArgumentException e) {
            assertTrue(e.getMessage().contains("No PGP private key found from files"));
        } catch (Exception e) {
            fail("Exception inattendue: " + e);
        }
    }

    // ------------------ Vérification "verifyNoInteractions" requise ------------------

    @Test
    public void verifyNoInteractions_example() {
        PGPSignatureGenerator neverUsed = mock(PGPSignatureGenerator.class);
        verifyNoInteractions(neverUsed);
    }
}
