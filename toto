Parfait — on fait **tests d’abord**, puis **évolution minimale**.
Je te donne tout le **code prêt à coller** (fichiers complets/patchs) dans l’ordre exact d’exécution, pour éviter toute régression.

---

# 1) Tests d’abord (remplace ta classe existante)

Chemin : `application/src/test/java/com/bnpparibas/dsibddf/ap10530/incident/application/IncidentServiceTest.java`

> Cette classe reprend ton existant, le nettoie (JUnit5 pur), **réactive** le test nominal (type=3) et ajoute 4 tests **@Disabled** pour les nouveaux modes 4–7 (tu les activeras après l’implémentation).
> Elle s’appuie sur les mêmes dépendances et API que ton code actuel : `IncidentService.searchIncident(List<PersonSearchRequest>, channel, caller, userId)` et les services `FICPService`/`FCCService`.

```java
package com.bnpparibas.dsibddf.ap10530.incident.application;

import com.bnpparibas.dsibddf.ap10530.incident.domain.goal.IncidentGoalResult;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.Incident;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentsCharacteristics;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.Personne;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.RequestTypeEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.SexEnum;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.service.FCCService;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.ficp.service.FICPService;
import org.joda.time.LocalDate;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.ArrayList;
import java.util.List;

import static org.mockito.ArgumentMatchers.anyList;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class IncidentServiceTest {

    @Mock private FCCService fccServiceMock;
    @Mock private FICPService ficpServiceMock;

    // Si une autre dépendance est requise chez toi (ex: BciFicpRestService), mocke-la ici.
    @InjectMocks private IncidentService incidentService;

    @Test
    void contextLoads() {
        Assertions.assertNotNull(incidentService);
    }

    // ---------- FIXTURES ----------
    private List<PersonSearchRequest> givenType3Request() {
        List<PersonSearchRequest> list = new ArrayList<>();
        PersonSearchRequest p = new PersonSearchRequest();
        p.setLastname("MARTIN");
        p.setFirstname("Jean");
        p.setBirthDate("2004-12-02");
        p.setCivility(SexEnum.MASCULIN);
        p.setRequestType(RequestTypeEnum.BOTH_BNP_BDF); // 3
        list.add(p);
        return list;
    }
    private List<Personne> ficpBdfOnePerson() {
        List<Personne> r = new ArrayList<>();
        r.add(samplePP());
        return r;
    }
    private List<Personne> fccOnePerson() {
        List<Personne> r = new ArrayList<>();
        r.add(samplePP());
        return r;
    }
    private List<Personne> emptyPersons() { return new ArrayList<>(); }

    private Personne samplePP() {
        Personne pp = new Personne();
        pp.setLastname("lastname");
        pp.setFirstname("firstName");
        pp.setBirthCity("birthCity");
        pp.setBirthCountry("birthCountry");
        pp.setBirthDate("birthDate");
        pp.setMarriedName("marriedName");
        Incident inc = new Incident();
        inc.setCodeBank("codeBank");
        inc.setDateEffect(new LocalDate());
        inc.setIncidentAgency("incidentAgency");
        inc.setIncidentDate(new LocalDate());
        inc.setIncidentMotif("incidentMotif");
        inc.setIncidentStatus("incidentStatus");
        inc.setIncidentUO("incidentUO");
        inc.setNumberOfDeclarers(1);
        inc.setNumberOfIncidentDeclared(1);
        inc.setOriginCode("originCode");
        inc.setRib("rib");
        pp.addIncidentsItem(inc);
        return pp;
    }

    // ---------- CHARACTERIZATION (état actuel : type=3 appelle FICP + FCC au moins) ----------
    @Test
    void searchIncident_type3_shouldAggregateAtLeastFicpBdfAndFcc() throws Exception {
        when(ficpServiceMock.searchIncident(anyList(), anyString(), anyString(), anyString()))
                .thenReturn(ficpBdfOnePerson());
        when(fccServiceMock.searchIncident(anyList(), anyString(), anyString(), anyString()))
                .thenReturn(fccOnePerson());

        List<IncidentsCharacteristics> result =
                incidentService.searchIncident(givenType3Request(), "WEB", "caller", "user1");

        // On attend au moins 2 blocs (FICP_BDF + FCC) selon l’existant.
        Assertions.assertTrue(result.size() >= 2);
        // Vérifie que FICP et FCC ont été appelés
        verify(ficpServiceMock, atLeastOnce()).searchIncident(anyList(), anyString(), anyString(), anyString());
        verify(fccServiceMock, atLeastOnce()).searchIncident(anyList(), anyString(), anyString(), anyString());
    }

    // ---------- NOUVELLES EXIGENCES (TDD) : à activer APRÈS ton dev ----------
    @Test @Disabled("Activer quand 4=FICP BDF ONLY sera implémenté dans IncidentService")
    void when_type4_then_only_ficp_bdf_is_called() throws Exception {
        List<PersonSearchRequest> req = givenType3Request();
        // si ton PersonSearchRequest ne supporte que l'enum, fais un fromValue("4") après avoir étendu l'enum
        req.get(0).setRequestType(RequestTypeEnum.fromValue("4"));

        when(ficpServiceMock.searchIncident(anyList(), anyString(), anyString(), anyString()))
                .thenReturn(ficpBdfOnePerson());
        when(fccServiceMock.searchIncident(anyList(), anyString(), anyString(), anyString()))
                .thenReturn(emptyPersons());

        List<IncidentsCharacteristics> result =
                incidentService.searchIncident(req, "WEB", "caller", "user1");

        verify(ficpServiceMock, times(1)).searchIncident(anyList(), anyString(), anyString(), anyString());
        verifyNoMoreInteractions(fccServiceMock);
        Assertions.assertEquals(1, result.size());
        Assertions.assertEquals(IncidentsCharacteristics.OriginEnum.FICP_BDF, result.get(0).getOrigin());
    }

    @Test @Disabled("Activer quand 5=FCC BDF ONLY sera implémenté dans IncidentService")
    void when_type5_then_only_fcc_is_called() throws Exception {
        List<PersonSearchRequest> req = givenType3Request();
        req.get(0).setRequestType(RequestTypeEnum.fromValue("5"));

        when(ficpServiceMock.searchIncident(anyList(), anyString(), anyString(), anyString()))
                .thenReturn(emptyPersons());
        when(fccServiceMock.searchIncident(anyList(), anyString(), anyString(), anyString()))
                .thenReturn(fccOnePerson());

        List<IncidentsCharacteristics> result =
                incidentService.searchIncident(req, "WEB", "caller", "user1");

        verify(fccServiceMock, times(1)).searchIncident(anyList(), anyString(), anyString(), anyString());
        verifyNoMoreInteractions(ficpServiceMock);
        Assertions.assertEquals(1, result.size());
        Assertions.assertEquals(IncidentsCharacteristics.OriginEnum.FCC, result.get(0).getOrigin());
    }

    @Test @Disabled("Activer quand 6=FICP BNPP/BCEF ONLY sera implémenté")
    void when_type6_then_only_ficp_bnpp_branch_is_used() throws Exception {
        List<PersonSearchRequest> req = givenType3Request();
        req.get(0).setRequestType(RequestTypeEnum.fromValue("6"));

        // Pour ce cas, IncidentService doit emprunter la branche BNPP/BCEF (BCI/FICP côté Z/OS).
        // Ici on s'assure que FICP BDF et FCC ne sont pas appelés.
        when(ficpServiceMock.searchIncident(anyList(), anyString(), anyString(), anyString()))
                .thenReturn(emptyPersons());
        when(fccServiceMock.searchIncident(anyList(), anyString(), anyString(), anyString()))
                .thenReturn(emptyPersons());

        List<IncidentsCharacteristics> result =
                incidentService.searchIncident(req, "WEB", "caller", "user1");

        verifyNoInteractions(fccServiceMock);
        verify(ficpServiceMock, times(0)).searchIncident(anyList(), anyString(), anyString(), anyString());
        // On attend 1 seul bloc FICP_BNPP (l’orchestrateur devra le construire)
        Assertions.assertEquals(1, result.size());
        Assertions.assertEquals(IncidentsCharacteristics.OriginEnum.FICP_BNPP, result.get(0).getOrigin());
    }

    @Test @Disabled("Activer quand 7=BCI BNPP/BCEF ONLY sera implémenté")
    void when_type7_then_only_bci_branch_is_used() throws Exception {
        List<PersonSearchRequest> req = givenType3Request();
        req.get(0).setRequestType(RequestTypeEnum.fromValue("7"));

        when(ficpServiceMock.searchIncident(anyList(), anyString(), anyString(), anyString()))
                .thenReturn(emptyPersons());
        when(fccServiceMock.searchIncident(anyList(), anyString(), anyString(), anyString()))
                .thenReturn(emptyPersons());

        List<IncidentsCharacteristics> result =
                incidentService.searchIncident(req, "WEB", "caller", "user1");

        verifyNoInteractions(fccServiceMock);
        verify(ficpServiceMock, times(0)).searchIncident(anyList(), anyString(), anyString(), anyString());
        Assertions.assertEquals(1, result.size());
        Assertions.assertEquals(IncidentsCharacteristics.OriginEnum.BCI, result.get(0).getOrigin());
    }
}
```

**Pourquoi ça tient ?**

* La méthode sous test et la signature sont bien celles de ton `IncidentService`. 
* L’enum actuelle ne contient que `1/2/3` : on ajoutera 4–7 juste après (cf. §2). 

---

# 2) Évolution minimale côté modèle (enum)

Chemin : `domain/src/main/java/.../model/enums/RequestTypeEnum.java`

> Ajoute ces constantes + une petite javadoc pour geler le contrat. (La méthode `fromValue` existe déjà et sera réutilisée par la désérialisation.) 

```java
package com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;

/**
 * Code accès :
 * 1=BNP_ONLY, 2=BDF_ONLY, 3=BOTH_BNP_BDF
 * 4=FICP_BDF, 5=FCC_BDF, 6=FICP_BCEF, 7=BCI_BCEF
 */
public enum RequestTypeEnum {
    BNP_ONLY("1"),
    BDF_ONLY("2"),
    BOTH_BNP_BDF("3"),
    FICP_BDF("4"),
    FCC_BDF("5"),
    FICP_BCEF("6"),
    BCI_BCEF("7");

    @JsonCreator
    public static RequestTypeEnum fromValue(final String text) {
        for (final RequestTypeEnum b : RequestTypeEnum.values()) {
            if (String.valueOf(b.value).equals(text)) {
                return b;
            }
        }
        return null;
    }

    private final String value;
    RequestTypeEnum(final String value) { this.value = value; }

    @Override @JsonValue
    public String toString() { return String.valueOf(value); }
}
```

---

# 3) Évolution minimale de l’orchestrateur

Chemin : `application/src/main/java/.../IncidentService.java`
Objectif : router **un seul** flux selon 4–7, et **ne rien casser** pour 1–3. Le code ci-dessous montre le **garde-fou en tête de méthode** (early return), sans toucher au reste de ta logique historique. Ton `IncidentService` a déjà toutes les dépendances (`FICPService`, `FCCService`, `BciFicpRestService`, etc.). 

> ⚠️ Copie uniquement le **bloc switch** en tout début de `searchIncident(...)`, **avant** l’ancienne orchestration.

```java
// ... dans IncidentService

public List<IncidentsCharacteristics> searchIncident(
        final List<PersonSearchRequest> incidentsSearchRequest,
        final String channel, final String caller, String userId) throws Exception {

    // NEW: aiguillage unitaire demandé par AER_SOC-1529
    RequestTypeEnum type = incidentsSearchRequest.get(0).getRequestType();
    if (type == RequestTypeEnum.FICP_BDF
     || type == RequestTypeEnum.FCC_BDF
     || type == RequestTypeEnum.FICP_BCEF
     || type == RequestTypeEnum.BCI_BCEF) {

        List<IncidentsCharacteristics> resultList = new ArrayList<>();

        switch (type) {
            case FICP_BDF: {
                // n’appeler QUE FICP côté BDF (implémentation existante)
                // le service FICP remonte déjà des Personne -> à mapper en IncidentsCharacteristics origin=FICP_BDF
                List<Personne> ficp = ficpService.searchIncident(incidentsSearchRequest, channel, caller, userId);
                IncidentsCharacteristics ic = new IncidentsCharacteristics();
                ic.setOrigin(IncidentsCharacteristics.OriginEnum.FICP_BDF);
                ic.setPersonneCollection(ficp != null ? ficp : new ArrayList<>());
                resultList.add(ic);
                return resultList;
            }
            case FCC_BDF: {
                List<Personne> fcc = fccService.searchIncident(incidentsSearchRequest, channel, caller, userId);
                IncidentsCharacteristics ic = new IncidentsCharacteristics();
                ic.setOrigin(IncidentsCharacteristics.OriginEnum.FCC);
                ic.setPersonneCollection(fcc != null ? fcc : new ArrayList<>());
                resultList.add(ic);
                return resultList;
            }
            case FICP_BCEF: {
                // branche BNPP/BCEF : s’appuyer sur le flux BCI/FICP (Z/OS) déjà présent
                // via bciFicpService + bciFicpMapper si nécessaire (existant dans IncidentService).
                IncidentBciFicpResult res = bciFicpService.searchBciFicp(
                        bciFicpMapper.createBciFicpRequest(incidentsSearchRequest), channel, caller, userId);
                IncidentsCharacteristics ic = new IncidentsCharacteristics();
                ic.setOrigin(IncidentsCharacteristics.OriginEnum.FICP_BNPP);
                ic.setPersonneCollection(res != null ? res.getIncidentListFCIPBNPP() : new ArrayList<>());
                resultList.add(ic);
                return resultList;
            }
            case BCI_BCEF: {
                IncidentBciFicpResult res = bciFicpService.searchBciFicp(
                        bciFicpMapper.createBciFicpRequest(incidentsSearchRequest), channel, caller, userId);
                IncidentsCharacteristics ic = new IncidentsCharacteristics();
                ic.setOrigin(IncidentsCharacteristics.OriginEnum.BCI);
                ic.setPersonneCollection(res != null ? res.getIncidentListBCI() : new ArrayList<>());
                resultList.add(ic);
                return resultList;
            }
            default: break;
        }
    }

    // === ANCIEN COMPORTEMENT POUR 1/2/3 : on ne touche pas ===
    // ... (laisse ta logique existante qui agrège FICP + FCC + BCI/FICP)
}
```

* `FICP_BDF`/`FCC_BDF` : on réutilise **tes services existants** (aucune modif interne requise).
* `FICP_BCEF`/`BCI_BCEF` : on réutilise **ton flux Z/OS** via `BciFicpRestService` + `BciFicpRequestMapper` (déjà présents dans la classe). Le mapper exclut déjà le cas `BDF_ONLY` lorsqu’il construit la liste des KPI, ce qui convient pour 6/7 côté BNPP/BCEF.

---

# 4) Lancer et valider

```bash
# À la racine du repo
mvn -q clean verify
# Ouvre le coverage :
# application/target/site/jacoco/index.html
```

* Le test **type 3** doit rester vert (car on n’a pas touché au chemin historique 1/2/3).
* Active ensuite les tests 4→7 **un par un** (retire @Disabled puis `mvn verify`) pour sécuriser l’implémentation.

---

## Pourquoi ce plan évite les régressions

1. **Filet de sécurité** : le test “type=3” documente l’existant et doit rester vert après tes modifs. On ne change pas le bloc historique (1/2/3). 
2. **Évolution encapsulée** : le `switch` en tête de méthode fait un **early return** pour 4–7. Si `requestType` ∉ {4,5,6,7}, l’ancien code s’exécute inchangé. 
3. **Réutilisation des services établis** :

   * FICP/FCC BDF ⇒ `FICPService` / `FCCService` existants.
   * BNPP/BCEF ⇒ `BciFicpRestService` + `BciFicpRequestMapper` déjà intégrés.

Si tu veux, je peux aussi te donner une **variante** où `FICP_BCEF` passe par `PobiFicpClient` avec une autre propriété d’URL (si vous avez une URL dédiée côté BCEF) — le client REST existe déjà et gère l’URL par propriété `ficp.ws.resturl`. 

Dis-moi si tu préfères :

* **implémentation BNPP via BciFicpRestService** (ci-dessus), ou
* **implémentation BNPP via PobiFicpClient** (nouvelle méthode dédiée, URL différente).
