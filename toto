package com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.service.batch.security.openpgp;

import org.bouncycastle.openpgp.*;
import org.bouncycastle.openpgp.operator.PublicKeyDataDecryptorFactory;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.junit.MockitoJUnitRunner;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.Collections;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class EncryptedInputStreamTest {

    private InputStream baseStream;

    @Before
    public void setUp() {
        baseStream = new ByteArrayInputStream("seed".getBytes());
    }

    // --- utilitaire pour setter un champ privé d'instance
    private static void set(Object target, String field, Object value) throws Exception {
        Field f = target.getClass().getDeclaredField(field);
        f.setAccessible(true);
        f.set(target, value);
    }

    // --- utilitaire pour getter un champ privé d'instance
    private static Object get(Object target, String field) throws Exception {
        Field f = target.getClass().getDeclaredField(field);
        f.setAccessible(true);
        return f.get(target);
    }

    // --- 1) Constructeur : aucun encrypted data -> aucun throw (comportement actuel), couverture chemin
    @Test
    public void ctor_no_encrypted_data_should_complete_without_throwing() throws Exception {
        PGPObjectFactory factory = mock(PGPObjectFactory.class);
        PGPEncryptedDataList emptyList = mock(PGPEncryptedDataList.class);
        when(emptyList.getEncryptedDataObjects()).thenReturn(Collections.<PGPEncryptedData>emptyList().iterator());
        when(factory.nextObject()).thenReturn(emptyList);

        EncryptedInputStream s = new EncryptedInputStream(baseStream,
                Collections.<PGPPrivateKey>singletonList(mock(PGPPrivateKey.class)),
                Collections.<PGPPublicKey>singletonList(mock(PGPPublicKey.class)));
        set(s, "objectFactory", factory);
        // Pas d'exception attendue, couverture des premières lignes du ctor
        s.close();
    }

    // --- 2) Constructeur : chemin nominal avec marker + compressed + literal
    @Test
    public void ctor_nominal_with_marker_compressed_literal() throws Exception {
        PGPMarker marker = mock(PGPMarker.class);
        PGPEncryptedDataList encList = mock(PGPEncryptedDataList.class);
        PGPPublicKeyEncryptedData enc = mock(PGPPublicKeyEncryptedData.class);

        PGPPrivateKey priv = mock(PGPPrivateKey.class);
        when(priv.getKeyID()).thenReturn(123L);
        when(enc.getKeyID()).thenReturn(123L);
        when(enc.getDataStream(any(PublicKeyDataDecryptorFactory.class)))
                .thenReturn(new ByteArrayInputStream("dec".getBytes()));

        PGPCompressedData comp = mock(PGPCompressedData.class);
        when(comp.getDataStream()).thenReturn(new ByteArrayInputStream("comp".getBytes()));

        PGPLiteralData lit = mock(PGPLiteralData.class);
        when(lit.getDataStream()).thenReturn(new ByteArrayInputStream("ok".getBytes()));

        PGPObjectFactory factory = mock(PGPObjectFactory.class);
        when(factory.nextObject()).thenReturn(marker).thenReturn(encList).thenReturn(comp).thenReturn(lit);
        when(encList.getEncryptedDataObjects()).thenReturn(Arrays.asList((PGPEncryptedData) enc).iterator());

        EncryptedInputStream s = new EncryptedInputStream(baseStream,
                Collections.singletonList(priv),
                Collections.<PGPPublicKey>emptyList());
        set(s, "objectFactory", factory);
        s.close();
    }

    // --- 3) Constructeur : literal data null -> pas d’exception (comportement actuel), couverture
    @Test
    public void ctor_literal_stream_null_should_be_handled() throws Exception {
        PGPEncryptedDataList encList = mock(PGPEncryptedDataList.class);
        PGPPublicKeyEncryptedData enc = mock(PGPPublicKeyEncryptedData.class);
        when(encList.getEncryptedDataObjects()).thenReturn(Arrays.asList((PGPEncryptedData) enc).iterator());
        when(enc.getKeyID()).thenReturn(1L);

        PGPPrivateKey priv = mock(PGPPrivateKey.class);
        when(priv.getKeyID()).thenReturn(1L);
        when(enc.getDataStream(any(PublicKeyDataDecryptorFactory.class)))
                .thenReturn(new ByteArrayInputStream("x".getBytes()));

        PGPLiteralData lit = mock(PGPLiteralData.class);
        when(lit.getDataStream()).thenReturn(null);

        PGPObjectFactory factory = mock(PGPObjectFactory.class);
        when(factory.nextObject()).thenReturn(encList).thenReturn(lit);

        EncryptedInputStream s = new EncryptedInputStream(baseStream,
                Collections.singletonList(priv),
                Collections.<PGPPublicKey>emptyList());
        set(s, "objectFactory", factory);
        // Chemin exécuté, pas d’exception attendue selon implémentation actuelle
        s.close();
    }

    // --- 4) calculateSignature : met à jour si initialisée
    @Test
    public void calculateSignature_should_update_signature_when_initialized() throws Exception {
        EncryptedInputStream s = new EncryptedInputStream(baseStream,
                Collections.<PGPPrivateKey>emptyList(), Collections.<PGPPublicKey>emptyList());
        PGPOnePassSignature calc = mock(PGPOnePassSignature.class);
        set(s, "calculatedSignature", calc);
        set(s, "targetPartnerPGPPublicKey", mock(PGPPublicKey.class));

        s.calculateSignature("abc".getBytes(), 0, 3);
        verify(calc, times(1)).update(any(byte[].class), anyInt(), anyInt());
        s.close();
    }

    // --- 5) verifySignature : succès puis échec (exception convertie) — couverture des branches
    @Test
    public void verifySignature_should_cover_success_then_failure() throws Exception {
        EncryptedInputStream s = new EncryptedInputStream(baseStream,
                Collections.<PGPPrivateKey>emptyList(), Collections.<PGPPublicKey>emptyList());

        PGPSignatureList list = mock(PGPSignatureList.class);
        PGPSignature msgSig = mock(PGPSignature.class);
        when(list.iterator()).thenReturn(Arrays.asList(msgSig).iterator());

        PGPOnePassSignature calc = mock(PGPOnePassSignature.class);
        when(calc.getKeyID()).thenReturn(7L);
        when(msgSig.getKeyID()).thenReturn(7L);

        set(s, "calculatedSignature", calc);
        set(s, "targetPartnerPGPPublicKey", mock(PGPPublicKey.class));
        PGPObjectFactory factory = mock(PGPObjectFactory.class);
        set(s, "objectFactory", factory);
        when(factory.nextObject()).thenReturn(list);

        when(calc.verify(any(PGPSignature.class))).thenReturn(true);
        s.verifySignature(); // succès

        when(calc.verify(any(PGPSignature.class))).thenReturn(false);
        try {
            s.verifySignature();
            fail("Expected exception");
        } catch (Exception ex) {
            assertTrue(ex instanceof PGPException || ex instanceof IllegalStateException);
        }
        s.close();
    }

    // --- 6) verifyIntegrity : protégé OK, protégé KO, non protégé
    @Test
    public void verifyIntegrity_should_cover_all_paths() throws Exception {
        EncryptedInputStream s = new EncryptedInputStream(baseStream,
                Collections.<PGPPrivateKey>emptyList(), Collections.<PGPPublicKey>emptyList());
        PGPPublicKeyEncryptedData enc = mock(PGPPublicKeyEncryptedData.class);
        set(s, "publicKeyEncryptedData", enc);

        when(enc.isIntegrityProtected()).thenReturn(true);
        when(enc.verify()).thenReturn(true);
        s.verifyIntegrity(); // OK

        when(enc.verify()).thenReturn(false);
        try {
            s.verifyIntegrity();
            fail("Expected PGPException");
        } catch (PGPException expected) {
            // OK
        }

        when(enc.isIntegrityProtected()).thenReturn(false);
        s.verifyIntegrity(); // sans vérification
        s.close();
    }

    // --- 7) read() et read(byte[],off,len) déléguent au flux clair
    @Test
    public void read_should_delegate_to_clear_stream() throws Exception {
        EncryptedInputStream s = new EncryptedInputStream(baseStream,
                Collections.<PGPPrivateKey>emptyList(), Collections.<PGPPublicKey>emptyList());
        set(s, "clearTextInputStream", new ByteArrayInputStream("DATA".getBytes()));
        int first = s.read();
        assertTrue(first >= 0);
        byte[] buf = new byte[3];
        int n = s.read(buf, 0, 3);
        assertTrue(n >= 0);
        s.close();
    }

    // --- 8) close() multiple (idempotent)
    @Test
    public void close_should_be_idempotent() throws Exception {
        EncryptedInputStream s = new EncryptedInputStream(baseStream,
                Collections.<PGPPrivateKey>emptyList(), Collections.<PGPPublicKey>emptyList());
        s.close();
        s.close();
    }
}