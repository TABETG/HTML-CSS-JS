package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.update.writer;

import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

import java.util.Arrays;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.springframework.batch.item.Chunk;

import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.SynchroResult;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.loanfolder.model.LoanFolderEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.loanfolder.mapper.LoanFolderMapperToJpa;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.loanfolder.repository.LoanFolderAnswerJpaRepository;

/**
 * Test JUnit 4 pour LoanFolderSynchroItemWriter.
 * Compatible Jenkins/Sonar/Jacoco (pas de JUnit Jupiter, pas d'AssertJ).
 */
@RunWith(MockitoJUnitRunner.class)
public class LoanFolderSynchroItemWriterTest {

    @Mock
    private LoanFolderAnswerJpaRepository loanFolderAnswerJpaRepository;

    @InjectMocks
    private LoanFolderSynchroItemWriter writer;

    @Before
    public void setUp() {
        // Initialisation éventuelle avant chaque test
    }

    /**
     * Cas 1 : Aucun élément ne possède de synchronisation.
     * Le repository doit recevoir une liste vide.
     */
    @Test
    public void write_shouldCallSaveAllWithEmptyList_whenNoItemHasSynchronisation() {
        SynchroResult res1 = Mockito.mock(SynchroResult.class);
        SynchroResult res2 = Mockito.mock(SynchroResult.class);

        Chunk<SynchroResult> chunk = new Chunk<>(Arrays.asList(res1, res2));

        writer.write(chunk);

        // Capture correcte : typée LoanFolderEntity pour correspondre au repository
        ArgumentCaptor<List<LoanFolderEntity>> captor = ArgumentCaptor.forClass((Class) List.class);
        verify(loanFolderAnswerJpaRepository, times(1)).saveAll(captor.capture());

        // Vérifie que la liste passée est vide
        assertEquals(0, captor.getValue().size());
    }

    /**
     * Cas 2 : Un seul élément possède une synchronisation.
     * On vérifie que seul celui-ci est mappé et sauvegardé.
     */
    @Test
    public void write_shouldMapAndSaveOneEntity_whenOneItemHasSynchronisation() {
        SynchroResult noSync = Mockito.mock(SynchroResult.class);
        SynchroResult withSync = Mockito.mock(SynchroResult.class, Mockito.RETURNS_DEEP_STUBS);
        Mockito.when(withSync.getLoanFolderSynchroResult()).thenReturn(
                withSync.getLoanFolderSynchroResult()
        );

        Chunk<SynchroResult> chunk = new Chunk<>(Arrays.asList(noSync, withSync));

        // Création d'un mock d'entité à renvoyer depuis le mapper
        LoanFolderEntity mockEntity = Mockito.mock(LoanFolderEntity.class);

        // Mock statique de LoanFolderMapperToJpa
        try (MockedStatic<LoanFolderMapperToJpa> mocked = Mockito.mockStatic(LoanFolderMapperToJpa.class)) {
            mocked.when(() -> LoanFolderMapperToJpa.toJpa(any())).thenReturn(mockEntity);

            writer.write(chunk);

            // Capture du bon type
            ArgumentCaptor<List<LoanFolderEntity>> captor = ArgumentCaptor.forClass((Class) List.class);
            verify(loanFolderAnswerJpaRepository, times(1)).saveAll(captor.capture());

            // Vérifie qu’un seul élément est sauvegardé
            assertEquals(1, captor.getValue().size());
        }
    }
}