Super clair. Pour te donner une réponse exploitable tout de suite, je te liste tout ce qui doit avoir des tests pour faire monter la couverture Sonar, module par module, sous forme de chemins/patterns exacts. Je m’appuie sur ton POM parent et l’arbo fournie. 


---

Ce qu’il faut tester (à garder dans la couverture)

1) stream-fact-batch

Readers / Processors / Writers / Tasklets (toute la logique de traitement)

**/batch/**/reader/**.java

**/batch/**/processor/**.java

**/batch/**/writer/**.java (sauf Header/Footer callbacks “décoratifs”)

**/batch/**/tasklet/**.java


Listeners avec logique (modif d’ExitStatus, enrichissement contexte, retries, compteurs…)

**/batch/**/listener/**.java (sauf listeners purement log, voir exclusions de couverture)


RowMappers / Converters utilisés par les steps (format de dates, null-safety, parsing)

**/batch/**/rowmapper/**.java

**/batch/**/converter/**.java


Services et adaptateurs appelés par les steps (COS/CFT/Docaposte/PGP…)

**/batch/**/service/**.java

**/batch/**/adapter/**.java


Utilitaires avec logique utilisés par le batch

**/batch/**/util/**.java



> Exemples typiques de classes à tester dans ce module : Readers/Processors/Writers de synchro/closure/purge, Tasklets d’envoi (COS, chiffrement, CFT), RowMappers avec formatage, listeners qui ajustent l’ExitStatus.




---

2) stream-fact-domain

Services/Use-cases contenant des règles (même simples)

**/domain/**/service/**.java

**/domain/**/usecase/**.java


Logique “métier” hors DTO/enum/mapper

**/domain/**/helper/**.java

**/domain/**/util/**.java



> Ne testent pas : DTO/POJO, Enums, Mappers purs, interfaces de repository (cf. exclusions de couverture plus bas).




---

3) stream-fact-application

Orchestrations / Façades / Command handlers qui enchaînent des appels et gèrent des erreurs

**/application/**/service/**.java

**/application/**/command/**.java

**/application/**/facade/**.java


Intégration applicative avec logique (validation, mapping enrichi, décisions)

**/application/**/adapter/**.java




---

4) stream-fact-exposition

JMS/REST processors avec logique (filtrage, validation, routage, mapping non trivial)

**/exposition/**/jms/**/processor/**.java

**/exposition/**/rest/**/controller/**.java (si logique interne; sinon tester via tests d’intégration web)


Filtres/Intercepteurs qui modifient la requête/réponse ou le contexte

**/exposition/**/web/**/filter/**.java

**/exposition/**/web/**/interceptor/**.java



> Ne testent pas : DTO d’expo “plats”. Ils restent analysés mais peuvent être exclus de la couverture.




---

5) stream-fact-infra-sql

Implémentations personnalisées / logique SQL (au-delà des interfaces Spring Data)

**/infra-sql/**/repository/**/impl/**.java

**/infra-sql/**/dao/**.java

**/infra-sql/**/rowmapper/**.java


Converters (type handlers)

**/infra-sql/**/converter/**.java



> Ne testent pas : interfaces de repository, entités JPA (sauf logique particulière dans getters/custom methods).




---

6) stream-fact-infra-rest-clients / stream-fact-infra-soap-clients / stream-fact-infra-smtp / stream-fact-infra-static-filestore / stream-fact-infra-jms

Clients/Adapters avec logique de transformation/récupération/erreurs

**/infra-*/**/client/**.java

**/infra-*/**/adapter/**.java

**/infra-*/**/service/**.java


Wrappers PGP/COS/CFT si tu ne couvres pas ces flux via un test d’intégration de niveau batch

**/infra-*/**/security/**.java

**/infra-*/**/storage/**.java

**/infra-*/**/transfer/**.java



> Astuce : soit tu testes ces wrappers unitairement (write/close/erreurs), soit tu les couvres indirectement par un test de Tasklet/Writer qui les utilise.




---

Rappel — Ce qu’on peut retirer du calcul de couverture (mais garder analysé)

Ces classes restent analysées par Sonar (bugs/smells), mais ne plombent pas la couverture :

Wiring/Configuration sans logique :
**/*Application.java, **/*Configuration.java, **/*Config.java,
**/batch/**/job/**.java, **/batch/**/config/**.java.

Callbacks décoratifs :
**/batch/**/writer/*HeaderCallback*.java, **/batch/**/writer/*FooterCallback*.java.

Artefacts structurels “peu testables” :
**/exposition/**/dto/**.java,
**/domain/commons/**.java (enums/constantes),
**/domain/**/model/**.java (POJO),
**/domain/mapper/**/**.java (mappers purs),
**/domain/**/repository/**/**.java (interfaces).

Listeners purement log/no-op :
**/*Logging*Listener.java, **/*NoOp*Listener.java.


(ces patterns sont déjà intégrés dans le POM parent corrigé que je t’ai fourni.)


---

Ce qu’on exclut complètement du scan (donc pas à tester)

Répertoires de build et code généré :
**/target/**, **/build/**, **/out/**,
**/generated-sources/**, **/generated-test-sources/**,
schémas/artefacts : **/com/bnp/schema/**/**, **/xsd/**/**, **/wsdl/**/**, **/openapi/**/**, **/swagger/**/**, **/proto/**/**, **/jooq/**/**.
(déjà en place dans le POM parent que je t’ai envoyé). 



---

En deux phrases

Fais des tests partout où il y a de la logique (Readers/Processors/Writers/Tasklets, listeners non triviaux, RowMappers/Converters, services/adapters avec décisions ou gestion d’erreurs) dans tous les modules cités plus haut.

Ne perds pas de temps à tester le wiring (jobs/config), les DTO/Enums/Mappers purs/Repos interfaces, et les callbacks décoratifs : on les retire du calcul de couverture mais on garde leur analyse Sonar.