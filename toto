package com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.tasklet;

import com.bnpparibas.dsibddf.ap00420.streamfact.application.cos.CosService;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.test.util.ReflectionTestUtils;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.mockito.Mockito.*;

/**
 * Tests JUnit 4 pour SendToBMDUploadCOSTasklet.
 *
 * Objectifs (couverture 100 %) :
 *  - afterPropertiesSet() : pas d'effet (no-op).
 *  - execute() mock=true : FINISHED, aucune interaction COS.
 *  - execute() mock=false et succès : appel COS, ExitStatus.COMPLETED.
 *  - execute() mock=false et exception : ExitStatus.FAILED.
 *
 * Contraintes :
 *  - JUnit 4 uniquement (org.junit.*), pas de JUnit Jupiter.
 *  - @RunWith(MockitoJUnitRunner.class), pas d’AssertJ.
 *  - verifyNoInteractions(...) utilisé à la place de verifyZeroInteractions(...).
 */
@RunWith(MockitoJUnitRunner.class)
public class SendToBMDUploadCOSTaskletTest {

    /** SUT : tasklet sous test. */
    @InjectMocks
    private SendToBMDUploadCOSTasklet tasklet;

    /** Dépendance externe simulée (service COS). */
    @Mock
    private CosService cosService;

    /** Contexte Spring Batch réel pour vérifier ExitStatus et RepeatStatus. */
    private StepExecution stepExecution;
    private StepContribution contribution;

    @Before
    public void setUp() {
        // Construit un contexte réaliste pour que le tasklet puisse poser l'ExitStatus.
        JobExecution jobExecution = new JobExecution(1L);
        stepExecution = new StepExecution("sendToBMDUpload", jobExecution);
        contribution = new StepContribution(stepExecution);
    }

    /**
     * afterPropertiesSet() : la classe annonce "Nothing to do".
     * Aucune exception ni modification d'état attendue.
     */
    @Test
    public void afterPropertiesSet_should_do_nothing() throws Exception {
        tasklet.afterPropertiesSet();
    }

    /**
     * Branche mock=true :
     *  - Le tasklet lit 'encryptedFileName' mais n'appelle pas CosService.
     *  - RepeatStatus.FINISHED attendu (contrat Tasklet).
     */
    @Test
    public void execute_when_mock_true_should_finish_without_cos_call() throws Exception {
        // Préparation des champs injectés et du contexte
        ReflectionTestUtils.setField(tasklet, "mock", true);
        ReflectionTestUtils.setField(tasklet, "pathGenerateFile", "/tmp");
        ReflectionTestUtils.setField(tasklet, "prefix", "arch-");
        putEncryptedFileName("file.enc");

        ChunkContext chunkContext = new ChunkContext(new StepContext(stepExecution));

        // Exécution
        RepeatStatus status = tasklet.execute(contribution, chunkContext);

        // Vérifications
        assertEquals(RepeatStatus.FINISHED, status);
        // En mode mock, aucun appel effectif à COS
        verifyNoInteractions(cosService);
    }

    /**
     * Branche mock=false et succès :
     *  - Appel à cosService.pushArchiveFileToNewCOS(path, file, prefix).
     *  - ExitStatus.COMPLETED posé sur le StepExecution.
     *  - RepeatStatus.FINISHED.
     */
    @Test
    public void execute_when_mock_false_and_push_ok_should_set_completed() throws Exception {
        ReflectionTestUtils.setField(tasklet, "mock", false);
        ReflectionTestUtils.setField(tasklet, "pathGenerateFile", "/opt/export");
        ReflectionTestUtils.setField(tasklet, "prefix", "bkp-");
        putEncryptedFileName("daily.enc");

        ChunkContext chunkContext = new ChunkContext(new StepContext(stepExecution));

        RepeatStatus status = tasklet.execute(contribution, chunkContext);

        assertEquals(RepeatStatus.FINISHED, status);
        assertEquals(ExitStatus.COMPLETED, stepExecution.getExitStatus());
        verify(cosService, times(1))
                .pushArchiveFileToNewCOS("/opt/export", "daily.enc", "bkp-");
        verifyNoMoreInteractions(cosService);
    }

    /**
     * Branche mock=false et exception lors du push :
     *  - ExitStatus.FAILED posé sur le StepExecution.
     *  - RepeatStatus.FINISHED, conformément au contrat Tasklet.
     */
    @Test
    public void execute_when_mock_false_and_push_throws_should_set_failed() throws Exception {
        ReflectionTestUtils.setField(tasklet, "mock", false);
        ReflectionTestUtils.setField(tasklet, "pathGenerateFile", "/data/out");
        ReflectionTestUtils.setField(tasklet, "prefix", "pref-");
        putEncryptedFileName("broken.enc");

        // Simule une panne du service COS pendant le push
        doThrow(new RuntimeException("cos down"))
                .when(cosService).pushArchiveFileToNewCOS("/data/out", "broken.enc", "pref-");

        ChunkContext chunkContext = new ChunkContext(new StepContext(stepExecution));

        RepeatStatus status = tasklet.execute(contribution, chunkContext);

        assertEquals(RepeatStatus.FINISHED, status);
        assertEquals(ExitStatus.FAILED, stepExecution.getExitStatus());
        verify(cosService, times(1))
                .pushArchiveFileToNewCOS("/data/out", "broken.enc", "pref-");
        verifyNoMoreInteractions(cosService);
    }

    /**
     * Place 'encryptedFileName' dans le JobExecutionContext,
     * clé lue par le tasklet au début de execute(...).
     */
    private void putEncryptedFileName(String fileName) {
        assertNotNull(stepExecution);
        assertNotNull(stepExecution.getJobExecution());
        stepExecution.getJobExecution().getExecutionContext().put("encryptedFileName", fileName);
    }
}