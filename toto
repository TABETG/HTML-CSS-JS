Voici un test prêt à coller qui corrige ton erreur Mockito et fait monter la couverture de la classe BillingSpaceClosureProcessor (chemin et code confirmés dans tes fichiers). L’erreur vient du fait que tu “stubbais” LoanFolderMapperToDomain.toDomain(...) avec un type qui n’est pas LoanFolder (“WrongTypeOfReturnValue”) — or, la classe appelle bien ce mapper statique avant d’exécuter la commande. 


---

1) Test JUnit 5 + Mockito (avec mock statique)

Crée ce fichier :
src/test/java/com/bnpparibas/dsibddf/ap00420/streamfact/batch/billingspace/close/processor/BillingSpaceClosureProcessorTest.java

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.processor;

import com.bnpparibas.bddf.cqrs.command.v2.CommandExecutorV2;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.billingspace.close.CloseBillingSpaceCommand;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.billingspace.close.CloseBillingSpaceRequest;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.billingspace.close.pojo.BillingSpaceCloseToSend;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.loanfolder.model.LoanFolder;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.BillingSpaceEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.loanfolder.model.LoanFolderEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.loanfolder.mapper.LoanFolderMapperToDomain;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Couvre le scénario nominal et le scénario d'exception de process(...).
 * Points clés :
 * - mock statique du mapper LoanFolderMapperToDomain.toDomain(...) pour renvoyer un LoanFolder (bon type)
 * - vérification que CommandExecutorV2.execute(...) est appelé avec la commande attendue
 */
@ExtendWith(MockitoExtension.class)
class BillingSpaceClosureProcessorTest {

    @InjectMocks
    private BillingSpaceClosureProcessor processor;

    @Mock
    private CommandExecutorV2 commandExecutor;

    @Test
    void process_should_execute_command_with_mapped_loan_folder() throws Exception {
        // Arrange
        BillingSpaceEntity billingSpaceEntity = mock(BillingSpaceEntity.class);
        LoanFolderEntity loanFolderEntity = mock(LoanFolderEntity.class);
        when(billingSpaceEntity.getLoanFolder()).thenReturn(loanFolderEntity);

        // IMPORTANT : le mapper doit renvoyer un LoanFolder (le bon type) et pas un Object
        LoanFolder mappedLoanFolder = mock(LoanFolder.class);
        BillingSpaceCloseToSend expected = mock(BillingSpaceCloseToSend.class);

        try (MockedStatic<LoanFolderMapperToDomain> mockedMapper =
                     Mockito.mockStatic(LoanFolderMapperToDomain.class)) {

            mockedMapper.when(() -> LoanFolderMapperToDomain.toDomain(loanFolderEntity))
                        .thenReturn(mappedLoanFolder);

            when(commandExecutor.execute(eq(CloseBillingSpaceCommand.class), any(CloseBillingSpaceRequest.class)))
                    .thenReturn(expected);

            // Act
            BillingSpaceCloseToSend result = processor.process(billingSpaceEntity);

            // Assert
            assertSame(expected, result, "Le résultat doit être celui retourné par l'executor");

            // Vérifie que le mapper statique a bien été appelé avec l'entité fournie
            mockedMapper.verify(() -> LoanFolderMapperToDomain.toDomain(loanFolderEntity));

            // Optionnel : capture et vérifie des champs de la requête
            ArgumentCaptor<CloseBillingSpaceRequest> reqCap = ArgumentCaptor.forClass(CloseBillingSpaceRequest.class);
            verify(commandExecutor).execute(eq(CloseBillingSpaceCommand.class), reqCap.capture());
            // Si CloseBillingSpaceRequest a un getter getLoanFolder(), décommente :
            // assertSame(mappedLoanFolder, reqCap.getValue().getLoanFolder());
        }
    }

    @Test
    void process_should_propagate_exception_from_executor() throws Exception {
        // Arrange
        BillingSpaceEntity billingSpaceEntity = mock(BillingSpaceEntity.class);
        LoanFolderEntity loanFolderEntity = mock(LoanFolderEntity.class);
        when(billingSpaceEntity.getLoanFolder()).thenReturn(loanFolderEntity);

        LoanFolder mappedLoanFolder = mock(LoanFolder.class);

        try (MockedStatic<LoanFolderMapperToDomain> mockedMapper =
                     Mockito.mockStatic(LoanFolderMapperToDomain.class)) {

            mockedMapper.when(() -> LoanFolderMapperToDomain.toDomain(loanFolderEntity))
                        .thenReturn(mappedLoanFolder);

            when(commandExecutor.execute(eq(CloseBillingSpaceCommand.class), any(CloseBillingSpaceRequest.class)))
                    .thenThrow(new IllegalStateException("boom"));

            // Act + Assert
            IllegalStateException ex = assertThrows(IllegalStateException.class,
                    () -> processor.process(billingSpaceEntity));
            assertEquals("boom", ex.getMessage());
        }
    }
}

Pourquoi ça corrige l’erreur ?
BillingSpaceClosureProcessor.process(...) appelle le mapper statique LoanFolderMapperToDomain.toDomain(...) puis commandExecutor.execute(...). Il faut donc mock-er la méthode statique pour qu’elle retourne un LoanFolder (et non un Object). L’erreur “Object cannot be returned by toDomain() / toDomain() should return LoanFolder” provenait d’un stub au mauvais type. 


---

2) Dépendances test (si besoin dans ton pom.xml)

Dans le module stream-fact-batch (celui où se trouve la classe testée), assure-toi d’avoir ces deps test :

<!-- JUnit 5 + Mockito JUnit Jupiter -->
<dependency>
  <groupId>org.mockito</groupId>
  <artifactId>mockito-junit-jupiter</artifactId>
  <scope>test</scope>
</dependency>

<!-- Mockito inline pour le mock des méthodes statiques -->
<dependency>
  <groupId>org.mockito</groupId>
  <artifactId>mockito-inline</artifactId>
  <scope>test</scope>
</dependency>

Ton module utilise déjà Spring Batch et les tests batch (vu dans ton POM), donc rien d’autre à ajouter ici pour ce test. 


---

3) Lancer uniquement ce test (pratique pour la CI)

mvn -q -Dtest=BillingSpaceClosureProcessorTest test


---

4) Bonus bonnes pratiques pour booster la couverture rapidement

Couvrir la voie d’exception (déjà fait ci-dessus).

Si CloseBillingSpaceRequest expose des getters, asserter le contenu (ex. loanFolder).

Écrire un micro-test unitaire sur BillingSpaceClosureWriter.distinctByKey(...) (fonction pure), très simple et très “rentable” en couverture. Le writer/reader sont bien présents dans ton code exporté. 


Si tu veux, je te fournis aussi un test minimal pour distinctByKey(...) du writer — dis-le et je te le colle.