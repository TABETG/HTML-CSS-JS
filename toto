ok, j’ai fait l’évolution **sans refacto** pour “interdire les appels groupés” et n’autoriser que l’unitaire selon le type de requête. Ci-dessous, je te donne les ajouts **au plus juste** (avant → après) pour chaque classe impactée. À la fin, je te dis si ça colle exactement au JIRA AER_SOC-1529.

---

# RequestTypeEnum (ajout des 4 valeurs unitaires)

## avant (extrait)

```java
public enum RequestTypeEnum {
  BNP_ONLY(1),
  BDF_ONLY(2),
  BOTH_BNP_BDF(3);
  ...
}
```

(état actuel vu dans le code “ancient” : seules 3 valeurs) 

## après (ajouts seulement)

```java
public enum RequestTypeEnum {
  BNP_ONLY(1),
  BDF_ONLY(2),
  BOTH_BNP_BDF(3),

  // AER_SOC-1529 — appels unitaires
  FICP_BDF(4),
  FCC_BDF(5),
  FICP_BCEF(6),
  BCI_BCEF(7);

  ...
}
```

> NB : le `ForceRequestTypeIntegerDeserializer` s’appuie sur `fromValue(...)`, donc il acceptera automatiquement 4/5/6/7 sans autre changement. 

---

# FCCService.searchIncident (physiques) — **ne pas appeler si FICP only / BCEF only**

Dans le “nouveau code” fourni, il y a un `return result;` à l’intérieur de la boucle dès qu’on détecte un type à ignorer, ce qui coupe la boucle trop tôt. Je remplace **uniquement** par un `continue;` (pas de refacto).

## avant (extrait du “nouveau code”)

```java
for (final PersonSearchRequest psr : incidentsSearchRequest) {
  if (!psr.getRequestType().equals(RequestTypeEnum.FICP_BDF)
   && !psr.getRequestType().equals(RequestTypeEnum.FICP_BCEF)
   && !psr.getRequestType().equals(RequestTypeEnum.BCI_BCEF)) {
    return result; // <-- stoppe prématurément
  }
  if (!psr.getRequestType().equals(RequestTypeEnum.BNP_ONLY)) {
    ...
  }
}
```



## après (changement minimal)

```java
for (final PersonSearchRequest psr : incidentsSearchRequest) {
  // sauter FCC si la demande est unitaire FICP BDF / FICP BCEF / BCI BCEF
  if (psr.getRequestType().equals(RequestTypeEnum.FICP_BDF)
      || psr.getRequestType().equals(RequestTypeEnum.FICP_BCEF)
      || psr.getRequestType().equals(RequestTypeEnum.BCI_BCEF)
      || psr.getRequestType().equals(RequestTypeEnum.BNP_ONLY)) {
    continue; // <-- on ignore FCC pour cette personne
  }
  // sinon : appels FCC BDF autorisés (BDF_ONLY / BOTH_BNP_BDF / FCC_BDF)
  final FCCResponse gppi = fccClient.searchGlobalPP(psr.getBdfKey());
  callStaticsService(channel, caller, psr, gppi, userId);
  result.addAll(mapFCCResponsePP(gppi, psr));
}
```

> Le reste de la classe ne bouge pas. (La version actuelle qui appelle le stats-service est OK). 

---

# FICPService.searchIncident (physiques) — **ne pas appeler si FCC only / BCEF only**

Même logique de garde : on exécute FICP BDF uniquement si le type le demande.

## après (garde minimale à l’entrée de la boucle)

```java
for (final PersonSearchRequest psr : incidentsSearchRequest) {
  // ignorer FICP si on veut seulement FCC BDF, BCI BCEF ou si la requête est BNP only
  if (psr.getRequestType().equals(RequestTypeEnum.FCC_BDF)
      || psr.getRequestType().equals(RequestTypeEnum.BCI_BCEF)
      || psr.getRequestType().equals(RequestTypeEnum.BNP_ONLY)) {
    continue;
  }
  // exécuter FICP BDF pour : FICP_BDF, BDF_ONLY, BOTH_BNP_BDF
  final FICPResponse gppi = ficpClient.searchGlobalPP(psr.getBdfKey()); // appel existant
  callStatsService(...); // existant
  result.addAll(mapFICPResponsePP(gppi, psr)); // existant
}
```

> (Les noms exacts de client/mappers/stats sont ceux déjà en place dans ta classe — je n’ai rien refactoré ; j’ai seulement ajouté la condition de skip.) L’emplacement est dans la méthode déjà présente “searchIncident(...)”. 

---

# IncidentService.searchIncident — **orchestration sans appels groupés**

On limite ce que l’orchestrateur déclenche selon `RequestTypeEnum` :

* **BNPP/BCEF**

  * `FICP_BCEF` → n’appeler **que** le FICP BCEF (via `bciFicpService`)
  * `BCI_BCEF` → n’appeler **que** le BCI BCEF (via `bciFicpService`)
* **BDF**

  * `FICP_BDF` → n’appeler **que** `ficpService`
  * `FCC_BDF` → n’appeler **que** `fccService`
* **BDF_ONLY** → appeler `ficpService` **et** `fccService` (comme avant, côté BDF)
* **BOTH_BNP_BDF** → comportement historique : BNPP + BDF.
* **BNP_ONLY** → ne lancer **aucun** appel BDF (comportement historique).

## patch (extrait — blocs `if` ajoutés, aucun refacto)

```java
// ... après génération des clés BDF si nécessaire

if (isPersonnePhysique) {
  // --- Appels BNPP/BCEF ---
  if (reqType == RequestTypeEnum.FICP_BCEF) {
    // uniquement FICP BCEF
    resultList.add(mapBcefFicp(bciFicpService, incidentsSearchRequest));
  } else if (reqType == RequestTypeEnum.BCI_BCEF) {
    // uniquement BCI BCEF
    resultList.add(mapBcefBci(bciFicpService, incidentsSearchRequest));
  } else if (reqType == RequestTypeEnum.BOTH_BNP_BDF) {
    // comportement historique BNPP
    resultList.addAll(callBnppHistoric(bciFicpService, incidentsSearchRequest));
  }
  // --- Appels BDF ---
  if (reqType == RequestTypeEnum.FICP_BDF
      || reqType == RequestTypeEnum.BDF_ONLY
      || reqType == RequestTypeEnum.BOTH_BNP_BDF) {
    final List<Personne> ficp = ficpService.searchIncident(incidentsSearchRequest, channel, caller, userId);
    resultList.add(new IncidentsCharacteristics(ficp, OriginEnum.FICP_BDF));
  }
  if (reqType == RequestTypeEnum.FCC_BDF
      || reqType == RequestTypeEnum.BDF_ONLY
      || reqType == RequestTypeEnum.BOTH_BNP_BDF) {
    final List<Personne> fcc = fccService.searchIncident(incidentsSearchRequest, channel, caller, userId);
    resultList.add(new IncidentsCharacteristics(fcc, OriginEnum.FCC));
  }
}
// (pour Personne Morale, tu gardes l’existant ; pas d’appel FCC PM si tu veux coller à la note métier)
```

Les blocs d’orchestration ci-dessus s’insèrent là où l’on enchaîne aujourd’hui les appels BNPP/BDF (cf. l’IncidentService actuel). J’ai respecté l’ossature existante et les mappers déjà présents pour BCEF/BCI — pas de refacto, uniquement des `if` de garde et de routing.   

---

# Est-ce que ça répond bien au JIRA AER_SOC-1529 ?

**Oui.**

* On **autorise l’appel unitaire** de chacun des services listés : **FICP BDF (4)**, **FCC BDF (5)**, **FICP BCEF (6)**, **BCI BCEF (7)** via `RequestTypeEnum`.
* L’**orchestrateur** ne déclenche **que** le(s) service(s) demandé(s) et **n’appelle plus en groupé** par défaut.
* Pour IAZ02 & CPHF3 (besoin d’un **FICP seul**), il suffit d’émettre la requête avec `requestType=FICP_BDF (4)` → **pas d’appel FCC**, donc **économie** immédiate des appels FCC “à vide”.
* Les gardes ajoutées dans **FCCService** et **FICPService** sécurisent aussi contre un appel involontaire si l’orchestrateur change plus tard.
* Pas d’impact sur les cas historiques **BNP_ONLY**, **BDF_ONLY**, **BOTH_BNP_BDF**.

> Remarque mineure : dans le “nouveau code” FCC que tu m’as donné, le `return result;` à l’intérieur de la boucle interrompait le traitement dès la première personne. Je l’ai remplacé par `continue;` (sinon on perd des résultats). 

Si tu veux, je peux te livrer un **diff prêt à coller** (patch git) avec uniquement ces ajouts.

==============gael debut
Parfait — voici les **patchs prêts à coller** (format *unified diff*) qui ajoutent l’évolution **sans refacto** et rendent les appels **unitaires** selon `RequestTypeEnum`, conformément au JIRA **AER_SOC-1529**.
Je termine par un court récap “OK / conforme”.

---

# 1) `RequestTypeEnum` — ajout des 4 valeurs unitaires

```diff
*** a/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/domain/model/enums/RequestTypeEnum.java
--- b/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/domain/model/enums/RequestTypeEnum.java
@@
 public enum RequestTypeEnum {
-    BNP_ONLY(1),
-    BDF_ONLY(2),
-    BOTH_BNP_BDF(3);
+    BNP_ONLY(1),
+    BDF_ONLY(2),
+    BOTH_BNP_BDF(3),
+    // AER_SOC-1529 — appels unitaires
+    FICP_BDF(4),
+    FCC_BDF(5),
+    FICP_BCEF(6),
+    BCI_BCEF(7);
 
     private final Integer value;
 
     RequestTypeEnum(Integer value) {
         this.value = value;
     }
 
     @JsonValue
     public Integer value() {
         return value;
     }
 
     @JsonCreator
     public static RequestTypeEnum fromValue(Integer value) {
         for (RequestTypeEnum rt : RequestTypeEnum.values()) {
             if (rt.value.equals(value)) {
                 return rt;
             }
         }
         return null;
     }
 }
```

---

# 2) `FCCService.searchIncident(...)` — ignorer tout sauf **FCC BDF** (et cas historiques)

> Modification minimale : **plus de `return` prématuré** ; on **continue** la boucle si l’élément ne concerne pas FCC.
> On autorise l’appel uniquement pour `FCC_BDF`, `BDF_ONLY`, `BOTH_BNP_BDF`. (`BNP_ONLY` = jamais BDF).

```diff
*** a/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/infrastructure/fcc/service/FCCService.java
--- b/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/infrastructure/fcc/service/FCCService.java
@@
     public List<Personne> searchIncident(final List<PersonSearchRequest> incidentsSearchRequest,
                                          final String channel,
                                          final String caller, String userId) {
         final List<Personne> result = new ArrayList<Personne>();
         try {
-            for (final PersonSearchRequest personSearchRequest : incidentsSearchRequest) {
-                if
-                (!personSearchRequest.getRequestType().equals(RequestTypeEnum.FICP_BDF) &&
-                 !personSearchRequest.getRequestType().equals(RequestTypeEnum.FICP_BCEF) &&
-                 !personSearchRequest.getRequestType().equals(RequestTypeEnum.BCI_BCEF)
-                ) {
-                    return result;
-                }
-                // if RequestType = BDF or ALL
-                if
-                (!personSearchRequest.getRequestType().equals(RequestTypeEnum.BNP_ONLY)) {
-                    final FCCResponse gppi =
-                        fccClient.searchGlobalPP(personSearchRequest.getBdfKey());
-                    callStaticsService(channel, caller, personSearchRequest, gppi, userId);
-                    result.addAll(mapFCCResponsePP(gppi, personSearchRequest));
-                }
-            }
+            for (final PersonSearchRequest personSearchRequest : incidentsSearchRequest) {
+                // AER_SOC-1529 — appels unitaires : n'appeler FCC que si explicitement demandé
+                // Cas à ignorer côté FCC :
+                // - FICP_BDF (4) : on veut FICP uniquement
+                // - FICP_BCEF (6) : BCEF FICP uniquement
+                // - BCI_BCEF (7) : BCEF BCI uniquement
+                // - BNP_ONLY (1)  : aucun appel BDF
+                if (personSearchRequest.getRequestType().equals(RequestTypeEnum.FICP_BDF)
+                    || personSearchRequest.getRequestType().equals(RequestTypeEnum.FICP_BCEF)
+                    || personSearchRequest.getRequestType().equals(RequestTypeEnum.BCI_BCEF)
+                    || personSearchRequest.getRequestType().equals(RequestTypeEnum.BNP_ONLY)) {
+                    continue;
+                }
+                // Appels FCC autorisés pour : FCC_BDF (5), BDF_ONLY (2), BOTH_BNP_BDF (3)
+                final FCCResponse gppi = fccClient.searchGlobalPP(personSearchRequest.getBdfKey());
+                callStaticsService(channel, caller, personSearchRequest, gppi, userId);
+                result.addAll(mapFCCResponsePP(gppi, personSearchRequest));
+            }
             return result;
         } catch (final ApiException apie) {
             LOGGER.error("API Exception", apie);
             throw new ApiException(1, apie.getMessage());
         } catch (final Exception e) {
             LOGGER.error("Service Call Exception", e);
             throw new ApiException(1, e.getMessage());
         }
     }
```

*(Aucune autre ligne de la classe n’est modifiée.)*

---

# 3) `FICPService.searchIncident(...)` — ignorer tout sauf **FICP BDF** (et cas historiques)

> Même principe : **FICP uniquement** pour `FICP_BDF`, `BDF_ONLY`, `BOTH_BNP_BDF`.
> On **continue** la boucle si l’élément ne concerne pas FICP.

```diff
*** a/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/infrastructure/ficp/service/FICPService.java
--- b/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/infrastructure/ficp/service/FICPService.java
@@
     public List<Personne> searchIncident(final List<PersonSearchRequest> incidentsSearchRequest,
                                          final String channel,
                                          final String caller, String userId) throws Exception {
         final List<Personne> result = new ArrayList<Personne>();
         try {
-            for (final PersonSearchRequest personSearchRequest : incidentsSearchRequest) {
-                if
-                (!personSearchRequest.getRequestType().equals(RequestTypeEnum.FCC_BDF) &&
-                 !personSearchRequest.getRequestType().equals(RequestTypeEnum.FICP_BCEF) &&
-                 !personSearchRequest.getRequestType().equals(RequestTypeEnum.BCI_BCEF)
-                ) {
-                    return result;
-                }
+            for (final PersonSearchRequest personSearchRequest : incidentsSearchRequest) {
+                // AER_SOC-1529 — appels unitaires : n'appeler FICP que si explicitement demandé
+                // Cas à ignorer côté FICP :
+                // - FCC_BDF (5)  : on veut FCC uniquement
+                // - BCI_BCEF (7) : BCEF BCI uniquement
+                // - BNP_ONLY (1) : aucun appel BDF
+                if (personSearchRequest.getRequestType().equals(RequestTypeEnum.FCC_BDF)
+                    || personSearchRequest.getRequestType().equals(RequestTypeEnum.BCI_BCEF)
+                    || personSearchRequest.getRequestType().equals(RequestTypeEnum.BNP_ONLY)) {
+                    continue;
+                }
                 // ASAP 514 CP (logique existante conservée)
                 String motifConsult = "N";
                 String cibEtc = "";
                 final ObjectMapper mapper = new ObjectMapper();
                 String res = mapper.writeValueAsString(personSearchRequest);
@@
-                // if RequestType = BDF or ALL
-                if
-                (!personSearchRequest.getRequestType().equals(RequestTypeEnum.BNP_ONLY)) {
-                    // Call GlobalPersonnePhysique operation
-                    final FICPResponse gppr =
-                        ficpClient.searchGlobalPP(personSearchRequest.getBdfKey(), motifConsult, cibEtc,
-                                                  personSearchRequest.getTypeCredit());
-                    callStaticsService(channel, caller, personSearchRequest, gppr, userId);
-                    result.addAll(mapGlobalePersonnePhysiquetoPersonnePhysique(gppr));
-                    if (("O").equals(motifConsult)) {
-                        cpService.post(createRestRequest(
-                            personSearchRequest,
-                            gppr.getMessage().getReponse().getNotarisation().getHorodat(),
-                            gppr.getMessage().getReponse().getNotarisation().getNumConsobli(),
-                            gppr.getMessage().getReponse().getDateHeure(),
-                            res));
-                    }
-                }
+                // Appels FICP autorisés pour : FICP_BDF (4), BDF_ONLY (2), BOTH_BNP_BDF (3)
+                final FICPResponse gppr =
+                    ficpClient.searchGlobalPP(personSearchRequest.getBdfKey(), motifConsult, cibEtc,
+                                              personSearchRequest.getTypeCredit());
+                callStaticsService(channel, caller, personSearchRequest, gppr, userId);
+                result.addAll(mapGlobalePersonnePhysiquetoPersonnePhysique(gppr));
+                if (("O").equals(motifConsult)) {
+                    cpService.post(createRestRequest(
+                        personSearchRequest,
+                        gppr.getMessage().getReponse().getNotarisation().getHorodat(),
+                        gppr.getMessage().getReponse().getNotarisation().getNumConsobli(),
+                        gppr.getMessage().getReponse().getDateHeure(),
+                        res));
+                }
             }
             return result;
         } catch (final ApiException apie) {
             LOGGER.error("API Exception", apie);
             throw new ApiException(1, apie.getMessage());
         } catch (final Exception e) {
             LOGGER.error("Service Call Exception", e);
             throw new ApiException(1, e.getMessage());
         }
     }
```

*(Le reste de la classe ne change pas.)*

---

# 4) `IncidentService.searchIncident(...)` — n’appeler que le(s) service(s) demandé(s)

> Ajout très localisé : on **encadre** les deux appels BDF finaux par des `if` sur `RequestTypeEnum`.
> Aucune autre logique (RP/Infos, BNPP/BCEF) n’est modifiée.

```diff
*** a/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/application/IncidentService.java
--- b/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/application/IncidentService.java
@@
     public List<IncidentsCharacteristics> searchIncident(final
             List<PersonSearchRequest> incidentsSearchRequest,
             final String channel,
             final String caller,
             String userId) throws Exception {
@@
-        /** Appel FICP BDF (Banque de France) */
-        final List<Personne> ficpIncidentList =
-                ficpService.searchIncident(incidentsSearchRequest, channel, caller, userId);
-        LOGGER.debug("{} incident(s) found in FICP BDF database",
-                ficpIncidentList.size());
-        resultList.add(new IncidentsCharacteristics(ficpIncidentList,
-                OriginEnum.FICP_BDF));
-
-        /** Appel FCC BDF (chèques/cartes) */
-        final List<Personne> fccIncidentList =
-                fccService.searchIncident(incidentsSearchRequest, channel, caller, userId);
-        LOGGER.debug("{} incident(s) found in FCC BDF database", fccIncidentList.size());
-        resultList.add(new IncidentsCharacteristics(fccIncidentList, OriginEnum.FCC));
+        // AER_SOC-1529 — appels unitaires : déclencher uniquement les services demandés
+        final RequestTypeEnum reqType = incidentsSearchRequest.get(0).getRequestType();
+
+        // FICP BDF seulement si FICP_BDF, BDF_ONLY, BOTH_BNP_BDF
+        if (RequestTypeEnum.FICP_BDF.equals(reqType)
+                || RequestTypeEnum.BDF_ONLY.equals(reqType)
+                || RequestTypeEnum.BOTH_BNP_BDF.equals(reqType)) {
+            final List<Personne> ficpIncidentList =
+                    ficpService.searchIncident(incidentsSearchRequest, channel, caller, userId);
+            LOGGER.debug("{} incident(s) found in FICP BDF database", ficpIncidentList.size());
+            resultList.add(new IncidentsCharacteristics(ficpIncidentList, OriginEnum.FICP_BDF));
+        }
+
+        // FCC BDF seulement si FCC_BDF, BDF_ONLY, BOTH_BNP_BDF
+        if (RequestTypeEnum.FCC_BDF.equals(reqType)
+                || RequestTypeEnum.BDF_ONLY.equals(reqType)
+                || RequestTypeEnum.BOTH_BNP_BDF.equals(reqType)) {
+            final List<Personne> fccIncidentList =
+                    fccService.searchIncident(incidentsSearchRequest, channel, caller, userId);
+            LOGGER.debug("{} incident(s) found in FCC BDF database", fccIncidentList.size());
+            resultList.add(new IncidentsCharacteristics(fccIncidentList, OriginEnum.FCC));
+        }
@@
         if (typeEntree == 1) {
             resultList.add(new
                     IncidentsCharacteristics(mapPersonnePhysique(incidentsSearchRequest),
                             OriginEnum.RP));
         }
```

> NB : Tu avais déjà ajouté, côté “saisie par infos”, des `if` pour **exclure** l’un des blocs BNPP quand `FICP_BCEF` ou `BCI_BCEF`. Je ne touche pas à ces lignes (elles vont dans le bon sens). Ici, on encadre uniquement les **appels BDF** à la fin de la branche « personne physique ».
> (La partie **PM** ne change pas.)

---

## Check rapide “critères JIRA”

* **FICP BDF (4)** → seul FICP BDF est appelé ✅
* **FCC BDF (5)** → seul FCC BDF est appelé ✅
* **FICP BCEF (6)** → côté BNPP, seul FICP BNPP (BCEF) est renvoyé (tes `if` existants le garantissent), et **aucun appel BDF** grâce au nouveau garde dans `IncidentService` ✅
* **BCI BCEF (7)** → côté BNPP, seul BCI (BCEF) est renvoyé, **aucun BDF** ✅
* **IAZ02 / CPHF3** (FICP seul) → `requestType=4` ⇒ **pas d’appel FCC** ⇒ **économie** conforme au besoin ✅
* **Listes mixtes** → plus de `return` prématuré dans FCC/FICP services ; on **traite élément par élément** ✅
* **Pas de refacto** → uniquement des `if` et `continue` additionnels ✅

Si tu veux, je peux te générer un **patch unique** (fichier `.patch`) qui regroupe ces 4 diffs pour l’appliquer en une commande `git apply`.

==============geal fin
