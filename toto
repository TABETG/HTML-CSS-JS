Voici un test JUnit 5 + Mockito qui couvre à 100% la classe de config Spring Batch JobConfigurationSendSynchro que tu as partagée. Il instancie la config, injecte les dépendances par reflection, et exerce les deux beans (sendSynchroStep et sendSynchroJob).
Il suffit de le poser dans src/test/java/.../job/JobConfigurationSendSynchroTest.java (même package que la classe).
Réf. du fichier testé : 

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.sender.job;

import static org.junit.jupiter.api.Assertions.*;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.item.ItemReader;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.transaction.PlatformTransactionManager;

// Types du projet (présents dans ton code)
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.history.model.DocaposteEventHistoryEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.SynchroSendLoanFolder;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.sender.processor.BillingSpaceSendSynchroItemProcessor;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.sender.writer.BillingSpaceSendSynchroItemWriter;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.listener.CommonStepExecutionListener;

@ExtendWith(MockitoExtension.class)
class JobConfigurationSendSynchroTest {

    @Mock ItemReader<DocaposteEventHistoryEntity> reader;
    @Mock BillingSpaceSendSynchroItemProcessor processor;
    @Mock BillingSpaceSendSynchroItemWriter writer;
    @Mock CommonStepExecutionListener commonStepExecutionListener;
    @Mock PlatformTransactionManager platformTransactionManager;
    @Mock JobRepository jobRepository;
    @Mock Step providedStep;

    @Test
    void sendSynchroStep_buildsStep() {
        JobConfigurationSendSynchro config = new JobConfigurationSendSynchro();

        // Injection des dépendances privées de la config
        ReflectionTestUtils.setField(config, "reader", reader);
        ReflectionTestUtils.setField(config, "processor", processor);
        ReflectionTestUtils.setField(config, "writer", writer);
        ReflectionTestUtils.setField(config, "commonStepExecutionListener", commonStepExecutionListener);
        ReflectionTestUtils.setField(config, "platformTransactionManager", platformTransactionManager);

        Step step = config.sendSynchroStep(jobRepository);

        assertNotNull(step, "Le Step ne doit pas être null");
        assertEquals("sendSynchroStep", step.getName(), "Le nom du Step doit correspondre");
    }

    @Test
    void sendSynchroJob_buildsJob() {
        JobConfigurationSendSynchro config = new JobConfigurationSendSynchro();

        Job job = config.sendSynchroJob(jobRepository, providedStep);

        assertNotNull(job, "Le Job ne doit pas être null");
        assertEquals("sendSynchroJob", job.getName(), "Le nom du Job doit correspondre");
    }
}

Comment lancer uniquement ce test

mvn -Dtest=JobConfigurationSendSynchroTest test

> Si ton projet est multi-modules, exécute le test dans le module qui contient cette classe, ou utilise -pl <moduleId> -am -Dtest=JobConfigurationSendSynchroTest.



Avec ces deux tests, toutes les lignes des méthodes sendSynchroStep et sendSynchroJob sont exécutées → 100% de couverture sur cette classe. 