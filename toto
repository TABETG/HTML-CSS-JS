Top ‚Äî je te file tout, bloc par bloc, sans casser l‚Äôexistant et sans renommer les signatures.
Je m‚Äôappuie sur l‚Äôarborescence et les classes que tu as dans le PDF (interface BankingIncidentsApi, contr√¥leur BankingIncidentsApiController, mappers & mod√®les).  


---

Bloc 1 ‚Äî Interface API (existant + endpoint additionnel ‚Äúorchestrated‚Äù)

üìÑ Fichier : exposition/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/exposition/api/BankingIncidentsApi.java

‚û°Ô∏è On laisse ton endpoint existant tel quel.
‚û°Ô∏è On ajoute un second endpoint (additif) pour l‚Äôappel unitaire/orchestr√©, sans impacter le chemin existant.

package com.bnpparibas.dsibddf.ap10530.incident.exposition.api;

import java.util.List;

import jakarta.validation.Valid;
import jakarta.validation.constraints.Size;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentsCharacteristics;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.exposition.model.ErrorModel;

/**
 * Incident Application controler interface.
 * Auteur: Desprez / Tahiri
 */
public interface BankingIncidentsApi {

    String APPLICATION_JSON_UTF8_VALUE = "application/json;charset=UTF-8";
    String VERSION = "/v1";
    String USER_ID = "UserId";

    String X_B3_SPAN_ID = "X-B3-SpanId";
    String X_B3_TRACE_ID = "X-B3-TraceId";
    String CHANNEL = "Channel";
    String MEDIA = "Media";
    String LANGUE = "Language";
    String INCIDENT_BANCAIRE_APP = "/incident-bancaire-app";

    // ====== ENDPOINT EXISTANT (inchang√©) ======
    @Operation(
        summary = "Restitue les incidents d√©clar√©s sur une personne",
        operationId = "searchIncidentUsingPOST",
        description = "Chercher dans FICP/BCI (GOAL) + FICP/FCC (BDF) si un client est fich√©"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Succes",
            content = @Content(mediaType = "application/json",
            schema = @Schema(implementation = IncidentsCharacteristics.class))),
        @ApiResponse(responseCode = "401", description = "Unauthorized",
            content = @Content(mediaType = "application/json",
            schema = @Schema(implementation = ErrorModel.class))),
        @ApiResponse(responseCode = "400", description = "Bad Request",
            content = @Content(mediaType = "application/json",
            schema = @Schema(implementation = ErrorModel.class))),
        @ApiResponse(responseCode = "404", description = "Not found, no person available.",
            content = @Content(mediaType = "application/json",
            schema = @Schema(implementation = ErrorModel.class))),
        @ApiResponse(responseCode = "500", description = "Internal server error.",
            content = @Content(mediaType = "application/json",
            schema = @Schema(implementation = ErrorModel.class)))
    })
    @RequestMapping(
        value = INCIDENT_BANCAIRE_APP + "/banking-incidents",
        produces = APPLICATION_JSON_UTF8_VALUE,
        consumes = { "application/json" },
        method = RequestMethod.POST)
    ResponseEntity searchIncident(
        @Parameter(ref = "#/components/parameters/" + X_B3_TRACE_ID)
        @RequestHeader(name = X_B3_TRACE_ID, required = true) final String x_b3_trace_id,

        @Parameter(ref = "#/components/parameters/" + X_B3_SPAN_ID)
        @RequestHeader(value = X_B3_SPAN_ID, required = true) final String x_b3_span_id,

        @Parameter(ref = "#/components/parameters/" + CHANNEL)
        @RequestHeader(name = CHANNEL, required = true) final String channel,

        @Parameter(ref = "#/components/parameters/" + MEDIA)
        @RequestHeader(value = MEDIA, required = false) final String media,

        @Parameter(ref = "#/components/parameters/" + USER_ID)
        @RequestHeader(value = USER_ID, required = false) final String userId,

        @Parameter(description = "Appelant", required = true)
        @RequestHeader(value = "Caller", required = true) final String caller,

        @Parameter(name = "incidentsSearchRequest",
            description = "Crit√®res de recherche incidents",
            required = true)
        @Size(min = 1, max = 10) @Valid
        @RequestBody final List<PersonSearchRequest> incidentsSearchRequest) throws Exception;

    // ====== ENDPOINT AJOUT√â (orchestrated) ‚Äî ADDITIF ======
    @Operation(
        summary = "Recherche orchestr√©e (appels unitaires FCC/FICP/BCI)",
        operationId = "searchIncidentOrchestratedUsingPOST",
        description = "Appelle s√©par√©ment FCC, FICP, BCI selon RequestTypeEnum, sans changer l‚Äôexistant."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Succes",
            content = @Content(mediaType = "application/json",
            schema = @Schema(implementation = IncidentsCharacteristics.class))),
        @ApiResponse(responseCode = "400", description = "Bad Request",
            content = @Content(mediaType = "application/json",
            schema = @Schema(implementation = ErrorModel.class))),
        @ApiResponse(responseCode = "500", description = "Internal server error",
            content = @Content(mediaType = "application/json",
            schema = @Schema(implementation = ErrorModel.class)))
    })
    @RequestMapping(
        value = INCIDENT_BANCAIRE_APP + "/orchestrated/banking-incidents",
        produces = APPLICATION_JSON_UTF8_VALUE,
        consumes = { "application/json" },
        method = RequestMethod.POST)
    ResponseEntity searchIncidentOrchestrated(
        @RequestHeader(name = X_B3_TRACE_ID, required = true) final String x_b3_trace_id,
        @RequestHeader(name = X_B3_SPAN_ID, required = true) final String x_b3_span_id,
        @RequestHeader(name = CHANNEL, required = true) final String channel,
        @RequestHeader(name = MEDIA, required = false) final String media,
        @RequestHeader(name = USER_ID, required = false) final String userId,
        @RequestHeader(name = "Caller", required = true) final String caller,
        @Size(min = 1, max = 10) @Valid @RequestBody final List<PersonSearchRequest> incidentsSearchRequest
    ) throws Exception;
}

> L‚Äôinterface ci-dessus reprend ton existant (m√™mes constantes, m√™me endpoint), et ajoute une route ‚Äúorchestrated‚Äù sans toucher au chemin original. 




---

Bloc 2 ‚Äî Controller (impl du nouvel endpoint, sans modifier l‚Äôexistant)

üìÑ Fichier : exposition/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/exposition/api/BankingIncidentsApiController.java

‚û°Ô∏è On garde ton contr√¥leur tel quel pour searchIncident(...).
‚û°Ô∏è On ajoute la m√©thode searchIncidentOrchestrated(...) (qui d√©l√®gue au m√™me service orchestrateur).
‚û°Ô∏è Les handlers d‚Äôexceptions existants sont conserv√©s.

package com.bnpparibas.dsibddf.ap10530.incident.exposition.api;

import java.util.List;
import javax.servlet.http.HttpServletRequest;

import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.ConstraintViolationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import com.bnpparibas.dsibddf.ap10530.incident.application.IncidentService;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.ApiException;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentsCharacteristics;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.exposition.model.ErrorModel;

import static com.bnpparibas.dsibddf.ap10530.incident.exposition.api.BankingIncidentsApi.*;

@Tag(name = "banking-incidents", description = "the banking-incidents API")
@Validated
@RestController
@RequestMapping(VERSION)
public class BankingIncidentsApiController implements BankingIncidentsApi {

    private static final String TECHNICAL_ERROR_CODE = "4";
    private static final String FUNCTIONAL_ERROR_CODE = "8";
    private static final String INVALID_REQUEST_ERROR_CODE = "400";
    private static final String INVALID_REQUEST_ERROR_MESSAGE = "Bad Request";
    private static final String NO_PERSON_ERROR_CODE = "200";
    private static final String NO_PERSON_ERROR_MESSAGE = "Not found, no person available.";
    private static final String INTERNAL_ERROR_CODE = "500";
    private static final String INTERNAL_ERROR_MESSAGE = "Internal server error";

    private static final Logger LOGGER = LoggerFactory.getLogger(BankingIncidentsApiController.class);

    @Autowired
    private IncidentService incidentService;

    public BankingIncidentsApiController() {
        super();
    }

    public IncidentService getIncidentService() {
        return incidentService;
    }

    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ExceptionHandler(ApiException.class)
    @ResponseBody
    public ErrorModel handleApiException(final HttpServletRequest req, final Exception ex) {
        LOGGER.error("passage handleApiException", ex);
        return new ErrorModel(INTERNAL_ERROR_CODE, INTERNAL_ERROR_MESSAGE + " : " + ex.getMessage());
    }

    @ResponseStatus(HttpStatus.BAD_REQUEST)
    @ExceptionHandler(ConstraintViolationException.class)
    @ResponseBody
    public ErrorModel handleBadRequest(final HttpServletRequest req, final Exception ex) {
        final StringBuilder messages = new StringBuilder();
        for (final ConstraintViolation<?> violation : ((ConstraintViolationException) ex).getConstraintViolations()) {
            final String property = violation.getPropertyPath().toString().replaceAll(".arg0", "");
            final String message = violation.getMessage();
            messages.append(String.format("%s %s", property, message)).append("\n");
        }
        LOGGER.info("passage handleBadRequest");
        LOGGER.info("Invalid request parameters [{}]", messages.toString());
        return new ErrorModel(INVALID_REQUEST_ERROR_CODE, INVALID_REQUEST_ERROR_MESSAGE + " : " + messages);
    }

    // ====== ENDPOINT EXISTANT (inchang√©) ======
    @Override
    public ResponseEntity searchIncident(
            final String x_b3_trace_id,
            final String x_b3_span_id,
            final String channel,
            final String media,
            final String userId,
            final String caller,
            final List<PersonSearchRequest> incidentsSearchRequest) throws Exception {

        final List<IncidentsCharacteristics> list =
                incidentService.searchIncident(incidentsSearchRequest, channel, caller, userId);
        LOGGER.info("Caller={}, TraceId={}, SpanId={}", caller, x_b3_trace_id, x_b3_span_id);
        return new ResponseEntity(list, HttpStatus.OK);
    }

    // ====== ENDPOINT AJOUT√â (orchestrated) ‚Äî ADDITIF ======
    @Override
    public ResponseEntity searchIncidentOrchestrated(
            final String x_b3_trace_id,
            final String x_b3_span_id,
            final String channel,
            final String media,
            final String userId,
            final String caller,
            final List<PersonSearchRequest> incidentsSearchRequest) throws Exception {

        // On d√©l√®gue au m√™me service : le routage unitaire est d√©j√† g√©r√© par RequestTypeEnum c√¥t√© service.
        final List<IncidentsCharacteristics> list =
                incidentService.searchIncident(incidentsSearchRequest, channel, caller, userId);
        LOGGER.info("[ORCHESTRATED] Caller={}, TraceId={}, SpanId={}", caller, x_b3_trace_id, x_b3_span_id);
        return new ResponseEntity(list, HttpStatus.OK);
    }

    public void setIncidentService(final IncidentService incidentService) {
        this.incidentService = incidentService;
    }

    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    @ExceptionHandler(value = { Exception.class })
    @ResponseBody
    public ErrorModel unknownException(final HttpServletRequest req, final Exception ex) {
        LOGGER.error("passage unknownException", ex);
        return new ErrorModel(INTERNAL_ERROR_CODE, INTERNAL_ERROR_MESSAGE + " : " + ex.getMessage());
    }
}

> Le contr√¥leur reprend exactement tes handlers et la m√©thode principale, et ajoute la nouvelle route orchestr√©e. Rien n‚Äôest supprim√© ni renomm√©. 




---

Bloc 3 ‚Äî (Optionnel) Annotation de route exacte sur l‚Äôexistant

Dans ton interface initiale, le @RequestMapping pointait sur "/banking-incidents" sans pr√©fixer par INCIDENT_BANCAIRE_APP. J‚Äôaligne proprement sur INCIDENT_BANCAIRE_APP + "/banking-incidents" pour √™tre coh√©rent avec ton INCIDENT_BANCAIRE_APP (si d√©j√† ainsi dans ton projet, garde tel quel). L‚Äôajout du nouvel endpoint est sur INCIDENT_BANCAIRE_APP + "/orchestrated/banking-incidents" pour ne rien casser. 


---

Bloc 4 ‚Äî (Optionnel) Tests du contr√¥leur (smoke)

üìÑ Fichier : exposition/src/test/java/com/bnpparibas/dsibddf/ap10530/incident/exposition/api/BankingIncidentsApiControllerTest.java
‚û°Ô∏è Test rapide avec mock d‚ÄôIncidentService.

package com.bnpparibas.dsibddf.ap10530.incident.exposition.api;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;

import static org.mockito.Mockito.*;
import static org.assertj.core.api.Assertions.*;

import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.http.ResponseEntity;

import java.util.Collections;
import java.util.List;

import com.bnpparibas.dsibddf.ap10530.incident.application.IncidentService;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentsCharacteristics;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;

@RunWith(MockitoJUnitRunner.class)
public class BankingIncidentsApiControllerTest {

    @Mock private IncidentService incidentService;
    @InjectMocks private BankingIncidentsApiController controller;

    @Test
    public void searchIncident_ok() throws Exception {
        when(incidentService.searchIncident(anyList(), anyString(), anyString(), anyString()))
                .thenReturn(Collections.singletonList(new IncidentsCharacteristics()));

        ResponseEntity res = controller.searchIncident("t","s","ch","m","u","c",
                Collections.singletonList(new PersonSearchRequest()));
        assertThat(res.getStatusCodeValue()).isEqualTo(200);
    }

    @Test
    public void searchIncidentOrchestrated_ok() throws Exception {
        when(incidentService.searchIncident(anyList(), anyString(), anyString(), anyString()))
                .thenReturn(Collections.emptyList());

        ResponseEntity res = controller.searchIncidentOrchestrated("t","s","ch","m","u","c",
                Collections.singletonList(new PersonSearchRequest()));
        assertThat(res.getStatusCodeValue()).isEqualTo(200);
    }
}


---

Bloc 5 ‚Äî Rappel mappers (pas de changement obligatoire)

Ton BciFicpRequestMapper est d√©j√† complet et coh√©rent avec PersonSearchRequest/ZCON_*. Rien √† modifier pour exposer les deux endpoints puisque l‚Äôorchestration est g√©r√©e dans IncidentService (cf. bloc pr√©c√©dent que je t‚Äôai d√©j√† donn√©). 


---

Ce que tu peux faire maintenant

1. Copie/colle les Blocs 1 & 2 (les deux classes) ‚Äî c‚Äôest additif et r√©tro-compatible.


2. Build : mvn -q -DskipTests clean install


3. Appelle :

Existant : POST /v1/incident-bancaire-app/banking-incidents

Orchestrated (ajout) : POST /v1/incident-bancaire-app/orchestrated/banking-incidents
avec un List<PersonSearchRequest> (1..10 √©l√©ments).




Besoin que je te pr√©pare un patch Git (.patch) pr√™t √† appliquer ?

