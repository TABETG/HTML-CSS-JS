package com.bnpparibas.dsibddf.ap00420.streamfact.batch.dailymeteorintegration.tasklet;

import com.bnpparibas.dsibddf.ap00420.streamfact.batch.dailymeteorintegration.manager.FileManager;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.dailymeteorintegration.model.MeteorFile;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.ContractTypeEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.meteorflux.model.MeteorFlux;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.meteorflux.repository.MeteorFluxRepository;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.repeat.RepeatStatus;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.util.Collections;
import java.util.List;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class LoadDailyMeteorFileTaskletTest {

    @Mock
    private MeteorFluxRepository meteorFluxRepository;

    @Mock
    private FileManager fileManager;

    @Mock
    private StepContribution stepContribution;

    @Mock
    private ChunkContext chunkContext;

    @InjectMocks
    private LoadDailyMeteorFileTasklet tasklet;

    private File validFile;
    private File invalidFile;

    @Before
    public void setUp() throws Exception {
        // Fichier valide (au moins une ligne "02" avec champs minimaux utilisés par la classe)
        validFile = File.createTempFile("meteor_valid", ".txt");
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(validFile))) {
            StringBuilder sb = new StringBuilder();
            sb.append("02");                                              // code
            sb.append(String.format("%-23s", "12345678901234567890123")); // loanAccountNumber
            sb.append(String.format("%65s", " "));                        // padding
            sb.append("001");                                             // idProt
            sb.append("0000000000000010");                                // personalContributionAmount
            sb.append("0000000000000020");                                // purchaseAmount
            sb.append("0000000000000030");                                // renovationAmount
            sb.append(String.format("%48s", " "));                        // padding jusqu'à landAmount
            sb.append("0000000000000040");                                // landAmount
            sb.append(String.format("%370s", " "));                       // padding
            sb.append(String.format("%-23s", "loanFolderTest"));          // loanFolderId
            writer.write(sb.toString());
            writer.newLine();
        }

        // Fichier invalide (ligne trop courte)
        invalidFile = File.createTempFile("meteor_invalid", ".txt");
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(invalidFile))) {
            writer.write("invalid_line");
            writer.newLine();
        }
    }

    @Test
    public void execute_should_handle_no_files() throws Exception {
        when(fileManager.getFiles()).thenReturn(Collections.emptyList());

        RepeatStatus status = tasklet.execute(stepContribution, chunkContext);

        assertEquals(RepeatStatus.FINISHED, status);
        verify(fileManager, times(1)).getFiles();
        verifyNoInteractions(meteorFluxRepository);
    }

    @Test
    public void execute_should_process_valid_file_and_archive() throws Exception {
        MeteorFile meteorFile = new MeteorFile(validFile, validFile.getName());
        when(fileManager.getFiles()).thenReturn(Collections.singletonList(meteorFile));
        when(meteorFluxRepository.existsByLoanAccountNumber(anyString())).thenReturn(false);
        when(meteorFluxRepository.saveAll(anyList())).thenReturn(Collections.emptyList());
        doNothing().when(fileManager).archiveFile(any(MeteorFile.class));

        RepeatStatus status = tasklet.execute(stepContribution, chunkContext);

        assertEquals(RepeatStatus.FINISHED, status);
        verify(meteorFluxRepository, atLeastOnce()).saveAll(anyList());
        verify(fileManager, times(1)).archiveFile(meteorFile);
    }

    @Test
    public void execute_should_handle_extract_result_when_invalid_line() throws Exception {
        MeteorFile meteorFile = new MeteorFile(invalidFile, invalidFile.getName());
        when(fileManager.getFiles()).thenReturn(Collections.singletonList(meteorFile));

        RepeatStatus status = tasklet.execute(stepContribution, chunkContext);

        assertEquals(RepeatStatus.FINISHED, status);
        // Pas de throw, le flux est géré et le step se termine
    }

    @Test
    public void extractMeteorFileData_should_return_true_and_save() throws Exception {
        when(meteorFluxRepository.existsByLoanAccountNumber(anyString())).thenReturn(false);
        when(meteorFluxRepository.saveAll(anyList())).thenReturn(Collections.emptyList());

        boolean result = invokeExtract(tasklet, validFile);

        assertTrue(result);
        verify(meteorFluxRepository, atLeastOnce()).saveAll(anyList());
    }

    @Test
    public void extractMeteorFileData_with_invalid_line_should_still_return_true_without_exception() throws Exception {
        // Selon le comportement observé en exécution, l’extraction avec ligne invalide ne jette pas et retourne true
        boolean result = invokeExtract(tasklet, invalidFile);
        assertTrue(result);
    }

    @Test
    public void convertIdProtToContractType_should_cover_all_branches() throws Exception {
        String pri = invokeConvert("001");
        String pro = invokeConvert("003");
        String none = invokeConvert("999");
        assertEquals(ContractTypeEnum.PRI.getCode(), pri);
        assertEquals(ContractTypeEnum.PRO.getCode(), pro);
        assertEquals("", none);
    }

    @Test
    public void valueIsEmptyOrNull_should_cover_true_and_false() {
        assertTrue(LoadDailyMeteorFileTasklet.valueIsEmptyOrNull(null));
        assertTrue(LoadDailyMeteorFileTasklet.valueIsEmptyOrNull(""));
        assertFalse(LoadDailyMeteorFileTasklet.valueIsEmptyOrNull("x"));
    }

    // --- utilitaires réflexion ---

    private boolean invokeExtract(LoadDailyMeteorFileTasklet instance, File file) throws Exception {
        java.lang.reflect.Method m = LoadDailyMeteorFileTasklet.class
                .getDeclaredMethod("extractMeteorFileData", File.class);
        m.setAccessible(true);
        return (boolean) m.invoke(instance, file);
    }

    private String invokeConvert(String idProt) throws Exception {
        java.lang.reflect.Method m = LoadDailyMeteorFileTasklet.class
                .getDeclaredMethod("convertIdProtToContractType", String.class);
        m.setAccessible(true);
        return (String) m.invoke(null, idProt);
    }
}