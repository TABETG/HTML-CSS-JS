package com.bnpparibas.dsibddf.ap00420.streamfact.batch.maestrostatuspaymentrequest.writer;

import com.bnpparibas.dsibddf.ap00420.streamfact.application.cos.CosService;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.maestrostatuspaymentrequest.dto.PaymentRequestInfosForDocaposte;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.repository.docaposte.DocaposteRepository;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.repository.docaposte.model.DocaposteResponse;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.MaestroPaymentRequestEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.PaymentRequestEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.history.model.DocaposteEventHistoryEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.history.repository.DocaposteEventHistoryJpaRepository;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.item.Chunk;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.File;
import java.nio.file.Files;
import java.util.Collections;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

/**
 * Tests JUnit 4 pour PrepareAndSendDocaposteNotifWriter.
 *
 * Couverture :
 *  - write() succès : envoi Docaposte, génération CSV, push COS.
 *  - write() erreur : exception Docaposte, génération CSV quand même, push COS.
 *
 * Contraintes :
 *  - JUnit 4 uniquement, MockitoJUnitRunner, pas d'AssertJ/Jupiter.
 */
@RunWith(MockitoJUnitRunner.class)
public class PrepareAndSendDocaposteNotifWriterTest {

    /** SUT instancié manuellement. */
    private PrepareAndSendDocaposteNotifWriter writer;

    /** Dépendances mockées. */
    @Mock private DocaposteRepository docaposteRepository;
    @Mock private DocaposteEventHistoryJpaRepository docaposteEventHistoryJpaRepository;
    @Mock private CosService cosService;

    /** Données d’entrée et entités liées. */
    @Mock private PaymentRequestInfosForDocaposte info;
    @Mock private PaymentRequestEntity paymentRequestEntity;
    @Mock private MaestroPaymentRequestEntity maestroPaymentRequestEntity;
    @Mock private DocaposteEventHistoryEntity docaposteEventHistoryEntity;

    /** Répertoire temporaire utilisé pour le rapport. */
    private File tempDir;

    @Before
    public void setUp() throws Exception {
        writer = new PrepareAndSendDocaposteNotifWriter();

        // Répertoire temporaire pour la génération du CSV
        tempDir = Files.createTempDirectory("docaposte-test-").toFile();
        assertTrue(tempDir.isDirectory());

        // Injection des champs @Value / @Autowired
        ReflectionTestUtils.setField(writer, "serialNumber", "SERIAL-001");
        ReflectionTestUtils.setField(writer, "docaposteRepository", docaposteRepository);
        ReflectionTestUtils.setField(writer, "docaposteEventHistoryJpaRepository", docaposteEventHistoryJpaRepository);
        ReflectionTestUtils.setField(writer, "cosService", cosService);
        ReflectionTestUtils.setField(writer, "pathGenerateFile", tempDir.getAbsolutePath() + File.separator);
        ReflectionTestUtils.setField(writer, "fileName", "StreamfactMaestroPaymentRequestsReport.%s.csv");
        ReflectionTestUtils.setField(writer, "prefix", "cos/prefix");

        // Stubs de l'item fourni au writer
        when(info.getDocaposteEventHistory()).thenReturn(docaposteEventHistoryEntity);
        when(info.getPaymentRequest()).thenReturn(paymentRequestEntity);

        // IMPORTANT : le MaestroPaymentRequestEntity (mpr) vient de "info", pas de PaymentRequestEntity
        when(info.getMaestroPaymentRequest()).thenReturn(maestroPaymentRequestEntity);
        // Si ta méthode s'appelle getMaestroPaymentRequestEntity(), remplace la ligne ci-dessus par :
        // when(info.getMaestroPaymentRequestEntity()).thenReturn(maestroPaymentRequestEntity);

        // Champs utilisés dans createReport(...)
        when(maestroPaymentRequestEntity.getNumCptCont()).thenReturn("CPT-001");

        // Identifiants de la demande (utiles pour le rapport)
        when(paymentRequestEntity.getPaymentRequestId()).thenReturn("PR-1");
        when(paymentRequestEntity.getIdDn()).thenReturn("DN-1");

        // La sauvegarde renvoie l’entité fournie
        when(docaposteEventHistoryJpaRepository.save(any(DocaposteEventHistoryEntity.class)))
                .thenAnswer(inv -> inv.getArgument(0));
    }

    /**
     * Chemin succès :
     *  - Docaposte renvoie une liste non vide,
     *  - Historique mis à jour, CSV généré, et push COS déclenché.
     */
    @Test
    public void write_should_send_to_docaposte_and_push_report_to_cos_on_success() throws Exception {
        DocaposteResponse response = mock(DocaposteResponse.class);
        when(response.getGroupId()).thenReturn("G-12345");
        when(docaposteRepository.sendDossierBox(anyList()))
                .thenReturn(Collections.singletonList(response));

        Chunk<PaymentRequestInfosForDocaposte> chunk = new Chunk<>(Collections.singletonList(info));

        writer.write(chunk);

        verify(docaposteRepository, times(1)).sendDossierBox(anyList());
        verify(docaposteEventHistoryJpaRepository, atLeastOnce()).save(any(DocaposteEventHistoryEntity.class));

        ArgumentCaptor<String> fileNameCaptor = ArgumentCaptor.forClass(String.class);
        verify(cosService, times(1))
                .pushArchiveFileToCOS(eq("cos/prefix"), fileNameCaptor.capture(), isNull());

        String producedFileName = fileNameCaptor.getValue();
        assertNotNull(producedFileName);
        File generated = new File(tempDir, producedFileName);
        assertTrue("Le rapport CSV doit exister", generated.exists());
        assertTrue("Le rapport CSV doit être un fichier", generated.isFile());
    }

    /**
     * Chemin erreur :
     *  - Docaposte lève une exception,
     *  - Le writer persiste l’historique, génère tout de même le CSV et appelle le push COS.
     */
    @Test
    public void write_should_handle_exception_from_docaposte_and_still_generate_and_push_report() throws Exception {
        when(docaposteRepository.sendDossierBox(anyList()))
                .thenThrow(new RuntimeException("Docaposte indisponible"));

        Chunk<PaymentRequestInfosForDocaposte> chunk = new Chunk<>(Collections.singletonList(info));

        writer.write(chunk);

        verify(docaposteEventHistoryJpaRepository, atLeastOnce()).save(any(DocaposteEventHistoryEntity.class));

        ArgumentCaptor<String> fileNameCaptor = ArgumentCaptor.forClass(String.class);
        verify(cosService, times(1))
                .pushArchiveFileToCOS(eq("cos/prefix"), fileNameCaptor.capture(), isNull());

        String producedFileName = fileNameCaptor.getValue();
        assertNotNull(producedFileName);
        assertTrue(new File(tempDir, producedFileName).exists());
    }
}