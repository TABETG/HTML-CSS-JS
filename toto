Tu as raison : l’erreur vient du fait que BciFicpRequestMapper n’expose pas map(...).
Dans le code source, ce mapper offre deux méthodes : createBciFicpRequest(...) et createBciFicpRequestRP(...) — pas map. C’est bien visible dans la classe du mapper, sous domain/mappers/BciFicpRequestMapper.java. 
Le log de build le confirme : l’appel à bciFicpMapper.map(...) échoue à la ligne 422 d’IncidentService.java. 

Voici donc les corrections complètes, bloc par bloc, prêtes à coller.


---

1) Bloc « BCI/FICP – mode RP » dans IncidentService.searchIncident(...)

Avant (appel erroné, schéma)

// ...
resultWrapper = bciFicpService.postRP(
    bciFicpMapper.map(incidentsSearchRequest.subList(0, 5), channel, caller, userId),
    incidentsSearchRequest.subList(0, 5)
);
// ...
resultWrapperSecond = bciFicpService.postRP(
    bciFicpMapper.map(incidentsSearchRequest.subList(5, incidentsSearchRequest.size()), channel, caller, userId),
    incidentsSearchRequest.subList(5, incidentsSearchRequest.size())
);

Après (correct, utilise createBciFicpRequestRP)

// Split si > 5, puis 2 appels RP
IncidentBciFicpResult resultWrapper =
        bciFicpService.postRP(
            bciFicpMapper.createBciFicpRequestRP(incidentsSearchRequest.subList(0, 5)),
            incidentsSearchRequest.subList(0, 5)
        );

IncidentBciFicpResult resultWrapperSecond =
        bciFicpService.postRP(
            bciFicpMapper.createBciFicpRequestRP(incidentsSearchRequest.subList(5, incidentsSearchRequest.size())),
            incidentsSearchRequest.subList(5, incidentsSearchRequest.size())
        );

// agrégation des listes retournées
resultWrapper.getIncidentListBCI().addAll(resultWrapperSecond.getIncidentListBCI());
resultWrapper.getIncidentListFCIPBNPP().addAll(resultWrapperSecond.getIncidentListFCIPBNPP());
resultWrapper.getIncidentListRPBNPP().addAll(resultWrapperSecond.getIncidentListRPBNPP());

// log + push dans resultList comme dans le code existant
LOGGER.debug("{} incident(s) found in BCI database by RP", resultWrapper.getIncidentListBCI().size());
resultList.add(new IncidentsCharacteristics(resultWrapper.getIncidentListBCI(), OriginEnum.BCI));

LOGGER.debug("{} incident(s) found in FICP BNPP database by RP", resultWrapper.getIncidentListFCIPBNPP().size());
resultList.add(new IncidentsCharacteristics(resultWrapper.getIncidentListFCIPBNPP(), OriginEnum.FICP_BNPP));

// Remontée des infos ‘RP BNPP’ dans la requête (inchangé, on recopie les champs)
List<Personne> incidentListRPBNPP = resultWrapper.getIncidentListRPBNPP();
for (int i = 0; i < incidentListRPBNPP.size(); i++) {
    incidentListRPBNPP.get(i).setConservPreuve(incidentsSearchRequest.get(i).getConservPreuve());
    incidentListRPBNPP.get(i).setStatutPreuve(incidentsSearchRequest.get(i).getStatutPreuve());
    incidentListRPBNPP.get(i).setNbCptesDossier(incidentsSearchRequest.get(i).getNbCptesDossier());
    incidentListRPBNPP.get(i).setDureeContrat(incidentsSearchRequest.get(i).getDureeContrat());
    incidentListRPBNPP.get(i).setDateDebutCredit(incidentsSearchRequest.get(i).getDateDebutCredit());
    incidentListRPBNPP.get(i).setAppEmettrice(incidentsSearchRequest.get(i).getAppEmettrice());
    incidentListRPBNPP.get(i).setRefExterne(incidentsSearchRequest.get(i).getRefExterne());
    incidentListRPBNPP.get(i).setPersonId(incidentsSearchRequest.get(i).getPersonId());
    incidentListRPBNPP.get(i).setNbPersFicp(incidentsSearchRequest.get(i).getNbPersFicp());
    incidentListRPBNPP.get(i).setRibEtTypedeCompte(incidentsSearchRequest.get(i).getRibEtTypedeCompte());
}
incidentsSearchRequest.clear();
incidentsSearchRequest.addAll(incidentListRPBNPP);

> Ce bloc correspond exactement à ce qui est attendu (appel à postRP + mapping RP) et figure déjà dans les extraits valides du PDF. 




---

2) Bloc « BCI/FICP – mode standard (non-RP) » dans IncidentService.searchIncident(...)

Avant (appel erroné, schéma)

// ...
IncidentBciFicpResult resultWrapper =
    bciFicpService.post(
        bciFicpMapper.map(incidentsSearchRequest, channel, caller, userId)
    );
// exploitation de resultWrapper...

Après (correct, utilise createBciFicpRequest)

// Calcul des clés BDF côté service (inchangé)
generateBDFKeyList(incidentsSearchRequest);

// Construction de la requête Z/OS + appel standard (non-RP)
IncidentBciFicpResult resultWrapper =
    bciFicpService.post(
        bciFicpMapper.createBciFicpRequest(incidentsSearchRequest)
    );

// Alimentation du résultat agrégé
LOGGER.debug("{} incident(s) found in BCI database", resultWrapper.getIncidentListBCI().size());
resultList.add(new IncidentsCharacteristics(resultWrapper.getIncidentListBCI(), OriginEnum.BCI));

LOGGER.debug("{} incident(s) found in FICP BNPP database", resultWrapper.getIncidentListFCIPBNPP().size());
resultList.add(new IncidentsCharacteristics(resultWrapper.getIncidentListFCIPBNPP(), OriginEnum.FICP_BNPP));

> createBciFicpRequest(...) est la bonne API du mapper pour le cas standard. Voir la classe du mapper dans domain/mappers/BciFicpRequestMapper.java. 




---

3) Méthode utilitaire « recherche BCI/FICP unitaire » (si tu as un helper dédié)

Si tu as une méthode type searchIncidentBciOnly(...) qui tombait aussi sur map(...), remplace-la entièrement par :

private IncidentBciFicpResult searchIncidentBciOnly(final List<PersonSearchRequest> persons) throws Exception {
    // enrichit les personnes avec la clé BDF attendue côté z/OS
    generateBDFKeyList(persons);

    // mapping correct -> appel standard
    return bciFicpService.post(
        bciFicpMapper.createBciFicpRequest(persons)
    );
}

> Le service BciFicpRestService expose bien post(...) (standard) et postRP(...) (RP) ; le postRP(...) prend en 2e paramètre la sous-liste d’entrée, comme montré dans le code source. 




---

4) Rappels importants

Imports / beans : rien à changer, tu as déjà
private final BciFicpRequestMapper bciFicpMapper = new BciFicpRequestMapper(); et l’injection de BciFicpRestService. 

Nom du champ : attention à ne pas écrire bciFcipMapper (inversion c/ip). Le champ s’appelle bien bciFicpMapper partout. L’erreur actuelle n’est pas le nom du champ, mais la méthode map(...) inexistante (cf. log Maven). 

Pourquoi map(...) n’existe pas : l’API a été renommée/normalisée. Les méthodes dispo sont :

createBciFicpRequest(List<PersonSearchRequest>) (mode standard),

createBciFicpRequestRP(List<PersonSearchRequest>) (mode RP),
comme on le voit dans le code du mapper. 




---

Si tu colles ces blocs (RP + standard + éventuel helper unitaire), la compilation du module application ne plantera plus sur la ligne 422. Le reste de la logique (logs, agrégation des listes, copie des champs RP) reste inchangé et validé par les extraits du projet. 

