package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.create;

import com.bnpparibas.bddf.cqrs.command.v2.CommandExecutorV2;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.billingspace.create.CreateBillingSpaceCommand;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.billingspace.create.CreateBillingSpaceRequest;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.complete.CompleteLoanFoldersCommand;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.complete.CompleteLoanFoldersRequest;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.createeligiblefolders.CreateEligibleLoanFoldersCommand;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.createeligiblefolders.CreateEligibleLoanFoldersRequest;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.billingspace.model.BillingSpace;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.loanfolder.model.LoanFolder;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.repeat.RepeatStatus;

import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.List;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Test JUnit4 100% coverage – CreateBillingSpaceTasklet
 */
@RunWith(MockitoJUnitRunner.class)
public class CreateBillingSpaceTaskletTest {

    @Mock
    private CommandExecutorV2 commandExecutor;

    @Mock
    private StepContribution contribution;

    @Mock
    private ChunkContext chunkContext;

    @InjectMocks
    private CreateBillingSpaceTasklet tasklet;

    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void execute_callsCommandsInOrder_andReturnsFinished() throws Exception {
        // Given
        List<LoanFolder> eligible = Arrays.asList(mock(LoanFolder.class), mock(LoanFolder.class));
        List<LoanFolder> complete = Arrays.asList(mock(LoanFolder.class));
        List<BillingSpace> spaces = Arrays.asList(mock(BillingSpace.class));

        when(commandExecutor.execute(eq(CreateEligibleLoanFoldersCommand.class),
                any(CreateEligibleLoanFoldersRequest.class))).thenReturn(eligible);
        when(commandExecutor.execute(eq(CompleteLoanFoldersCommand.class),
                any(CompleteLoanFoldersRequest.class))).thenReturn(complete);
        when(commandExecutor.execute(eq(CreateBillingSpaceCommand.class),
                any(CreateBillingSpaceRequest.class))).thenReturn(spaces);

        // When
        RepeatStatus status = tasklet.execute(contribution, chunkContext);

        // Then
        assertEquals(RepeatStatus.FINISHED, status);

        InOrder inOrder = inOrder(commandExecutor);
        inOrder.verify(commandExecutor).execute(eq(CreateEligibleLoanFoldersCommand.class),
                any(CreateEligibleLoanFoldersRequest.class));
        inOrder.verify(commandExecutor).execute(eq(CompleteLoanFoldersCommand.class),
                any(CompleteLoanFoldersRequest.class));
        inOrder.verify(commandExecutor).execute(eq(CreateBillingSpaceCommand.class),
                any(CreateBillingSpaceRequest.class));

        // Capture des requêtes pour vérification
        ArgumentCaptor<CreateEligibleLoanFoldersRequest> cap1 =
                ArgumentCaptor.forClass(CreateEligibleLoanFoldersRequest.class);
        ArgumentCaptor<CompleteLoanFoldersRequest> cap2 =
                ArgumentCaptor.forClass(CompleteLoanFoldersRequest.class);
        ArgumentCaptor<CreateBillingSpaceRequest> cap3 =
                ArgumentCaptor.forClass(CreateBillingSpaceRequest.class);

        verify(commandExecutor).execute(eq(CreateEligibleLoanFoldersCommand.class), cap1.capture());
        verify(commandExecutor).execute(eq(CompleteLoanFoldersCommand.class), cap2.capture());
        verify(commandExecutor).execute(eq(CreateBillingSpaceCommand.class), cap3.capture());

        assertNotNull(cap1.getValue());

        Object eligibleLoanFolders = readField(cap2.getValue(), "eligibleLoanFolders");
        assertSame(eligible, eligibleLoanFolders);

        Object eligibleAndComplete = readField(cap3.getValue(), "eligibleAndCompleteloanFolders");
        assertSame(complete, eligibleAndComplete);

        verifyNoMoreInteractions(commandExecutor);
    }

    @Test(expected = RuntimeException.class)
    public void execute_shouldPropagateException_ifCommandExecutorFails() throws Exception {
        when(commandExecutor.execute(eq(CreateEligibleLoanFoldersCommand.class),
                any(CreateEligibleLoanFoldersRequest.class)))
                .thenReturn(Arrays.asList(mock(LoanFolder.class)));

        when(commandExecutor.execute(eq(CompleteLoanFoldersCommand.class),
                any(CompleteLoanFoldersRequest.class)))
                .thenThrow(new RuntimeException("boom"));

        tasklet.execute(contribution, chunkContext);
    }

    // ==== Méthodes utilitaires de réflexion ====
    private static Object readField(Object target, String name) throws Exception {
        Field f = findField(target.getClass(), name);
        assertNotNull("Champ introuvable: " + name, f);
        f.setAccessible(true);
        return f.get(target);
    }

    private static Field findField(Class<?> type, String name) {
        for (Class<?> c = type; c != null; c = c.getSuperclass()) {
            try {
                return c.getDeclaredField(name);
            } catch (NoSuchFieldException ignored) {
            }
        }
        return null;
    }
}