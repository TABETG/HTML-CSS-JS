package com.bnpparibas.dsibddf.ap00420.streamfact.exposition.rest.support;

import com.bnpparibas.bddf.config.SpringProfileConstants;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.core.env.Environment;

import java.lang.reflect.Field;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.mockito.Mockito.when;

/**
 * Tests de couverture 100% pour AbstractSpringBootLauncher.
 * Couvre :
 *  - initApplication() avec profils non conflictuels (branche info)
 *  - initApplication() avec profils MQ + ACTIVEMQ (branche erreur)
 *  - launch(...) avec démarrage "headless" (web-application-type=NONE)
 */
class AbstractSpringBootLauncherTest {

    /** Sous-classe concrète minimale pour tester la classe abstraite. */
    static class TestLauncher extends AbstractSpringBootLauncher { }

    /** Petite application Spring Boot minimale pour tester launch(...). */
    @SpringBootApplication
    static class DummyApp { }

    /** Utilitaire : injecte un mock d'Environment dans l'instance via réflexion. */
    private static void injectEnv(AbstractSpringBootLauncher launcher, Environment env) throws Exception {
        Field f = AbstractSpringBootLauncher.class.getDeclaredField("env");
        f.setAccessible(true);
        f.set(launcher, env);
    }

    @Test
    void initApplication_withNonConflictingProfiles_logsInfoOnly() throws Exception {
        // given
        TestLauncher launcher = new TestLauncher();
        Environment env = Mockito.mock(Environment.class);
        when(env.getActiveProfiles()).thenReturn(new String[] { "dev" }); // aucun conflit
        injectEnv(launcher, env);

        // when / then: on vérifie simplement que tout s'exécute (les logs suffisent pour la couverture)
        launcher.initApplication();
    }

    @Test
    void initApplication_withMqAndActiveMq_logsErrorBranch() throws Exception {
        // given
        TestLauncher launcher = new TestLauncher();
        Environment env = Mockito.mock(Environment.class);
        when(env.getActiveProfiles()).thenReturn(new String[] {
                SpringProfileConstants.SPRING_PROFILE_MQ,
                SpringProfileConstants.SPRING_PROFILE_ACTIVE_MQ
        });
        injectEnv(launcher, env);

        // when / then: exécution de la branche "erreur" (les logs suffisent pour la couverture)
        launcher.initApplication();
    }

    @Test
    void launch_runsHeadlessAndLogsBanner() {
        // given: on passe des args pour éviter tout serveur web et définir des props lues par le code
        String[] args = new String[] {
                "--spring.main.web-application-type=NONE", // pas de serveur web
                "--spring.application.name=test-app",
                "--server.port=0" // valeur lue par le log, pas d'ouverture de port
        };

        // when / then: aucune exception, exécution de toutes les lignes de launch(...)
        assertDoesNotThrow(() ->
                AbstractSpringBootLauncher.launch(DummyApp.class, args)
        );
    }
}