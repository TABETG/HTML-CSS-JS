package com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.tasklet;

import com.bnpparibas.dsibddf.ap00420.streamfact.application.cos.CosService;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.test.util.ReflectionTestUtils;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.mockito.Mockito.*;

/**
 * Tests JUnit 4 pour SendToBMDUploadCOSTasklet.
 *
 * Objectifs:
 *  - Vérifier le comportement "mock": pas d'appel COS, terminaison FINISHED.
 *  - Vérifier le succès en mode réel: appel COS, ExitStatus.COMPLETED.
 *  - Vérifier l'échec en mode réel: exception COS, ExitStatus.FAILED.
 *  - Couvrir afterPropertiesSet() (contrat no-op).
 *
 * Contraintes:
 *  - JUnit 4 uniquement (org.junit.*), pas de JUnit Jupiter.
 *  - MockitoJUnitRunner, pas d'AssertJ.
 *  - verifyNoInteractions(...) pour l'absence d'appels.
 */
@RunWith(MockitoJUnitRunner.class)
public class SendToBMDUploadCOSTaskletTest {

    @InjectMocks
    private SendToBMDUploadCOSTasklet tasklet;

    @Mock
    private CosService cosService;

    private StepExecution stepExecution;
    private StepContribution contribution;

    @Before
    public void setUp() {
        // Construit un contexte Spring Batch réaliste pour vérifier ExitStatus.
        JobExecution jobExecution = new JobExecution(1L);
        stepExecution = new StepExecution("sendToBMDUpload", jobExecution);
        contribution = new StepContribution(stepExecution);
    }

    /**
     * afterPropertiesSet() ne fait rien: aucune exception attendue.
     */
    @Test
    public void afterPropertiesSet_should_do_nothing() throws Exception {
        tasklet.afterPropertiesSet();
    }

    /**
     * Branche mock=true:
     *  - Le service COS ne doit pas être appelé.
     *  - Le step termine en FINISHED (ExitStatus non forcé dans le code).
     */
    @Test
    public void execute_when_mock_true_should_finish_without_cos_call() throws Exception {
        ReflectionTestUtils.setField(tasklet, "mock", true);
        ReflectionTestUtils.setField(tasklet, "pathGenerateFile", "/tmp");
        ReflectionTestUtils.setField(tasklet, "prefix", "arch-");
        putEncryptedFileName("file.enc"); // clé "encryptedFileName" dans JobExecutionContext

        ChunkContext chunkContext = new ChunkContext(new StepContext(stepExecution));

        RepeatStatus status = tasklet.execute(contribution, chunkContext);

        assertEquals(RepeatStatus.FINISHED, status);
        verifyNoInteractions(cosService);
    }

    /**
     * Branche mock=false et envoi OK:
     *  - Appel à cosService.pushArchiveFileToNewCOS(path, file, prefix).
     *  - ExitStatus.COMPLETED posé sur le StepExecution.
     */
    @Test
    public void execute_when_mock_false_and_push_ok_should_set_completed() throws Exception {
        ReflectionTestUtils.setField(tasklet, "mock", false);
        ReflectionTestUtils.setField(tasklet, "pathGenerateFile", "/opt/export");
        ReflectionTestUtils.setField(tasklet, "prefix", "bkp-");
        putEncryptedFileName("daily.enc");

        ChunkContext chunkContext = new ChunkContext(new StepContext(stepExecution));

        RepeatStatus status = tasklet.execute(contribution, chunkContext);

        assertEquals(RepeatStatus.FINISHED, status);
        assertEquals(ExitStatus.COMPLETED, stepExecution.getExitStatus());
        verify(cosService, times(1))
                .pushArchiveFileToNewCOS("/opt/export", "daily.enc", "bkp-");
        verifyNoMoreInteractions(cosService);
    }

    /**
     * Branche mock=false mais le push lève une exception:
     *  - ExitStatus.FAILED posé.
     *  - Le RepeatStatus reste FINISHED (contrat d'un Tasklet).
     */
    @Test
    public void execute_when_mock_false_and_push_throws_should_set_failed() throws Exception {
        ReflectionTestUtils.setField(tasklet, "mock", false);
        ReflectionTestUtils.setField(tasklet, "pathGenerateFile", "/data/out");
        ReflectionTestUtils.setField(tasklet, "prefix", "pref-");
        putEncryptedFileName("broken.enc");

        doThrow(new RuntimeException("cos down"))
                .when(cosService).pushArchiveFileToNewCOS("/data/out", "broken.enc", "pref-");

        ChunkContext chunkContext = new ChunkContext(new StepContext(stepExecution));

        RepeatStatus status = tasklet.execute(contribution, chunkContext);

        assertEquals(RepeatStatus.FINISHED, status);
        assertEquals(ExitStatus.FAILED, stepExecution.getExitStatus());
        verify(cosService, times(1))
                .pushArchiveFileToNewCOS("/data/out", "broken.enc", "pref-");
        verifyNoMoreInteractions(cosService);
    }

    /**
     * Place le nom de fichier attendu dans le JobExecutionContext sous la clé "encryptedFileName".
     * Le tasklet lit explicitement cette clé pour récupérer le nom à envoyer vers COS.
     */
    private void putEncryptedFileName(String fileName) {
        assertNotNull(stepExecution);
        assertNotNull(stepExecution.getJobExecution());
        stepExecution.getJobExecution().getExecutionContext().put("encryptedFileName", fileName);
    }
}