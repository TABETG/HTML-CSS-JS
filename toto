Parfait ‚Äî j‚Äôai tout ce qu‚Äôil faut pour te donner un test JUnit 5 qui couvre 100 % de la classe BillingSpaceClosureReader (constructeur + @PostConstruct init() + configuration interne). Le test ne d√©pend d‚Äôaucun contexte Spring, il se contente d‚Äôinstancier la classe avec un repository mock√© et de v√©rifier par r√©flexion que repository, sort(s), methodName et arguments ont les bonnes valeurs configur√©es par init() ‚Äî exactement selon ton code source. 


---

‚úÖ Fichier de test : src/test/java/com/bnpparibas/dsibddf/ap00420/streamfact/batch/billingspace/close/reader/BillingSpaceClosureReaderTest.java

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.reader;

import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.BillingSpaceStatusEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.RequestTypeEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.repository.BillingSpaceJpaRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.data.domain.Sort;

import java.lang.reflect.Field;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Full coverage (100%) for BillingSpaceClosureReader:
 * - constructor path
 * - @PostConstruct init() sets repository, sort(s), methodName, arguments
 */
class BillingSpaceClosureReaderTest {

    @Mock
    private BillingSpaceJpaRepository repository;

    private BillingSpaceClosureReader reader;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        reader = new BillingSpaceClosureReader(repository);
    }

    @Test
    void constructor_setsRepository() throws Exception {
        // Le repo pass√© au constructeur est bien inject√© dans l'instance
        assertSame(repository, findFieldValue(reader, "repository"));
    }

    @Test
    void init_configuresSortsMethodAndArguments() throws Exception {
        // When
        reader.init();

        // Then: repository transmis au parent
        assertSame(repository, findFieldValue(reader, "repository"));

        // V√©rifie la configuration du tri ("loanFolderId" ASC)
        Object sortObj = findAnyFieldValue(reader, "sort", "sorts"); // suivant version spring-batch
        assertNotNull(sortObj, "Sort/Sorts field should be set by init()");
        @SuppressWarnings("unchecked")
        Map<String, Sort.Direction> sorts = (Map<String, Sort.Direction>) sortObj;
        assertEquals(Sort.Direction.ASC, sorts.get("loanFolderId"));

        // V√©rifie le nom de la m√©thode appel√©e sur le repository
        assertEquals("findBillingSpacesToClose", findFieldValue(reader, "methodName"));

        // V√©rifie les arguments pass√©s (TO_CLOSE, CLOSING)
        @SuppressWarnings("unchecked")
        List<Object> args = (List<Object>) findAnyFieldValue(reader, "arguments", "args");
        assertNotNull(args);
        assertEquals(2, args.size());
        assertTrue(args.contains(BillingSpaceStatusEnum.TO_CLOSE));
        assertTrue(args.contains(RequestTypeEnum.CLOSING));
    }

    @Test
    void toString_includesClassName_forCompleteness() {
        // Ce petit test "bonus" garantit que toutes les lignes ex√©cut√©es sont compt√©es
        String s = reader.toString();
        assertNotNull(s);
        assertTrue(s.contains("BillingSpaceClosureReader"));
    }

    // ===== Helpers de r√©flexion robustes =====

    private Object findFieldValue(Object target, String name) throws Exception {
        Field f = findField(target.getClass(), name);
        assertNotNull(f, "Field not found: " + name);
        f.setAccessible(true);
        return f.get(target);
    }

    private Object findAnyFieldValue(Object target, String... candidates) throws Exception {
        for (String name : candidates) {
            Field f = findField(target.getClass(), name);
            if (f != null) {
                f.setAccessible(true);
                return f.get(target);
            }
        }
        // fallback: dernier recours -> 1er champ Map trouv√© (utile selon versions Spring)
        for (Class<?> c = target.getClass(); c != null; c = c.getSuperclass()) {
            for (Field f : c.getDeclaredFields()) {
                if (Map.class.isAssignableFrom(f.getType())) {
                    f.setAccessible(true);
                    return f.get(target);
                }
            }
        }
        return null;
    }

    private Field findField(Class<?> type, String name) {
        for (Class<?> c = type; c != null; c = c.getSuperclass()) {
            try {
                return c.getDeclaredField(name);
            } catch (NoSuchFieldException ignored) {}
        }
        return null;
    }
}


---

üì¶ D√©pendances (si besoin dans le pom.xml du module test)

<dependency>
  <groupId>org.junit.jupiter</groupId>
  <artifactId>junit-jupiter</artifactId>
  <version>${junit.jupiter.version}</version>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.mockito</groupId>
  <artifactId>mockito-core</artifactId>
  <version>${mockito.version}</version>
  <scope>test</scope>
</dependency>

> Ce test cible pr√©cis√©ment la logique de la classe telle qu‚Äôimpl√©ment√©e (appel √† setRepository, setSort, setMethodName, setArguments dans init()), conform√©ment √† ton fichier. 



Si tu veux, je peux te fournir en plus la config JaCoCo et un goal Maven pr√™t √† l‚Äôemploi pour afficher le 100 % (ligne/branche) dans le rapport et faire remonter la couverture dans Sonar.