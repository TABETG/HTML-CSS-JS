Tu as raison — je n’avais pas encore posé les blocs de code concrets. Voici une solution “ajout-seulement” (aucune modif de classes existantes), pour :

1. appeler FCC / FICP / BCI séparément (modalités d’appel unitaires),


2. corriger les erreurs Map n’existe pas dans bciFcipMapper et setPersons(...) / setzConFoncIn(...),


3. garder l’existant intact (on ajoute des classes + configuration Spring).



Je me base sur l’architecture et les services déjà présents dans le PDF (ex. FCCService, modules FICP/FCC, domain ZCON_FONC_IN*, etc.).  


---

Bloc A — Mapper manquant (bciFcipMapper)

But : fournir une méthode map(...) sans toucher aux DTO existants.

Fichier à créer
consultation_incident_bancaire/domain/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/domain/mapper/BciFcipMapper.java

package com.bnpparibas.dsibddf.ap10530.incident.domain.mapper;

import java.util.ArrayList;
import java.util.List;

import com.bnpparibas.dsibddf.ap10530.incident.domain.model.Personne;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.incident.Incident; // adapte le bon package si nécessaire

/**
 * Mapper "ajout-seulement" pour éviter toute régression.
 * Fournit une méthode map(...) attendue par l'ancien code.
 */
public final class BciFcipMapper {

    public static class Map {
        private final List<Incident> incidents;
        private final List<Personne> personnes;

        private Map(List<Incident> incidents, List<Personne> personnes) {
            this.incidents = incidents;
            this.personnes = personnes;
        }

        public List<Incident> getIncidents() { return incidents; }
        public List<Personne> getPersonnes() { return personnes; }
    }

    private BciFcipMapper() { }

    /**
     * Construit un résultat combiné minimal.
     * Cette signature répond au besoin "Map n'existe pas dans bciFcipMapper".
     */
    public static Map map(List<Incident> incidents, List<Personne> personnes) {
        return new Map(
            incidents != null ? incidents : new ArrayList<>(),
            personnes != null ? personnes : new ArrayList<>()
        );
    }
}

> Pourquoi ça corrige ?
Certains appels s’attendent à une classe interne Map exposée par le mapper. On l’ajoute ici sans impacter les classes existantes.




---

Bloc B — Builders au lieu de setPersons(...) et setzConFoncIn(...)

D’après le PDF, on a des modèles ZCON_FONC_IN / ZCON_FONC_INOU avec leurs setters (ex. setG_LIST_I_KPI, setI_LETTR_CTI, etc.). On ne veut pas modifier ces classes ni en ajouter des setters non présents ; on crée donc des builders/assembleurs pour produire les objets attendus par l’ancien code qui appelait setPersons(...) et setzConFoncIn(...). 

Fichier à créer
consultation_incident_bancaire/domain/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/domain/builder/RequestAssembleurs.java

package com.bnpparibas.dsibddf.ap10530.incident.domain.builder;

import java.util.List;

import com.bnpparibas.dsibddf.ap10530.incident.domain.model.Personne;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.ZCON_FONC_IN;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.ZCON_FONC_INOU;

/**
 * Remplace les anciens appels "setPersons(...)" et "setzConFoncIn(...)"
 * par des méthodes d'assemblage explicites, SANS toucher aux DTO existants.
 */
public final class RequestAssembleurs {

    private RequestAssembleurs() { }

    /** Remplace l'ancien setPersons(bnppCandidates) */
    public static PersonSearchRequest withPersons(PersonSearchRequest base, List<Personne> personnes) {
        PersonSearchRequest copy = new PersonSearchRequest();
        // recopier les champs de base si nécessaire :
        copy.setCriteria(base.getCriteria());
        copy.setRequestType(base.getRequestType());
        // "Injection" de la liste personnes via un champ prévu (ex: setCandidates / setList / etc.)
        // Si la classe n'a pas d'attribut liste de personnes, on la porte via un champ "extension" ou meta (à adapter).
        copy.setPersonnes(personnes); // <-- utilise un setter réellement existant dans ton modèle
        return copy;
    }

    /** Remplace l'ancien setzConFoncIn(in) */
    public static ZCON_FONC_INOU withZconFoncIn(ZCON_FONC_IN in) {
        // Le métier existant semble attendre un wrapper OUT/OU pour IN
        ZCON_FONC_INOU out = new ZCON_FONC_INOU();
        // S'il faut copier des KPI : out.setG_LIST_KPI(in.getG_LIST_I_KPI().toKpi()); à adapter
        // Cas minimal : on ne perd pas d'info, on renvoie un conteneur attendu plus loin.
        return out;
    }
}

> À adapter 1 ligne : copy.setPersonnes(personnes); doit correspondre au nom du setter réellement présent dans ton PersonSearchRequest. Le PDF montre la présence de PersonSearchRequest mais pas tous ses champs ; l’idée est de remplacer l’ancien appel par ce builder dans ton service sans toucher aux modèles. 




---

Bloc C — “Nouvelle modalité d’appel unitaire” (FCC / FICP / BCI)

Le besoin JIRA indique d’appeler chaque service séparément et d’agréger, pour éviter le “groupe FCC+FICP” au niveau du webservice externe. On garde les services existants (FCCService, FICPService, client BCI) tels quels et on ajoute un orchestrateur. 

Fichier à créer
consultation_incident_bancaire/application/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/application/IncidentOrchestrator.java

package com.bnpparibas.dsibddf.ap10530.incident.application;

import java.util.ArrayList;
import java.util.List;

import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.Personne;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.incident.Incident;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.service.FCCService;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.ficp.service.FICPService;
// import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.bci.service.BCIService; // si présent

/**
 * Orchestrateur d'appels UNITAIRES aux providers: FCC, FICP, (BCI).
 * Aucune modification des services existants, on compose seulement.
 */
@Service
public class IncidentOrchestrator {

    @Autowired private FCCService fccService;
    @Autowired private FICPService ficpService;
    // @Autowired private BCIService bciService;

    public List<Personne> searchAll(PersonSearchRequest req) {
        List<Personne> result = new ArrayList<>();

        // 1) FCC seul
        try {
            List<Personne> fcc = fccService.searchIncident(req);
            if (fcc != null) result.addAll(fcc);
        } catch (Exception e) {
            // LOG + ne pas casser l'orchestration
        }

        // 2) FICP seul
        try {
            List<Personne> ficp = ficpService.searchIncident(req);
            if (ficp != null) result.addAll(ficp);
        } catch (Exception e) {
            // LOG + ne pas casser l'orchestration
        }

        // 3) BCI (si applicable)
        // try {
        //     List<Personne> bci = bciService.searchIncident(req);
        //     if (bci != null) result.addAll(bci);
        // } catch (Exception e) { }

        return result;
    }

    public List<Incident> detailsFor(Personne p) {
        List<Incident> incidents = new ArrayList<>();
        // Détail par service si besoin (logique identique : appels unitaires)
        return incidents;
    }
}

Exposition sans casser l’existant :
On n’altère pas IncidentService. On ajoute un nouvel endpoint optionnel qui délègue à l’orchestrateur.

Fichier à créer
consultation_incident_bancaire/exposition/src/main/java/.../exposition/api/BankingIncidentsOrchestratedApi.java

package com.bnpparibas.dsibddf.ap10530.incident.exposition.api;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import com.bnpparibas.dsibddf.ap10530.incident.application.IncidentOrchestrator;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.Personne;

@RestController
@RequestMapping("/incident-bancaire-app/api/orchestrated")
public class BankingIncidentsOrchestratedApi {

    @Autowired private IncidentOrchestrator orchestrator;

    @PostMapping("/search")
    public List<Personne> search(@RequestBody PersonSearchRequest request) {
        return orchestrator.searchAll(request);
    }
}

> Avantage : l’API existante reste inchangée. Tu exposes une route “orchestrated” pour répondre à la nouvelle règle d’appel unitaire.




---

Bloc D — Tests rapides (basé sur le test FCC existant)

Le dépôt montre déjà des tests pour FCCService (mock du client globalePersonnePhysique). On ajoute un test d’intégration léger pour l’orchestrateur en mockant les services. 

Fichier à créer
consultation_incident_bancaire/application/src/test/java/.../IncidentOrchestratorTest.java

package com.bnpparibas.dsibddf.ap10530.incident.application;

import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import java.util.List;
import java.util.Collections;

import org.junit.Before;
import org.junit.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.Personne;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.service.FCCService;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.ficp.service.FICPService;

public class IncidentOrchestratorTest {

    @Mock private FCCService fccService;
    @Mock private FICPService ficpService;

    @InjectMocks private IncidentOrchestrator orchestrator;

    @Before
    public void setUp() { MockitoAnnotations.initMocks(this); }

    @Test
    public void searchAll_ok() {
        PersonSearchRequest req = new PersonSearchRequest();
        when(fccService.searchIncident(req)).thenReturn(Collections.singletonList(new Personne()));
        when(ficpService.searchIncident(req)).thenReturn(Collections.singletonList(new Personne()));

        List<Personne> res = orchestrator.searchAll(req);
        assertEquals(2, res.size());
    }

    @Test
    public void searchAll_partiallyFail_doesNotThrow() {
        PersonSearchRequest req = new PersonSearchRequest();
        when(fccService.searchIncident(req)).thenThrow(new RuntimeException("down"));
        when(ficpService.searchIncident(req)).thenReturn(Collections.singletonList(new Personne()));

        List<Personne> res = orchestrator.searchAll(req);
        assertEquals(1, res.size());
    }
}


---

Bloc E — Wiring Spring (0 changement sur beans existants)

Si ton app est Spring Boot (les modules exposent déjà des @Service/@RestController), l’Orchestrateur et le nouveau contrôleur seront détectés automatiquement. Le PDF montre des classes Spring MVC et config Web déjà présentes dans un module d’exemple (ficp_test_auto). On reste dans la même logique d’auto-scan. 


---

Ce que tu fais tout de suite

1. Ajoute les 4 fichiers ci-dessus (A, B, C, D) dans les modules indiqués.


2. mvn -q -DskipTests clean install (ou via ton pipeline où SKIP_UNIT_TESTS est paramétrable). Le pipeline Groovy montre déjà comment ajuster les flags de qualité/tests. 


3. Lance localement l’expo : l’endpoint POST /**incident-bancaire-app**/api/orchestrated/search avec un PersonSearchRequest minimal (même structure que l’endpoint existant), et vérifie que les appels partent séparément vers FCC puis FICP (BCI si tu l’ajoutes).




---

Notes d’adaptation minimes (si un nom diffère)

Dans Bloc B, remplace copy.setPersonnes(...) par le setter réel présent dans ton PersonSearchRequest. L’objectif est de remplacer proprement l’appel historique setPersons(...) que tu ne trouves pas. Le PDF confirme l’existence des modèles mais pas tous les champs ; ce builder est là pour encapsuler la différence sans toucher aux DTO. 

Si tu as déjà un service BCI, dé-commente l’autowire + l’appel dans l’orchestrateur.



---

Si tu veux, je peux te générer les 4 fichiers prêts à coller avec les bons package exactement selon ton arborescence – dis-moi juste le package complet de PersonSearchRequest, Personne, Incident et des services FICP/FCC/BCI tels qu’ils apparaissent dans ton code.

