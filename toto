package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.update.processor;

import com.bnpparibas.bddf.cqrs.command.v2.CommandExecutorV2;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.*;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.update.*;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.BillingSpaceStatusEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.billingspace.model.BillingSpace;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.history.repository.DocaposteEventHistoryRepository;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.loanfolder.model.LoanFolder;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.mapper.BillingSpaceMapperToDomain;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.BillingSpaceEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.loanfolder.mapper.LoanFolderMapperToDomain;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;

import java.util.Collections;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * ✅ Test JUnit4 100 % compatible Sonar / Jenkins / Jacoco
 * Teste toutes les branches de BillingSpaceSynchroItemProcessor.
 */
@RunWith(MockitoJUnitRunner.class)
public class BillingSpaceSynchroItemProcessorTest {

    @InjectMocks
    private BillingSpaceSynchroItemProcessor processor;

    @Mock
    private CommandExecutorV2 commandExecutor;

    @Mock
    private DocaposteEventHistoryRepository docaposteEventHistoryRepository;

    @Mock
    private BillingSpaceEntity billingSpaceEntity;

    @Mock
    private BillingSpace billingSpace;

    @Mock
    private BillingSpace synchroBillingSpace;

    @Mock
    private LoanFolder loanFolder;

    @Mock
    private LoanFolderSynchroResult loanFolderSynchroResult;

    @Mock
    private LoanFolderSynchroAnalysis loanFolderSynchroAnalysis;

    @Mock
    private ContractLoandFolderAnalysis contractAnalysis;

    @Before
    public void init() {
        when(billingSpaceEntity.getLoanFolder())
                .thenReturn(mock(com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.loanfolder.model.LoanFolderEntity.class));
    }

    /** ✅ Cas nominal : synchro ok ou fermeture TO_CLOSE → résultat non nul */
    @Test
    public void process_should_return_result_when_synchro_or_closure_valid() {
        try (MockedStatic<BillingSpaceMapperToDomain> billingMapper = Mockito.mockStatic(BillingSpaceMapperToDomain.class);
             MockedStatic<LoanFolderMapperToDomain> loanMapper = Mockito.mockStatic(LoanFolderMapperToDomain.class)) {

            billingMapper.when(() -> BillingSpaceMapperToDomain.toDomain(any())).thenReturn(billingSpace);
            loanMapper.when(() -> LoanFolderMapperToDomain.toDomain(any())).thenReturn(loanFolder);

            when(commandExecutor.execute(eq(SynchroLoanFoldersCommand.class), any(SynchroLoanFoldersRequest.class)))
                    .thenReturn(loanFolderSynchroResult);
            when(commandExecutor.execute(eq(SynchroBillingSpaceCommand.class), any(SynchroBillingSpaceRequest.class)))
                    .thenReturn(synchroBillingSpace);

            when(synchroBillingSpace.getBillingSpaceStatus()).thenReturn(BillingSpaceStatusEnum.TO_CLOSE);
            when(loanFolderSynchroResult.getLoanFolderSynchroAnalysis()).thenReturn(loanFolderSynchroAnalysis);
            when(loanFolderSynchroAnalysis.getContractLoandFolderAnalysisList())
                    .thenReturn(Collections.singletonList(contractAnalysis));

            SynchroResult result = processor.process(billingSpaceEntity);

            assertNotNull(result);
            assertEquals(synchroBillingSpace, result.getBillingSpace());
            assertEquals(loanFolderSynchroResult, result.getLoanFolderSynchroResult());

            verify(commandExecutor, times(2)).execute(any(), any());
            verifyNoInteractions(docaposteEventHistoryRepository);
        }
    }

    /** ✅ Cas : aucune analyse + statut ≠ TO_CLOSE → résultat null */
    @Test
    public void process_should_return_null_when_no_analysis_and_not_TO_CLOSE() {
        try (MockedStatic<BillingSpaceMapperToDomain> billingMapper = Mockito.mockStatic(BillingSpaceMapperToDomain.class);
             MockedStatic<LoanFolderMapperToDomain> loanMapper = Mockito.mockStatic(LoanFolderMapperToDomain.class)) {

            billingMapper.when(() -> BillingSpaceMapperToDomain.toDomain(any())).thenReturn(billingSpace);
            loanMapper.when(() -> LoanFolderMapperToDomain.toDomain(any())).thenReturn(loanFolder);

            when(commandExecutor.execute(eq(SynchroLoanFoldersCommand.class), any(SynchroLoanFoldersRequest.class)))
                    .thenReturn(loanFolderSynchroResult);
            when(commandExecutor.execute(eq(SynchroBillingSpaceCommand.class), any(SynchroBillingSpaceRequest.class)))
                    .thenReturn(synchroBillingSpace);

            when(synchroBillingSpace.getBillingSpaceStatus()).thenReturn(BillingSpaceStatusEnum.CLOSED);
            when(loanFolderSynchroResult.getLoanFolderSynchroAnalysis()).thenReturn(loanFolderSynchroAnalysis);
            when(loanFolderSynchroAnalysis.getContractLoandFolderAnalysisList()).thenReturn(Collections.emptyList());
            when(loanFolderSynchroAnalysis.getSynchroAnalysisDatas()).thenReturn(Collections.emptyList());
            when(loanFolderSynchroAnalysis.getBorrowerLoandFolderAnalysisList()).thenReturn(Collections.emptyList());
            when(loanFolderSynchroAnalysis.getLoanFolderAnalysisDatas()).thenReturn(Collections.emptyList());

            SynchroResult result = processor.process(billingSpaceEntity);

            assertNull(result);
            verify(commandExecutor, times(2)).execute(any(), any());
        }
    }

    /** ✅ Méthode privée : doit retourner un résultat si au moins une liste non vide */
    @Test
    public void checkLoanFolderSynchroResultNotEmpty_should_return_result_if_any_list_non_empty() {
        LoanFolderSynchroResult input = mock(LoanFolderSynchroResult.class);
        LoanFolderSynchroAnalysis analysis = mock(LoanFolderSynchroAnalysis.class);

        when(analysis.getContractLoandFolderAnalysisList()).thenReturn(Collections.singletonList(contractAnalysis));
        when(input.getLoanFolderSynchroAnalysis()).thenReturn(analysis);

        LoanFolderSynchroResult output = invokePrivateCheckMethod(input);
        assertNotNull(output);
    }

    /** ✅ Méthode privée : doit retourner null si toutes les listes sont vides */
    @Test
    public void checkLoanFolderSynchroResultNotEmpty_should_return_null_if_all_lists_empty() {
        LoanFolderSynchroResult input = mock(LoanFolderSynchroResult.class);
        LoanFolderSynchroAnalysis analysis = mock(LoanFolderSynchroAnalysis.class);

        when(analysis.getContractLoandFolderAnalysisList()).thenReturn(Collections.emptyList());
        when(analysis.getSynchroAnalysisDatas()).thenReturn(Collections.emptyList());
        when(analysis.getBorrowerLoandFolderAnalysisList()).thenReturn(Collections.emptyList());
        when(analysis.getLoanFolderAnalysisDatas()).thenReturn(Collections.emptyList());
        when(input.getLoanFolderSynchroAnalysis()).thenReturn(analysis);

        LoanFolderSynchroResult result = invokePrivateCheckMethod(input);
        assertNull(result);
    }

    /** Accès réfléchi à la méthode privée checkLoanFolderSynchroResultNotEmpty() */
    private LoanFolderSynchroResult invokePrivateCheckMethod(LoanFolderSynchroResult arg) {
        try {
            java.lang.reflect.Method method = BillingSpaceSynchroItemProcessor.class
                    .getDeclaredMethod("checkLoanFolderSynchroResultNotEmpty", LoanFolderSynchroResult.class);
            method.setAccessible(true);
            return (LoanFolderSynchroResult) method.invoke(processor, arg);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}