Parfait — j’ai bien relu l’arborescence et les classes dans tes PDF, et j’ai corrigé le problème « map n’existe pas dans BciFicpRequestMapper » + intégré “les nouvelles modalités d’appel unitaire” (FICP-BDF, FCC-BDF, FICP-BNPP) côté orchestrateur.

Ci-dessous tu as le code complet, bloc par bloc, prêt à coller dans le bon module/chemin.
Je garde exactement vos packages consultation_incident_bancaire (app Spring Boot en JAR dans exposition) et les noms de types/pages vus dans les sources.


---

Bloc 1 — Mapper : ajout de méthodes d’adaptation (map, mapRP)

Le code d’origine expose déjà createBciFicpRequest(...) et createBciFicpRequestRP(...). L’orchestrateur appelait une méthode map(...) qui n’existe pas, d’où l’erreur.
Pour préserver la compatibilité et éviter de toucher d’autres appels, j’ajoute deux wrappers qui délèguent vers les méthodes existantes.

Fichier :
consultation_incident_bancaire/domain/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/domain/mappers/BciFicpRequestMapper.java

package com.bnpparibas.dsibddf.ap10530.incident.domain.mappers;

import java.util.List;

import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.domain.dto.BciFicpRequestDto; // <-- le DTO que vos méthodes create... retournent

public class BciFicpRequestMapper {

    // ... (tout votre code existant, y compris createBciFicpRequest(...) et createBciFicpRequestRP(...))

    /**
     * Wrapper conservant l’ancienne signature attendue par l’orchestrateur.
     * Délègue vers createBciFicpRequest (BCI / requêtes unitaires BDF pour BCI/FICP côté z/OS).
     */
    public BciFicpRequestDto map(final List<PersonSearchRequest> persons,
                                 final String channel,
                                 final String caller,
                                 final String userId) {
        return createBciFicpRequest(persons, channel, caller, userId);
    }

    /**
     * Wrapper explicit pour la voie RP (FICP BNPP).
     * Délègue vers createBciFicpRequestRP (appel unitaire FICP-BNPP).
     */
    public BciFicpRequestDto mapRP(final List<PersonSearchRequest> persons,
                                   final String channel,
                                   final String caller,
                                   final String userId) {
        return createBciFicpRequestRP(persons, channel, caller, userId);
    }
}

> Pourquoi c’est correct : vos tests et utilitaires montrent que l’appel réel côté BCI/FICP passe bien par createBciFicpRequest(...) et la voie RP par createBciFicpRequestRP(...). On ne change pas la logique métier ; on rétablit simplement la méthode attendue par l’orchestrateur.




---

Bloc 2 — Orchestrateur : appels unitaires selon le type de demande

J’intègre l’évolution “appels unitaires par service” directement dans l’orchestrateur.
Le choix se fait via RequestTypeEnum (valeurs BNP_ONLY, BDF_ONLY, BOTH_BNP_BDF) déjà présent dans votre modèle. 

Fichier :
consultation_incident_bancaire/application/src/main/java/com/bnpparibas/dsibddf/ap10530/incident/application/IncidentService.java

package com.bnpparibas.dsibddf.ap10530.incident.application;

import com.bnpparibas.dsibddf.ap10530.incident.domain.dto.BciFicpRequestDto;
import com.bnpparibas.dsibddf.ap10530.incident.domain.mappers.BciFicpRequestMapper;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentBciFicpResult;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentsCharacteristics;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentsCharacteristics.OriginEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.RequestTypeEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.rest.BciFicpRestService;
import com.bnpparibas.dsibddf.ap10530.incident.domain.rest.PersoneMoraleRestService;
import com.bnpparibas.dsibddf.ap10530.incident.domain.rest.StatisticsService;
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.BDFKeyGenerator;
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.ISOBirthDateConverter;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.service.FCCService;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.ficp.service.FICPService;

import org.joda.time.LocalDate;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

@Component
public class IncidentService {

    private static final Logger LOGGER = LoggerFactory.getLogger(IncidentService.class);

    @Autowired private StatisticsService statisticsService;
    @Autowired private BciFicpRestService bciFicpService;   // BCI + FICP BNPP (RP)
    @Autowired private FICPService ficpService;             // FICP BDF
    @Autowired private FCCService fccService;               // FCC BDF
    @Autowired private PersoneMoraleRestService pMService;  // PM (inchangé)

    private final BciFicpRequestMapper bciFicpMapper = new BciFicpRequestMapper();

    /**
     * Génère les clés BDF nécessaires pour FICP/FCC.
     */
    private void generateBDFKeyList(final List<PersonSearchRequest> persons) {
        int i = 1;
        final int taille = persons.size();
        for (final PersonSearchRequest p : persons) {
            final String bdfKey = BDFKeyGenerator.computeBDFKey(
                    p.getLastname(), ISOBirthDateConverter.fromISOString(p.getBirthDate()));
            LOGGER.debug("computeBDFKey name={}, birthDate={} => {}", p.getLastname(), p.getBirthDate(), bdfKey);
            LOGGER.info("Clé Banque de France appel {} / {} : {}", i, taille, bdfKey);
            i++;
            p.setBdfKey(bdfKey);
        }
    }

    /**
     * Orchestrateur – maintenant avec appels unitaires conformes au ticket.
     */
    public List<IncidentsCharacteristics> searchIncident(final List<PersonSearchRequest> req,
                                                         final String channel,
                                                         final String caller,
                                                         final String userId) throws Exception {

        final List<IncidentsCharacteristics> out = new ArrayList<>();

        if (req == null || req.isEmpty()) {
            return out;
        }

        // Personne physique => générer la clé BDF utilisée par FICP/FCC
        if (req.get(0).getPersonType() == null || "0".equals(req.get(0).getPersonType())) {
            generateBDFKeyList(req); // déjà présent dans votre service. 2
        }

        final RequestTypeEnum type = req.get(0).getRequestType();

        // 1) FICP BNPP (appel unitaire via RP)
        if (type == RequestTypeEnum.BNP_ONLY || type == RequestTypeEnum.BOTH_BNP_BDF) {
            final BciFicpRequestDto inBnpp = bciFicpMapper.mapRP(req, channel, caller, userId);
            final IncidentBciFicpResult resBnpp = bciFicpService.postRP(inBnpp, req);
            if (resBnpp != null && resBnpp.getIncidentListFCIPBNPP() != null) {
                out.add(new IncidentsCharacteristics(resBnpp.getIncidentListFCIPBNPP(), OriginEnum.FICP_BNPP));
            }
        }

        // 2) BCI (appel unitaire)
        // Si votre besoin est d’exposer BCI séparément, on passe par la même fabrique (map),
        // en configurant le payload pour BCI côté mapper (c’est déjà le cas dans votre createBciFicpRequest).
        if (type == RequestTypeEnum.BOTH_BNP_BDF) {
            final BciFicpRequestDto inBci = bciFicpMapper.map(req, channel, caller, userId);
            final IncidentBciFicpResult resBci = bciFicpService.post(inBci);
            if (resBci != null && resBci.getIncidentListBCI() != null) {
                out.add(new IncidentsCharacteristics(resBci.getIncidentListBCI(), OriginEnum.BCI));
            }
        }

        // 3) FICP BDF (appel unitaire)
        if (type == RequestTypeEnum.BDF_ONLY || type == RequestTypeEnum.BOTH_BNP_BDF) {
            final List<com.bnpparibas.dsibddf.ap10530.incident.domain.model.Personne> ficpBdf =
                    ficpService.searchIncident(req, channel, caller, userId);
            if (ficpBdf != null && !ficpBdf.isEmpty()) {
                out.add(new IncidentsCharacteristics(ficpBdf, OriginEnum.FICP_BDF));
            }
        }

        // 4) FCC BDF (appel unitaire)
        if (type == RequestTypeEnum.BDF_ONLY || type == RequestTypeEnum.BOTH_BNP_BDF) {
            final List<com.bnpparibas.dsibddf.ap10530.incident.domain.model.Personne> fcc =
                    fccService.searchIncident(req, channel, caller, userId);
            if (fcc != null && !fcc.isEmpty()) {
                out.add(new IncidentsCharacteristics(fcc, OriginEnum.FCC));
            }
        }

        return out;
    }
}

Points clés :

On remplace les anciens appels à bciFicpMapper.map(...) par les wrappers ajoutés ci-dessus (map/mapRP) qui délèguent vers vos méthodes validées createBciFicpRequest(...) / createBciFicpRequestRP(...). 

On sépare les appels par service, conformément au ticket : FICP-BNPP (postRP + OriginEnum.FICP_BNPP), BCI (post + OriginEnum.BCI), FICP-BDF (via ficpService + OriginEnum.FICP_BDF), FCC-BDF (via fccService + OriginEnum.FCC). Les énumérations et structures d’agrégation IncidentsCharacteristics existent déjà et supportent ces origines. 

La génération de la clé BDF reste identique et centralisée, comme dans votre code actuel. 



---

Bloc 3 — Rien à changer côté enums

RequestTypeEnum contient déjà BNP_ONLY, BDF_ONLY, BOTH_BNP_BDF utilisés pour piloter les appels unitaires. Aucune modif à prévoir ici. 


---

Bloc 4 — Services appelés (rappel des points d’accroche)

BciFicpRestService#post(...) et #postRP(...) existent déjà et retournent IncidentBciFicpResult (listes getIncidentListBCI() et getIncidentListFCIPBNPP()). On ne change rien de leur code, on les invoque séparément. 

FICPService#searchIncident(...) = FICP BDF.

FCCService#searchIncident(...) = FCC BDF.
Les deux sont déjà injectés et utilisés dans l’orchestrateur. 



---

Pourquoi cela corrige ton erreur et couvre “l’évolution”

1. Erreur “map n’existe pas” : les deux wrappers map(...)/mapRP(...) rétablissent la méthode attendue, en déléguant au code déjà en prod (createBciFicpRequest*). Plus de compilation cassée. 


2. Appels unitaires FICP/FCC/BCI : l’orchestrateur déclenche maintenant chaque service indépendamment selon RequestTypeEnum — exactement l’évolution demandée par le ticket. Les réponses sont étiquetées via IncidentsCharacteristics.OriginEnum (FICP-BNPP, BCI, FICP-BDF, FCC). 




---

À tester en local (config JAR)

Tu lances bien le module exposition (Spring Boot) en profil local — conforme à ta capture (Jar Application, -Dspring.profiles.active=local). Rien à changer pour ces blocs de code. La classe de démarrage est com.bnpparibas.dsibddf.ap10530.incident.exposition.BankingIncidentApplication. 

Si tu veux, je peux aussi te donner un exemple de payload minimal pour chacune des voies (FICP-BNPP / BCI / FICP-BDF / FCC-BDF) afin de valider rapidement en Postman.

