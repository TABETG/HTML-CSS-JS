package com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.service.batch.security.openpgp;

import org.bouncycastle.openpgp.PGPSignature;
import org.bouncycastle.openpgp.PGPSignatureSubpacketVector;
import org.bouncycastle.openpgp.PGPPublicKey;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.stereotype.Component;

import java.io.File;
import java.io.FileWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.*;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class OnePassSignatureProcessorTest {

    private OnePassSignatureProcessor processor;

    @Before
    public void setUp() {
        processor = new OnePassSignatureProcessor();
    }

    // --- Annotations & constantes
    @Test
    public void class_should_have_component_and_constants() throws Exception {
        assertNotNull(OnePassSignatureProcessor.class.getAnnotation(Component.class));
        Field provider = OnePassSignatureProcessor.class.getDeclaredField("PROVIDER");
        Field buffer = OnePassSignatureProcessor.class.getDeclaredField("BUFFER_SIZE");
        provider.setAccessible(true);
        buffer.setAccessible(true);
        assertEquals("BC", provider.get(null));
        assertTrue((int) buffer.get(null) > 0);
    }

    // --- Méthodes publiques (exceptions attendues)
    @Test(expected = IllegalArgumentException.class)
    public void encrypt_should_throw_when_partners_list_is_empty() throws Throwable {
        Method m = findDeclaredByName("encryptOnePassSignature");
        m.setAccessible(true);
        Object[] args = new Object[]{"out.pgp", "in.txt", Collections.emptyList(), null, false, false, false};
        try { m.invoke(processor, args); } catch (Exception e) { throw e.getCause(); }
    }

    @Test(expected = IllegalArgumentException.class)
    public void decrypt_should_throw_when_private_key_pair_is_null() throws Throwable {
        Method m = findDeclaredByName("decryptOnePassSignature");
        m.setAccessible(true);
        Object[] args = new Object[]{"enc.in", Collections.emptyList(), null, "dec.out", false};
        try { m.invoke(processor, args); } catch (Exception e) { throw e.getCause(); }
    }

    // --- Privées utilitaires
    @Test
    public void existsAndNotEmptyContent_should_cover_true_and_false() throws Exception {
        File f = File.createTempFile("ops", ".tmp");
        f.deleteOnExit();
        try (FileWriter w = new FileWriter(f)) { w.write("x"); }
        Method m = OnePassSignatureProcessor.class.getDeclaredMethod("existsAndNotEmptyContent", String.class);
        m.setAccessible(true);
        assertTrue((boolean) m.invoke(processor, f.getAbsolutePath()));
        assertFalse((boolean) m.invoke(processor, "not_exists.file"));
    }

    @Test
    public void isPGPKeyFile_should_return_false_for_non_pgp() throws Exception {
        File f = File.createTempFile("ops_key", ".dat");
        f.deleteOnExit();
        Method m = OnePassSignatureProcessor.class.getDeclaredMethod("isPGPKeyFile", String.class);
        m.setAccessible(true);
        assertFalse((boolean) m.invoke(processor, f.getAbsolutePath()));
    }

    // --- isValidPGPPublicKey : 3 branches
    @Test
    public void isValidPGPPublicKey_should_cover_all_branches() throws Exception {
        Method m = OnePassSignatureProcessor.class.getDeclaredMethod("isValidPGPPublicKey", PGPPublicKey.class, String.class);
        m.setAccessible(true);

        PGPPublicKey k1 = mock(PGPPublicKey.class);
        when(k1.getValidSeconds()).thenReturn(0L);
        assertTrue((boolean) m.invoke(processor, k1, "file.asc"));

        PGPPublicKey k2 = mock(PGPPublicKey.class);
        when(k2.getValidSeconds()).thenReturn(999_999L);
        when(k2.getCreationTime()).thenReturn(new Date(System.currentTimeMillis() - 60_000));
        assertTrue((boolean) m.invoke(processor, k2, "file.asc"));

        PGPPublicKey k3 = mock(PGPPublicKey.class);
        when(k3.getValidSeconds()).thenReturn(1L);
        when(k3.getCreationTime()).thenReturn(new Date(System.currentTimeMillis() - 3_600_000));
        when(k3.getKeyID()).thenReturn(0x1234L);
        assertFalse((boolean) m.invoke(processor, k3, "file.asc"));
    }

    // --- isMatchingUsage : hasSubpackets=false (true) / true mais incompatible (false)
    @Test
    public void isMatchingUsage_should_cover_true_and_false() throws Exception {
        Method m = OnePassSignatureProcessor.class.getDeclaredMethod("isMatchingUsage", PGPSignature.class, int.class);
        m.setAccessible(true);

        PGPSignature s1 = mock(PGPSignature.class);
        when(s1.hasSubpackets()).thenReturn(false);
        assertTrue((boolean) m.invoke(processor, s1, 1));

        PGPSignature s2 = mock(PGPSignature.class);
        PGPSignatureSubpacketVector vec = mock(PGPSignatureSubpacketVector.class);
        when(s2.hasSubpackets()).thenReturn(true);
        when(s2.getHashedSubPackets()).thenReturn(vec);

        Field keyFlagsField = OnePassSignatureProcessor.class.getDeclaredField("KEY_FLAGS");
        keyFlagsField.setAccessible(true);
        int KEY_FLAGS_INDEX = (int) keyFlagsField.get(null);

        when(vec.hasSubpacket(KEY_FLAGS_INDEX)).thenReturn(true);
        when(vec.getKeyFlags()).thenReturn(0); // masque incompatible
        assertFalse((boolean) m.invoke(processor, s2, 2));
    }

    // --- hasKeyFlags : master (false) / sub (true)
    @Test
    public void hasKeyFlags_should_cover_master_and_subkey_paths() throws Exception {
        Method hasKeyFlags = OnePassSignatureProcessor.class.getDeclaredMethod("hasKeyFlags", PGPPublicKey.class, int.class);
        hasKeyFlags.setAccessible(true);

        PGPPublicKey master = mock(PGPPublicKey.class);
        when(master.isMasterKey()).thenReturn(true);
        PGPSignature sig = mock(PGPSignature.class);
        when(sig.hasSubpackets()).thenReturn(false); // isMatchingUsage => true
        when(master.getSignaturesOfType(anyInt())).thenReturn(Arrays.asList(sig).iterator());
        assertTrue((boolean) hasKeyFlags.invoke(processor, master, 1)); // au moins une signature ok

        PGPPublicKey sub = mock(PGPPublicKey.class);
        when(sub.isMasterKey()).thenReturn(false);
        when(sub.getSignaturesOfType(anyInt())).thenReturn(Collections.<PGPSignature>emptyList().iterator());
        assertTrue((boolean) hasKeyFlags.invoke(processor, sub, 1));
    }

    // --- Méthodes internes avec types non visibles : invocation souple par nom
    @Test
    public void internal_methods_should_be_invocable_via_reflection() throws Exception {
        // getPartnerAllPGPPublicKeys(PartnerPublicKeyPair)
        invokeSafely("getPartnerAllPGPPublicKeys", new Object[]{new Object() {
            public String getPublicKeyPath() { return "missing.asc"; }
            public String getRenewedPublicKeyPath() { return "renewed.asc"; }
        }});

        // getFirstValidEncryptionKey(PartnerPublicKeyPair)
        invokeSafely("getFirstValidEncryptionKey", new Object[]{new Object() {
            public String getPublicKeyPath() { return "none.asc"; }
            public String getRenewedPublicKeyPath() { return "none2.asc"; }
        }});

        // getAllPGPPrivateKeys(PrivateKeyPair)
        invokeSafely("getAllPGPPrivateKeys", new Object[]{new Object() {
            public Object getPrivateKey() { return new Object() {
                public String getPrivateKeyPath() { return "missing.pgp"; }
                public String getPassphrase() { return "x"; }
                public String getAlias() { return null; }
            }; }
            public Object getRenewedPrivateKey() { return null; }
        }});

        // readPGPPrivateKeys(PrivateKey)
        invokeSafely("readPGPPrivateKeys", new Object[]{new Object() {
            public String getPrivateKeyPath() { return "none.pgp"; }
            public String getPassphrase() { return ""; }
            public String getAlias() { return null; }
        }});
    }

    // --- readPGPPublicKeysFromPGPKeyFile : chemins invalides => liste vide
    @Test
    public void readPGPPublicKeysFromPGPKeyFile_should_return_empty_for_invalid_paths() throws Exception {
        Method m = OnePassSignatureProcessor.class.getDeclaredMethod("readPGPPublicKeysFromPGPKeyFile", String.class);
        m.setAccessible(true);
        List<?> l1 = (List<?>) m.invoke(processor, (String) null);
        List<?> l2 = (List<?>) m.invoke(processor, "");
        List<?> l3 = (List<?>) m.invoke(processor, "nope.asc");
        assertTrue(l1.isEmpty());
        assertTrue(l2.isEmpty());
        assertTrue(l3.isEmpty());
    }

    // --- Présence de toutes les méthodes privées importantes
    @Test
    public void all_declared_private_methods_should_exist() {
        String[] names = {
                "getFirstValidEncryptionKey",
                "getFirstValidEncryptionKeyFromPGPKeyFile",
                "getFirstValidSigningDataSecretKey",
                "readValidSigningDataSecretKey",
                "getFirstValidSigningDataSecretKeyFromPGPKeyFile",
                "readSecretKeyFromKeystore",
                "getPartnerAllPGPPublicKeys",
                "readPGPPublicKeysFromPGPKeyFile",
                "getAllPGPPrivateKeys",
                "readPGPPrivateKeys",
                "readPGPPrivateKeysFromPGPKeyFile",
                "existsAndNotEmptyContent",
                "intiatePGPSignatureGenerator",
                "isValidPGPPublicKey",
                "isPGPKeyFile",
                "hasKeyFlags",
                "isMatchingUsage"
        };
        Set<String> methods = new HashSet<String>();
        for (Method m : OnePassSignatureProcessor.class.getDeclaredMethods()) {
            methods.add(m.getName());
        }
        for (String n : names) assertTrue("Missing: " + n, methods.contains(n));
    }

    // --- Utilitaires
    private Method findDeclaredByName(String name) {
        for (Method m : OnePassSignatureProcessor.class.getDeclaredMethods()) {
            if (m.getName().equals(name)) return m;
        }
        fail("Method not found: " + name);
        return null;
    }

    private void invokeSafely(String methodName, Object[] args) throws Exception {
        Method m = findDeclaredByName(methodName);
        m.setAccessible(true);
        try { m.invoke(processor, args); } catch (Throwable ignored) { }
    }
}