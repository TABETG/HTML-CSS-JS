Top, je te livre l’évolution “appels unitaires FICP/FCC/BCI” prête à coller.
Principe : on garde la compat’ (comportement actuel = “tous les services”), et on ajoute un sélecteur de services. Si l’appelant précise les services demandés, on n’exécute que ceux-ci.


---

1) Nouvel enum (domain)

// src/main/java/.../domain/model/enums/TargetServiceEnum.java
package com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums;

public enum TargetServiceEnum {
    BCI,           // BCI BNPP (inclut FICP_BNPP dans le wrapper BNPP)
    FICP_BNPP,     // si tu veux dissocier un jour, on garde la valeur
    FICP_BDF,      // FICP Banque de France (PP)
    FCC_BDF,       // FCC Banque de France (PP)
    FCC_PM,        // FCC Banque de France (PM)
    RP             // Vue Référentiel Personne (PP ou PM)
}


---

2) IncidentService — bloc unique remplaçant (ajoute la sélection tout en conservant l’API existante)

package com.bnpparibas.dsibddf.ap10530.incident.application;

import java.util.ArrayList;
import java.util.EnumSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import com.bnpparibas.dsibddf.ap10530.incident.domain.dto.IncidentMoralRequestDto;
import com.bnpparibas.dsibddf.ap10530.incident.domain.dto.IncidentMoralResponseDto;
import com.bnpparibas.dsibddf.ap10530.incident.domain.dto.StatisticsRequestDto;
import com.bnpparibas.dsibddf.ap10530.incident.domain.mappers.BciFicpRequestMapper;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentBciFicpResult;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentsCharacteristics;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentsCharacteristics.OriginEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.MSG_IN;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.Personne;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.ZCON_FONC_IN;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.CTypeImmatEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.LegalNameEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.RequestTypeEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.TargetServiceEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.pm.ZCON_N_FAM;
import com.bnpparibas.dsibddf.ap10530.incident.domain.rest.BciFicpRestService;
import com.bnpparibas.dsibddf.ap10530.incident.domain.rest.PersoneMoraleRestService;
import com.bnpparibas.dsibddf.ap10530.incident.domain.rest.StatisticsService;
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.BDFKeyGenerator;
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.DebuggingUtils;
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.ISOBirthDateConverter;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.service.FCCService;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.ficp.service.FICPService;
import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class IncidentService {

    private static final Logger LOGGER = LoggerFactory.getLogger(IncidentService.class);
    private static final int MAX_BNPP_BATCH = 5;

    @Autowired private StatisticsService statisticsService;
    @Autowired private BciFicpRestService bciFicpService;
    @Autowired private FICPService ficpService;
    @Autowired private FCCService fccService;
    @Autowired private PersoneMoraleRestService pMService;

    private final BciFicpRequestMapper bciFicpMapper = new BciFicpRequestMapper();

    /* ===================== API PUBLIQUE ===================== */

    /** Compat ascendante : appel “historique” = TOUS les services pertinents. */
    public List<IncidentsCharacteristics> searchIncident(final List<PersonSearchRequest> incidentsSearchRequest,
                                                         final String channel,
                                                         final String caller,
                                                         String userId) throws Exception {
        return searchIncidentSelective(
                incidentsSearchRequest, channel, caller, userId, null
        );
    }

    /**
     * Nouveau : sélectionne les services à appeler.
     * @param targets null ou vide => comportement historique (tous).
     */
    public List<IncidentsCharacteristics> searchIncidentSelective(final List<PersonSearchRequest> incidentsSearchRequest,
                                                                  final String channel,
                                                                  final String caller,
                                                                  String userId,
                                                                  Set<TargetServiceEnum> targets) throws Exception {

        final Set<TargetServiceEnum> wanted = normalizeTargets(incidentsSearchRequest, targets);
        final List<IncidentsCharacteristics> resultList = new ArrayList<>();

        // PP (personType null/"0") vs PM ("1")
        if (isPP(incidentsSearchRequest)) {
            final int typeEntree = determineTypeEntreePP(incidentsSearchRequest);

            // BNPP (BCI/FICP BNPP) si demandé
            if (includesAny(wanted, TargetServiceEnum.BCI, TargetServiceEnum.FICP_BNPP)) {
                if (typeEntree == 1) {
                    final IncidentBciFicpResult wrapper = callBnppRP(incidentsSearchRequest);
                    if (wanted.contains(TargetServiceEnum.BCI)) {
                        resultList.add(new IncidentsCharacteristics(wrapper.getIncidentListBCI(), OriginEnum.BCI));
                    }
                    if (wanted.contains(TargetServiceEnum.FICP_BNPP)) {
                        resultList.add(new IncidentsCharacteristics(wrapper.getIncidentListFCIPBNPP(), OriginEnum.FICP_BNPP));
                    }

                    // réinjection pour BDF (clé etc.) + empilement BDF_ONLY
                    final List<PersonSearchRequest> rpBnpp = new ArrayList<>(wrapper.getIncidentListRPBNPP());
                    copySupplementalFields(incidentsSearchRequest, rpBnpp);
                    final List<PersonSearchRequest> bdfOnly = incidentsSearchRequest.stream()
                            .filter(r -> RequestTypeEnum.BDF_ONLY.equals(r.getRequestType()))
                            .collect(Collectors.toList());
                    incidentsSearchRequest.clear();
                    incidentsSearchRequest.addAll(rpBnpp);
                    incidentsSearchRequest.addAll(bdfOnly);

                    // Vue RP si demandée
                    if (wanted.contains(TargetServiceEnum.RP)) {
                        resultList.add(new IncidentsCharacteristics(mapPersonnePhysique(incidentsSearchRequest), OriginEnum.RP));
                    }
                } else if (typeEntree == 2) {
                    generateBDFKeyList(incidentsSearchRequest);
                    final IncidentBciFicpResult wrapper = callBnppInfo(incidentsSearchRequest);
                    if (wanted.contains(TargetServiceEnum.BCI)) {
                        resultList.add(new IncidentsCharacteristics(wrapper.getIncidentListBCI(), OriginEnum.BCI));
                    }
                    if (wanted.contains(TargetServiceEnum.FICP_BNPP)) {
                        resultList.add(new IncidentsCharacteristics(wrapper.getIncidentListFCIPBNPP(), OriginEnum.FICP_BNPP));
                    }
                } // typeEntree==0 : données insuffisantes → pas BNPP
            }

            // FICP BDF (PP)
            if (wanted.contains(TargetServiceEnum.FICP_BDF)) {
                final List<Personne> ficpIncidentList = ficpService.searchIncident(incidentsSearchRequest, channel, caller, userId);
                resultList.add(new IncidentsCharacteristics(ficpIncidentList, OriginEnum.FICP_BDF));
            }

            // FCC BDF (PP)
            if (wanted.contains(TargetServiceEnum.FCC_BDF)) {
                final List<Personne> fccIncidentList = fccService.searchIncident(incidentsSearchRequest, channel, caller, userId);
                resultList.add(new IncidentsCharacteristics(fccIncidentList, OriginEnum.FCC));
            }

            return resultList;
        }

        /* -------- PM -------- */

        final int typeEntreePM = determineTypeEntreePM(incidentsSearchRequest);
        if (typeEntreePM == 2) {
            for (PersonSearchRequest r : incidentsSearchRequest) {
                if (StringUtils.isNotEmpty(r.getImmatId()) && StringUtils.isNotEmpty(r.getImmatType())) {
                    r.setBdfKey(r.getImmatType() + r.getImmatId());
                }
            }
        }

        // Vue RP PM
        if (typeEntreePM == 1 && wanted.contains(TargetServiceEnum.RP)) {
            final List<Personne> listePM = buildPmFromRP(incidentsSearchRequest);
            resultList.add(new IncidentsCharacteristics(listePM, OriginEnum.RP));
        }

        // FCC PM
        if (wanted.contains(TargetServiceEnum.FCC_PM)) {
            final List<Personne> fccPm = fccService.searchIncidentMoral(incidentsSearchRequest, channel, caller, userId);
            resultList.add(new IncidentsCharacteristics(fccPm, OriginEnum.FCC_PM));
        }

        return resultList;
    }

    /* ===================== Helpers sélection ===================== */

    private Set<TargetServiceEnum> normalizeTargets(List<PersonSearchRequest> reqs, Set<TargetServiceEnum> targets) {
        if (targets != null && !targets.isEmpty()) return targets;

        // défaut = comportement historique
        if (isPP(reqs)) {
            return EnumSet.of(TargetServiceEnum.BCI, TargetServiceEnum.FICP_BNPP,
                              TargetServiceEnum.FICP_BDF, TargetServiceEnum.FCC_BDF, TargetServiceEnum.RP);
        }
        return EnumSet.of(TargetServiceEnum.FCC_PM, TargetServiceEnum.RP);
    }

    private static boolean includesAny(Set<TargetServiceEnum> set, TargetServiceEnum... values) {
        for (TargetServiceEnum v : values) if (set.contains(v)) return true;
        return false;
    }

    /* ===================== Impl. existante (ajustée) ===================== */

    private void generateBDFKeyList(final List<PersonSearchRequest> requests) {
        int i = 1;
        final int taille = requests.size();
        for (final PersonSearchRequest person : requests) {
            final String bdfKey = BDFKeyGenerator.computeBDFKey(
                    person.getLastname(), ISOBirthDateConverter.fromISOString(person.getBirthDate())
            );
            LOGGER.debug("computeBDFKey: {}, {} => {}", person.getLastname(), person.getBirthDate(), bdfKey);
            LOGGER.info("Clé BDF appel {} / {} : {}", i++, taille, bdfKey);
            person.setBdfKey(bdfKey);
        }
    }

    public FCCService getFccService() { return fccService; }
    public FICPService getFicpService() { return ficpService; }
    public void setFccService(final FCCService fccService) { this.fccService = fccService; }
    public void setFicpService(final FICPService ficpService) { this.ficpService = ficpService; }

    private static boolean isPP(List<PersonSearchRequest> reqs) {
        return reqs != null && !reqs.isEmpty()
                && (reqs.get(0).getPersonType() == null || "0".equals(reqs.get(0).getPersonType()));
    }

    private int determineTypeEntreePP(List<PersonSearchRequest> reqs) {
        int typeEntree = 1; // RP par défaut
        for (PersonSearchRequest r : reqs) {
            if (StringUtils.isEmpty(r.getPersonId())) { typeEntree = 2; break; }
        }
        if (typeEntree == 2) {
            for (PersonSearchRequest r : reqs) {
                if (r.getBirthDepartment() == null || r.getBirthDate() == null
                        || r.getFirstname() == null || r.getLastname() == null
                        || r.getCivility() == null) {
                    return 0;
                }
            }
        }
        return typeEntree;
    }

    private int determineTypeEntreePM(List<PersonSearchRequest> reqs) {
        int typeEntree = 1;
        for (PersonSearchRequest r : reqs) {
            if (StringUtils.isEmpty(r.getPersonId())) { typeEntree = 2; break; }
        }
        if (typeEntree == 2) {
            for (PersonSearchRequest r : reqs) {
                if (r.getImmatId() == null || r.getImmatType() == null) return 0;
            }
        }
        return typeEntree;
    }

    private List<Personne> mapPersonnePhysique(final List<PersonSearchRequest> list) {
        final List<Personne> out = new ArrayList<>();
        for (final PersonSearchRequest psr : list) {
            if (psr == null) continue;
            final Personne pp = new Personne();
            pp.setFirstname(psr.getFirstname());
            pp.setLastname(psr.getLastname());
            pp.setCivility(psr.getCivility());
            pp.setBdfkey(psr.getBdfKey());
            pp.setMarriedName(psr.getMarriedName());
            pp.setBirthDate(psr.getBirthDate());
            pp.setBirthCity(psr.getBirthCity());
            pp.setBirthCountry(psr.getBirthCountry());
            pp.setBirthDepartment(psr.getBirthDepartment());
            out.add(pp);
        }
        return out;
    }

    private IncidentMoralRequestDto createRestRequest(final PersonSearchRequest input) {
        IncidentMoralRequestDto in = new IncidentMoralRequestDto();
        MSG_IN msgIn = new MSG_IN();
        ZCON_FONC_IN fonc = new ZCON_FONC_IN();
        fonc.setZCON_N_VERSION(1);
        fonc.setZCON_Q_LIST_FAM(4);
        fonc.setZCON_I_SDISTN_MSG("");
        fonc.setZCON_I_ENT_PRSNE("");
        fonc.setZCON_C_ETABL_MSG("");
        fonc.setZCON_C_LANGUE_MSG("");
        fonc.setZCON_C_APPL("");
        List<ZCON_N_FAM> temp = new ArrayList<>();
        temp.add(new ZCON_N_FAM(96));
        temp.add(new ZCON_N_FAM(154));
        temp.add(new ZCON_N_FAM(178));
        temp.add(new ZCON_N_FAM(233));
        fonc.setZCON_G_LIST_FAM(temp);
        fonc.setZCON_I_IDENT(input.getPersonId());
        fonc.setZCON_C_TYPE_IDENT("PE");
        msgIn.setZcon_FONC_IN(fonc);
        in.setMSG_IN(msgIn);
        return in;
    }

    private void copySupplementalFields(List<PersonSearchRequest> from, List<PersonSearchRequest> to) {
        final int size = Math.min(from.size(), to.size());
        for (int i = 0; i < size; i++) {
            PersonSearchRequest src = from.get(i), dst = to.get(i);
            if (src == null || dst == null) continue;
            dst.setConservPreuve(src.getConservPreuve());
            dst.setStatutPreuve(src.getStatutPreuve());
            dst.setNbCptesDossier(src.getNbCptesDossier());
            dst.setDureeContrat(src.getDureeContrat());
            dst.setDateDebutCredit(src.getDateDebutCredit());
            dst.setAppEmettrice(src.getAppEmettrice());
            dst.setRefExterne(src.getRefExterne());
            dst.setPersonId(src.getPersonId());
            dst.setNbPersFicp(src.getNbPersFicp());
            dst.setRibEtTypedeCompte(src.getRibEtTypedeCompte());
        }
    }

    private IncidentBciFicpResult callBnppRP(List<PersonSearchRequest> reqs) {
        if (reqs.size() > MAX_BNPP_BATCH) {
            final List<PersonSearchRequest> p1 = reqs.subList(0, MAX_BNPP_BATCH);
            final List<PersonSearchRequest> p2 = reqs.subList(MAX_BNPP_BATCH, reqs.size());
            final IncidentBciFicpResult w1 = bciFicpService.postRP(bciFicpMapper.createBciFicpRequestRP(p1), p1);
            final IncidentBciFicpResult w2 = bciFicpService.postRP(bciFicpMapper.createBciFicpRequestRP(p2), p2);
            return mergeWrappers(w1, w2);
        }
        return bciFicpService.postRP(bciFicpMapper.createBciFicpRequestRP(reqs), reqs);
    }

    private IncidentBciFicpResult callBnppInfo(List<PersonSearchRequest> reqs) {
        if (reqs.size() > MAX_BNPP_BATCH) {
            final List<PersonSearchRequest> p1 = reqs.subList(0, MAX_BNPP_BATCH);
            final List<PersonSearchRequest> p2 = reqs.subList(MAX_BNPP_BATCH, reqs.size());
            final IncidentBciFicpResult w1 = bciFicpService.post(bciFicpMapper.createBciFicpRequest(p1));
            final IncidentBciFicpResult w2 = bciFicpService.post(bciFicpMapper.createBciFicpRequest(p2));
            return mergeWrappers(w1, w2);
        }
        return bciFicpService.post(bciFicpMapper.createBciFicpRequest(reqs));
    }

    private static IncidentBciFicpResult mergeWrappers(IncidentBciFicpResult w1, IncidentBciFicpResult w2) {
        w1.getIncidentListBCI().addAll(w2.getIncidentListBCI());
        w1.getIncidentListFCIPBNPP().addAll(w2.getIncidentListFCIPBNPP());
        Optional.ofNullable(w1.getIncidentListRPBNPP()).ifPresent(list -> {
            if (w2.getIncidentListRPBNPP() != null) list.addAll(w2.getIncidentListRPBNPP());
        });
        return w1;
    }
}


---

3) Contrôleur — patch minimal pour activer la sélection (facultatif si tu veux rester full-service)

On ajoute un header optionnel X-Incident-Services (CSV, ex. FICP_BDF,FCC_BDF), sinon comportement historique.


// dans BankingIncidentsApiController (méthode POST existante)
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.TargetServiceEnum;

// ...
@PostMapping("/banking-incidents")
public ResponseEntity<List<IncidentsCharacteristics>> search(
        @RequestBody List<PersonSearchRequest> body,
        @RequestHeader("channel") String channel,
        @RequestHeader("Caller") String caller,
        @RequestHeader(value = "userId", required = false) String userId,
        @RequestHeader(value = "X-Incident-Services", required = false) String servicesCsv
) throws Exception {

    Set<TargetServiceEnum> targets = null;
    if (servicesCsv != null && !servicesCsv.trim().isEmpty()) {
        targets = Arrays.stream(servicesCsv.split(","))
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .map(String::toUpperCase)
                .map(TargetServiceEnum::valueOf)
                .collect(Collectors.toCollection(() -> EnumSet.noneOf(TargetServiceEnum.class)));
    }

    final List<IncidentsCharacteristics> out = (targets == null || targets.isEmpty())
            ? incidentService.searchIncident(body, channel, caller, userId)
            : incidentService.searchIncidentSelective(body, channel, caller, userId, targets);

    return ResponseEntity.ok(out);
}


---

4) Exemples d’appel

Comportement historique (tous services)
POST /.../banking-incidents (sans header X-Incident-Services)

Seulement FICP & FCC BDF (PP)
X-Incident-Services: FICP_BDF,FCC_BDF

Seulement BCI BNPP (PP)
X-Incident-Services: BCI

PM : Vue RP + FCC PM
X-Incident-Services: RP,FCC_PM



---

Si tu veux, je peux te générer le diff git exact (IncidentService, enum + patch contrôleur) ou adapter le sélecteur via query param au lieu du header.

