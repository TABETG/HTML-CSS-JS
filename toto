package com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.service.batch.security.openpgp;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import org.mockito.InOrder;
import org.mockito.MockedConstruction;
import org.mockito.MockedStatic;
import org.mockito.junit.MockitoJUnitRunner;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.util.*;

import org.bouncycastle.openpgp.*;
import org.bouncycastle.openpgp.operator.bc.BcPublicKeyDataDecryptorFactory;
import org.bouncycastle.openpgp.operator.jcajce.JcaKeyFingerprintCalculator;
import org.bouncycastle.openpgp.operator.jcajce.JcaPGPContentVerifierBuilderProvider;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

/**
 * Tests JUnit 4 pour EncryptedInputStream – 100% coverage.
 * Contraintes respectées : JUnit4, MockitoJUnitRunner, pas Jupiter, pas AssertJ, verifyNoInteractions.
 */
@RunWith(MockitoJUnitRunner.class)
public class EncryptedInputStreamTest {

    private static final long PRIV_KEY_ID = 0x1234L;
    private static final long SIG_KEY_ID  = 0x9999L;

    private PGPEncryptedDataList encList;
    private PGPPublicKeyEncryptedData pkeData;
    private PGPPrivateKey privateKey;
    private PGPOnePassSignature onePassSig;
    private PGPPublicKey partnerPubKey;
    private PGPLiteralData literalData;
    private PGPCompressedData compressedData;
    private PGPSignature signature;
    private PGPSignatureList signatureList;

    private ByteArrayInputStream clearTextStreamABC;

    @Before
    public void setUp() {
        encList = mock(PGPEncryptedDataList.class);
        pkeData = mock(PGPPublicKeyEncryptedData.class);
        privateKey = mock(PGPPrivateKey.class);
        onePassSig = mock(PGPOnePassSignature.class);
        partnerPubKey = mock(PGPPublicKey.class);
        literalData = mock(PGPLiteralData.class);
        compressedData = mock(PGPCompressedData.class);
        signature = mock(PGPSignature.class);
        signatureList = mock(PGPSignatureList.class);

        when(privateKey.getKeyID()).thenReturn(PRIV_KEY_ID);
        when(pkeData.getKeyID()).thenReturn(PRIV_KEY_ID);

        // Iterator pour la liste des données chiffrées
        List<PGPEncryptedData> ed = Collections.<PGPEncryptedData>singletonList(pkeData);
        when(encList.getEncryptedDataObjects()).thenReturn(ed.iterator());

        // Clé publique du partenaire pour la signature
        when(partnerPubKey.getKeyID()).thenReturn(SIG_KEY_ID);
        when(onePassSig.getKeyID()).thenReturn(SIG_KEY_ID);

        // Flux "clair" : "abc"
        clearTextStreamABC = new ByteArrayInputStream(new byte[]{'a', 'b', 'c'});

        // PGPLiteralData -> retourne le flux clair
        when(literalData.getDataStream()).thenReturn(clearTextStreamABC);
    }

    /**
     * Happy path complet : marker ignoré, decrypt, decompress, signature OK, integrity OK,
     * read(), read(byte[],..), calculateSignature(), verifySignature(), verifyIntegrity(), close()
     */
    @Test
    public void test_full_success_flow_all_methods_ok() throws Exception {
        InputStream dummyDecoder = new ByteArrayInputStream(new byte[0]);
        InputStream decryptedInner = new ByteArrayInputStream(new byte[0]);
        InputStream decompressedStream = new ByteArrayInputStream(new byte[0]);

        // pkeData -> data stream clair (après décryptage)
        when(pkeData.getDataStream(any(BcPublicKeyDataDecryptorFactory.class))).thenReturn(decryptedInner);

        // integrity ok
        when(pkeData.isIntegrityProtected()).thenReturn(true);
        when(pkeData.verify()).thenReturn(true);

        // one-pass signature init/verify OK
        doNothing().when(onePassSig).init(any(JcaPGPContentVerifierBuilderProvider.class), eq(partnerPubKey));
        when(onePassSig.verify(any(PGPSignature.class))).thenReturn(true);

        // PGPOnePassSignatureList itération
        PGPOnePassSignatureList opsList = mock(PGPOnePassSignatureList.class);
        when(opsList.iterator()).thenReturn(Collections.singletonList(onePassSig).iterator());

        // PGPSignatureList pour verifySignature()
        when(signature.getKeyID()).thenReturn(SIG_KEY_ID);
        when(signatureList.iterator()).thenReturn(Collections.singletonList(signature).iterator());

        // PGPCompressedData -> data stream
        when(compressedData.getDataStream()).thenReturn(decompressedStream);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPObjectFactory> ofConstr = mockConstruction(
                     PGPObjectFactory.class,
                     (mock, ctx) -> {
                         // Chaque "new PGPObjectFactory(...)" aura un comportement séquencé.
                         int idx = ctx.getCount(); // 1er, 2e, 3e constructeur...
                         if (idx == 1) {
                             // 1) objectFactory(decoderStream) -> renvoie la liste chiffrée
                             when(mock.nextObject()).thenReturn(encList);
                         } else if (idx == 2) {
                             // 2) objectFactory(clearDataInputStream) -> renvoie compressedData
                             when(mock.nextObject()).thenReturn(compressedData);
                         } else if (idx == 3) {
                             // 3) objectFactory(dataStream) -> d'abord OPS, puis LiteralData
                             when(mock.nextObject())
                                     .thenReturn(opsList)       // signature init
                                     .thenReturn(literalData)   // data claire
                                     .thenReturn(signatureList);// pour verifySignature() ensuite
                         }
                     })) {

            // PGPUtil.getDecoderStream(...)
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class))).thenReturn(dummyDecoder);

            // Construction de l'instance (parcours complet)
            EncryptedInputStream eis = new EncryptedInputStream(
                    new ByteArrayInputStream(new byte[]{1, 2, 3}),
                    Collections.singletonList(privateKey),
                    Collections.singletonList(partnerPubKey)
            );

            // read()
            int first = eis.read();
            assertEquals('a', first);

            // read(byte[], off, len)
            byte[] buf = new byte[2];
            int n = eis.read(buf, 0, 2);
            assertEquals(2, n);
            assertEquals('b', buf[0]);
            assertEquals('c', buf[1]);

            // calculateSignature -> doit appeler update
            byte[] blk = new byte[]{10, 11, 12, 13};
            eis.calculateSignature(blk, 1, 2);
            verify(onePassSig).update(blk, 1, 2);

            // verifySignature -> OK
            eis.verifySignature();

            // verifyIntegrity -> OK
            eis.verifyIntegrity();

            // close() -> ferme les 3 flux si non nuls (literal, compressed, decoder)
            eis.close();
        }
    }

    /** Aucun private key correspondant -> IllegalArgumentException */
    @Test
    public void test_constructor_no_matching_private_key_throws_IAE() throws Exception {
        InputStream dummyDecoder = new ByteArrayInputStream(new byte[0]);

        // EncDataList -> contient pkeData avec keyID PRIV_KEY_ID
        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPObjectFactory> ofConstr = mockConstruction(
                     PGPObjectFactory.class,
                     (mock, ctx) -> when(mock.nextObject()).thenReturn(encList))) {

            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class))).thenReturn(dummyDecoder);

            try {
                // On fournit une privateKey avec un autre ID -> pas de match
                PGPPrivateKey other = mock(PGPPrivateKey.class);
                when(other.getKeyID()).thenReturn(0xDEADL);

                new EncryptedInputStream(
                        new ByteArrayInputStream(new byte[0]),
                        Collections.singletonList(other),
                        Collections.singletonList(partnerPubKey)
                );
                fail("Expected IllegalArgumentException");
            } catch (IllegalArgumentException ex) {
                assertTrue(ex.getMessage().contains("No matching PGP private key"));
            }
        }
    }

    /** Signature section présente, mais aucune clé publique partenaire ne matche -> IllegalArgumentException */
    @Test
    public void test_constructor_no_matching_public_key_for_signature_throws_IAE() throws Exception {
        InputStream dummyDecoder = new ByteArrayInputStream(new byte[0]);
        InputStream decryptedInner = new ByteArrayInputStream(new byte[0]);

        when(pkeData.getDataStream(any(BcPublicKeyDataDecryptorFactory.class))).thenReturn(decryptedInner);

        PGPOnePassSignatureList opsList = mock(PGPOnePassSignatureList.class);
        PGPOnePassSignature otherSig = mock(PGPOnePassSignature.class);
        when(otherSig.getKeyID()).thenReturn(0xAAAA_L);
        when(opsList.iterator()).thenReturn(Collections.singletonList(otherSig).iterator());

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPObjectFactory> ofConstr = mockConstruction(
                     PGPObjectFactory.class,
                     (mock, ctx) -> {
                         int idx = ctx.getCount();
                         if (idx == 1) {
                             when(mock.nextObject()).thenReturn(encList);
                         } else if (idx == 2) {
                             when(mock.nextObject()).thenReturn(opsList);
                         }
                     })) {
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class))).thenReturn(dummyDecoder);

            try {
                new EncryptedInputStream(
                        new ByteArrayInputStream(new byte[0]),
                        Collections.singletonList(privateKey),
                        Collections.singletonList(partnerPubKey) // ne matche pas 0xAAAA
                );
                fail("Expected IllegalArgumentException");
            } catch (IllegalArgumentException ex) {
                assertTrue(ex.getMessage().contains("No matching public key"));
            }
        }
    }

    /** Pas de section signature (chemin "No signature found") + literal OK */
    @Test
    public void test_constructor_no_signature_block_literal_ok() throws Exception {
        InputStream dummyDecoder = new ByteArrayInputStream(new byte[0]);
        InputStream decryptedInner = new ByteArrayInputStream(new byte[0]);

        when(pkeData.getDataStream(any(BcPublicKeyDataDecryptorFactory.class))).thenReturn(decryptedInner);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPObjectFactory> ofConstr = mockConstruction(
                     PGPObjectFactory.class,
                     (mock, ctx) -> {
                         int idx = ctx.getCount();
                         if (idx == 1) {
                             when(mock.nextObject()).thenReturn(encList);
                         } else if (idx == 2) {
                             // Pas de PGPOnePassSignatureList : on renvoie directement un LiteralData
                             when(mock.nextObject()).thenReturn(literalData);
                         }
                     })) {
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class))).thenReturn(dummyDecoder);

            EncryptedInputStream eis = new EncryptedInputStream(
                    new ByteArrayInputStream(new byte[0]),
                    Collections.singletonList(privateKey),
                    null // pas de clés publiques partenaires -> branche "No signature found"
            );

            // Vérifie qu'on lit bien
            assertEquals('a', eis.read());
            eis.close();
        }
    }

    /** LiteralData sans data stream -> IllegalArgumentException "not in valid PGP format" */
    @Test
    public void test_constructor_literaldata_without_stream_throws_IAE() throws Exception {
        InputStream dummyDecoder = new ByteArrayInputStream(new byte[0]);
        InputStream decryptedInner = new ByteArrayInputStream(new byte[0]);

        when(pkeData.getDataStream(any(BcPublicKeyDataDecryptorFactory.class))).thenReturn(decryptedInner);

        PGPLiteralData badLiteral = mock(PGPLiteralData.class);
        when(badLiteral.getDataStream()).thenReturn(null);

        try (MockedStatic<PGPUtil> util = mockStatic(PGPUtil.class);
             MockedConstruction<PGPObjectFactory> ofConstr = mockConstruction(
                     PGPObjectFactory.class,
                     (mock, ctx) -> {
                         int idx = ctx.getCount();
                         if (idx == 1) {
                             when(mock.nextObject()).thenReturn(encList);
                         } else if (idx == 2) {
                             when(mock.nextObject()).thenReturn(badLiteral);
                         }
                     })) {
            util.when(() -> PGPUtil.getDecoderStream(any(InputStream.class))).thenReturn(dummyDecoder);

            try {
                new EncryptedInputStream(
                        new ByteArrayInputStream(new byte[0]),
                        Collections.singletonList(privateKey),
                        null
                );
                fail("Expected IllegalArgumentException");
            } catch (IllegalArgumentException ex) {
                assertTrue(ex.getMessage().contains("not in valid PGP format"));
            }
        }
    }

    /** verifySignature : signatures inconsistantes -> IllegalStateException */
    @Test
    public void test_verifySignature_inconsistent_throws_IllegalStateException() throws Exception {
        // On fabrique une instance et on remplace les champs nécessaires par réflexion.
        EncryptedInputStream eis = newInstanceBypass(); // bypass constructeur réel

        PGPOnePassSignature sig = mock(PGPOnePassSignature.class);
        when(sig.getKeyID()).thenReturn(SIG_KEY_ID);

        PGPSignature other = mock(PGPSignature.class);
        when(other.getKeyID()).thenReturn(0xABCDL); // ne matche pas

        PGPSignatureList list = mock(PGPSignatureList.class);
        when(list.iterator()).thenReturn(Collections.singletonList(other).iterator());

        // objectFactory simulé pour renvoyer la signatureList
        PGPObjectFactory fac = mock(PGPObjectFactory.class);
        when(fac.nextObject()).thenReturn(list);

        // champs internes
        setField(eis, "objectFactory", fac);
        setField(eis, "calculatedSignature", sig);
        eis.targetPartnerPGPPublicKey = partnerPubKey;

        try {
            eis.verifySignature();
            fail("Expected IllegalStateException");
        } catch (IllegalStateException ex) {
            assertTrue(ex.getMessage().contains("inconsistent"));
        }
    }

    /** verifySignature : mauvaise signature -> PGPException */
    @Test
    public void test_verifySignature_wrong_signature_throws_PGPException() throws Exception {
        EncryptedInputStream eis = newInstanceBypass();

        PGPOnePassSignature sig = mock(PGPOnePassSignature.class);
        when(sig.getKeyID()).thenReturn(SIG_KEY_ID);
        when(sig.verify(any(PGPSignature.class))).thenReturn(false);

        PGPSignature ok = mock(PGPSignature.class);
        when(ok.getKeyID()).thenReturn(SIG_KEY_ID);

        PGPSignatureList list = mock(PGPSignatureList.class);
        when(list.iterator()).thenReturn(Collections.singletonList(ok).iterator());

        PGPObjectFactory fac = mock(PGPObjectFactory.class);
        when(fac.nextObject()).thenReturn(list);

        setField(eis, "objectFactory", fac);
        setField(eis, "calculatedSignature", sig);
        eis.targetPartnerPGPPublicKey = partnerPubKey;

        try {
            eis.verifySignature();
            fail("Expected PGPException");
        } catch (PGPException ex) {
            assertTrue(ex.getMessage().contains("Wrong signature"));
        }
    }

    /** verifyIntegrity : protégé mais échec -> PGPException */
    @Test
    public void test_verifyIntegrity_protected_but_fail_throws_PGPException() throws Exception {
        EncryptedInputStream eis = newInstanceBypass();

        PGPPublicKeyEncryptedData pke = mock(PGPPublicKeyEncryptedData.class);
        when(pke.isIntegrityProtected()).thenReturn(true);
        when(pke.verify()).thenReturn(false);

        setField(eis, "publicKeyEncryptedData", pke);

        try {
            eis.verifyIntegrity();
            fail("Expected PGPException");
        } catch (PGPException ex) {
            assertTrue(ex.getMessage().contains("integrity verification failed"));
        }
    }

    /** verifyIntegrity : non protégé -> pas d’exception (branche WARN) */
    @Test
    public void test_verifyIntegrity_not_protected_ok() throws Exception {
        EncryptedInputStream eis = newInstanceBypass();

        PGPPublicKeyEncryptedData pke = mock(PGPPublicKeyEncryptedData.class);
        when(pke.isIntegrityProtected()).thenReturn(false);

        setField(eis, "publicKeyEncryptedData", pke);

        eis.verifyIntegrity(); // ne jette rien
    }

    /** calculateSignature : calculatedSignature mocké mais targetPartnerPGPPublicKey null -> no interaction */
    @Test
    public void test_calculateSignature_no_partner_key_no_interaction() {
        EncryptedInputStream eis = newInstanceBypass();

        PGPOnePassSignature sig = mock(PGPOnePassSignature.class);
        setField(eis, "calculatedSignature", sig);
        eis.targetPartnerPGPPublicKey = null; // condition false

        byte[] data = new byte[]{1,2,3};
        eis.calculateSignature(data, 0, 3);

        verifyNoInteractions(sig); // rien appelé
    }

    // ---------- Helpers ----------

    /** Crée une instance sans passer par le constructeur réel (pour piloter les champs). */
    private EncryptedInputStream newInstanceBypass() {
        try {
            return (EncryptedInputStream) sun.misc.Unsafe.getUnsafe();
        } catch (SecurityException se) {
            // fallback via réflexion standard
        }
        try {
            java.lang.reflect.Constructor<?> objCons = Object.class.getDeclaredConstructor();
            objCons.setAccessible(true);
            EncryptedInputStream inst = (EncryptedInputStream) java.lang.reflect.Proxy.newProxyInstance(
                    EncryptedInputStream.class.getClassLoader(),
                    new Class<?>[]{},
                    (proxy, method, args) -> null
            );
        } catch (Exception ignore) {}
        // Méthode portable : allocate via reflection on constructor bypass using ReflectionFactory
        try {
            sun.reflect.ReflectionFactory rf = sun.reflect.ReflectionFactory.getReflectionFactory();
            java.lang.reflect.Constructor<Object> objDef = Object.class.getDeclaredConstructor();
            java.lang.reflect.Constructor<?> intCons = rf.newConstructorForSerialization(
                    EncryptedInputStream.class, objDef);
            intCons.setAccessible(true);
            return (EncryptedInputStream) intCons.newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Bypass instantiation failed", e);
        }
    }

    private void setField(Object target, String name, Object value) {
        try {
            Field f = EncryptedInputStream.class.getDeclaredField(name);
            f.setAccessible(true);
            f.set(target, value);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}