package com.bnpparibas.dsibddf.ap00420.streamfact.exposition.rest.support;

import com.bnpparibas.bddf.config.SpringProfileConstants;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.core.env.Environment;

import java.lang.reflect.Field;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.mockito.Mockito.when;

class AbstractSpringBootLauncherTest {

    /** Implémentation concrète minimale pour tester la classe abstraite. */
    static class TestLauncher extends AbstractSpringBootLauncher { }

    /**
     * Mini app pour le test de launch(...).
     * On EXCLUT explicitement les autoconfigs Vault par nom (pas besoin d'importer leurs classes).
     */
    @SpringBootApplication(
            excludeName = {
                    "org.springframework.cloud.vault.config.VaultAutoConfiguration",
                    "org.springframework.cloud.vault.config.VaultBootstrapConfiguration",
                    "org.springframework.cloud.vault.config.VaultBootstrapPropertySourceConfiguration"
            }
    )
    static class DummyApp { }

    /** Injecte un mock Environment dans le champ 'env' via réflexion. */
    private static void injectEnv(AbstractSpringBootLauncher launcher, Environment env) throws Exception {
        Field f = AbstractSpringBootLauncher.class.getDeclaredField("env");
        f.setAccessible(true);
        f.set(launcher, env);
    }

    @Test
    void initApplication_withNonConflictingProfiles_logsInfoOnly() throws Exception {
        TestLauncher launcher = new TestLauncher();
        Environment env = Mockito.mock(Environment.class);
        when(env.getActiveProfiles()).thenReturn(new String[] {"dev"});
        injectEnv(launcher, env);

        launcher.initApplication(); // branche "info"
    }

    @Test
    void initApplication_withMqAndActiveMq_logsErrorBranch() throws Exception {
        TestLauncher launcher = new TestLauncher();
        Environment env = Mockito.mock(Environment.class);
        when(env.getActiveProfiles()).thenReturn(new String[] {
                SpringProfileConstants.SPRING_PROFILE_MQ,
                SpringProfileConstants.SPRING_PROFILE_ACTIVE_MQ
        });
        injectEnv(launcher, env);

        launcher.initApplication(); // branche "error"
    }

    @Test
    void launch_runsHeadless_withoutVault_or_Bootstrap() {
        // Désactive TOUT ce qui déclenche Vault et le bootstrap context,
        // et empêche tout serveur web/port d’être ouvert.
        String[] args = new String[] {
                "--spring.main.web-application-type=NONE",
                "--spring.main.lazy-initialization=true",
                "--spring.application.name=test-app",
                "--server.port=0",

                // Désactivation explicite Spring Cloud Vault + Bootstrap
                "--spring.cloud.vault.enabled=false",
                "--spring.cloud.bootstrap.enabled=false",

                // Double sécurité : on exclut les autoconfigs Vault si elles sont présentes au classpath
                "--spring.autoconfigure.exclude=" +
                        "org.springframework.cloud.vault.config.VaultAutoConfiguration," +
                        "org.springframework.cloud.vault.config.VaultBootstrapConfiguration," +
                        "org.springframework.cloud.vault.config.VaultBootstrapPropertySourceConfiguration"
        };

        assertDoesNotThrow(() ->
                AbstractSpringBootLauncher.launch(DummyApp.class, args)
        );
    }
}