package com.bnpparibas.dsibddf.ap00420.streamfact.batch.maestrostatuspaymentrequest.writer;

import com.bnpparibas.dsibddf.ap00420.streamfact.application.cos.CosService;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.maestrostatuspaymentrequest.MaestroStatusPaymentRequestConfiguration;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.maestrostatuspaymentrequest.dto.PaymentRequestInfosForDocaposte;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.repository.docaposte.DocaposteRepository;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.repository.docaposte.model.DocaposteResponse;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.PaymentRequestEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.history.model.DocaposteEventHistoryEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.history.repository.DocaposteEventHistoryJpaRepository;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.item.Chunk;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.File;
import java.nio.file.Files;
import java.util.Collections;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

/**
 * Tests JUnit 4 pour PrepareAndSendDocaposteNotifWriter.
 *
 * Objectifs de couverture :
 *  - write() : chemin "succès" → envoi Docaposte OK, mise à jour des entités, génération du rapport, push COS.
 *  - write() : chemin "erreur" → exception Docaposte → sauvegardes adaptées, génération du rapport, push COS.
 *  - Vérifier que le fichier de rapport est bien créé dans pathGenerateFile et que COS est appelé avec les bons arguments.
 *
 * Contraintes :
 *  - JUnit 4 uniquement (org.junit.*), pas de JUnit Jupiter ni AssertJ.
 *  - Runner Mockito : @RunWith(MockitoJUnitRunner.class).
 *  - Mocks des dépendances @Autowired et @Value via ReflectionTestUtils.
 */
@RunWith(MockitoJUnitRunner.class)
public class PrepareAndSendDocaposteNotifWriterTest {

    /** SUT. */
    private PrepareAndSendDocaposteNotifWriter writer;

    /** Dépendances externes mockées. */
    @Mock private DocaposteRepository docaposteRepository;
    @Mock private DocaposteEventHistoryJpaRepository docaposteEventHistoryJpaRepository;
    @Mock private CosService cosService;

    /** Données d’entrée mockées. */
    @Mock private PaymentRequestInfosForDocaposte info;
    @Mock private PaymentRequestEntity paymentRequestEntity;
    @Mock private DocaposteEventHistoryEntity docaposteEventHistoryEntity;

    /** Dossier temporaire pour générer les rapports de test. */
    private File tempDir;

    @Before
    public void setUp() throws Exception {
        // Instance concrète du writer (la classe n’est pas un bean dans le test unitaire).
        writer = new PrepareAndSendDocaposteNotifWriter();

        // Prépare un répertoire temporaire d’écriture
        tempDir = Files.createTempDirectory("docaposte-test-").toFile();
        assertTrue(tempDir.isDirectory());

        // Injection des "propriétés" @Value et des beans @Autowired par réflexion
        ReflectionTestUtils.setField(writer, "serialNumber", "SERIAL-001");
        ReflectionTestUtils.setField(writer, "docaposteRepository", docaposteRepository);
        ReflectionTestUtils.setField(writer, "docaposteEventHistoryJpaRepository", docaposteEventHistoryJpaRepository);
        // Chemin de base + nom de fichier paramétrable avec date → on le laisse tel que pour couvrir getToday()
        ReflectionTestUtils.setField(writer, "pathGenerateFile", tempDir.getAbsolutePath() + File.separator);
        ReflectionTestUtils.setField(writer, "fileName", "StreamfactMaestroPaymentRequestsReport.%s.csv");
        ReflectionTestUtils.setField(writer, "prefix", "cos/prefix"); // utilisé par pushReportToCos(prefix, filename, null)

        // Mock de l’item d’entrée minimal requis par write()
        when(info.getDocaposteEventHistory()).thenReturn(docaposteEventHistoryEntity);
        when(info.getPaymentRequest()).thenReturn(paymentRequestEntity);
        when(paymentRequestEntity.getPaymentRequestId()).thenReturn("PR-1");
        when(paymentRequestEntity.getIdDn()).thenReturn("DN-1");

        // Par défaut, les sauvegardes JPA renvoient l’entity telle quelle
        when(docaposteEventHistoryJpaRepository.save(any(DocaposteEventHistoryEntity.class)))
                .thenAnswer(inv -> inv.getArgument(0));
    }

    /**
     * Chemin succès :
     *  - docaposteRepository.sendDossierBox(...) renvoie une liste avec un groupId.
     *  - write() met à jour l’historique, génère le rapport CSV, puis pousse le rapport vers COS.
     */
    @Test
    public void write_should_send_to_docaposte_and_push_report_to_cos_on_success() throws Exception {
        // Réponse Docaposte simulée
        DocaposteResponse response = mock(DocaposteResponse.class);
        when(response.getGroupId()).thenReturn("G-12345");
        when(docaposteRepository.sendDossierBox(anyList()))
                .thenReturn(Collections.singletonList(response));

        // Un seul item dans le Chunk pour couvrir la boucle
        Chunk<PaymentRequestInfosForDocaposte> chunk = new Chunk<>(Collections.singletonList(info));

        // Exécution
        writer.write(chunk);

        // Vérifie que l’envoi Docaposte est bien tenté
        verify(docaposteRepository, times(1)).sendDossierBox(anyList());

        // Deux sauvegardes : avant envoi et après mise à jour des infos de réponse
        verify(docaposteEventHistoryJpaRepository, atLeastOnce()).save(any(DocaposteEventHistoryEntity.class));

        // Vérifie le push COS : prefix + filename (filename contient la date calculée)
        ArgumentCaptor<String> fileNameCaptor = ArgumentCaptor.forClass(String.class);
        verify(cosService, times(1)).pushArchiveFileToCOS(eq("cos/prefix"), fileNameCaptor.capture(), isNull());

        // Le fichier doit exister physiquement dans le répertoire temp
        String producedFileName = fileNameCaptor.getValue();
        assertNotNull(producedFileName);
        File generated = new File(tempDir, producedFileName);
        assertTrue("Le rapport CSV doit exister", generated.exists());
        assertTrue("Le rapport CSV doit être un fichier", generated.isFile());
    }

    /**
     * Chemin erreur :
     *  - docaposteRepository.sendDossierBox(...) lève une exception.
     *  - write() trace l’erreur, sauvegarde les entités au statut d’échec, génère quand même le rapport
     *    puis tente le push COS. Le test vérifie l’absence d’exception et la présence du fichier rapport.
     */
    @Test
    public void write_should_handle_exception_from_docaposte_and_still_generate_and_push_report() throws Exception {
        // Simule une erreur lors de l’envoi
        when(docaposteRepository.sendDossierBox(anyList()))
                .thenThrow(new RuntimeException("Docaposte indisponible"));

        Chunk<PaymentRequestInfosForDocaposte> chunk = new Chunk<>(Collections.singletonList(info));

        // Exécution (ne doit pas lever)
        writer.write(chunk);

        // L’échec provoque au moins une sauvegarde (mise à jour requestDate)
        verify(docaposteEventHistoryJpaRepository, atLeastOnce()).save(any(DocaposteEventHistoryEntity.class));

        // Le rapport est quand même généré et poussé vers COS
        ArgumentCaptor<String> fileNameCaptor = ArgumentCaptor.forClass(String.class);
        verify(cosService, times(1)).pushArchiveFileToCOS(eq("cos/prefix"), fileNameCaptor.capture(), isNull());

        String producedFileName = fileNameCaptor.getValue();
        File generated = new File(tempDir, producedFileName);
        assertTrue(generated.exists());
    }
}