package com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.service;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Optional;

import com.bnpparibas.dsibddf.ap10530.incident.domain.dto.StatisticsRequestDto;
import com.bnpparibas.dsibddf.ap10530.incident.domain.rest.StatisticsService;
import org.apache.commons.lang3.StringUtils;
import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.format.DateTimeFormat;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.bnpparibas.dsibddf.ap10530.incident.domain.model.ApiException;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.Incident;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.Personne;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.RequestTypeEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.SexEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.BDFKeyGenerator;              // (utilisé en commentaire)
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.ISOBirthDateConverter;       // (utilisé en commentaire)
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.dto.Compte;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.dto.Detail;            // (mapping détaillé en attente, laissé commenté)
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.dto.Global;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.dto.Naissance;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.dto.PersonneBdf;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.dto.PersonneMorale;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.dto.PersonnePhysique;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.dto.FCCResponse;

/**
 * Orchestrateur des appels au webservice FCC (Banque de France) et
 * mapping des réponses vers le modèle domaine.
 *
 * Rôles principaux :
 *  - Interroger FCC pour Personnes Physiques (PP) et Personnes Morales (PM).
 *  - Mapper GLOBAL/PP/PM de la réponse FCC vers nos objets domaine (Personne/Incident).
 *  - Journaliser la consultation dans le service de statistiques (canal, appelant, payloads, erreurs).
 *
 * Remarques :
 *  - Les méthodes map* sont "défensives" (null-safe) au maximum.
 *  - Les calculs de clé BDF côté PP ne sont pas refaits ici : on réutilise celle fournie dans la requête.
 */
@Component
public class FCCService {

    // Codes de sexe renvoyés par FCC (différent de FICP : ici "M"/"F")
    private static final String FEMININ = "F";
    private static final String MASCULIN = "M";

    private static final Logger LOGGER = LoggerFactory.getLogger(FCCService.class);

    // Service de statistiques (KPI/traçabilité). Utilisé dans callStaticsService(...)
    @Autowired
    private StatisticsService statisticsService;

    // Client bas-niveau vers le service FCC (Pobi gateway).
    @Autowired
    private PobiFccClient fccClient;

    /** Getter fccClient (utile pour tests/intégration) */
    public PobiFccClient getFccClient() {
        return fccClient;
    }

    /** Setter fccClient (utile pour tests/injection manuelle) */
    public void setFccClient(final PobiFccClient fccClient) {
        this.fccClient = fccClient;
    }

    // =========================================================================
    // ===============  MAPPINGS DE LA REPONSE FCC -> DOMAINE  =================
    // =========================================================================

    /**
     * Convertit la chaîne de sexe FCC ("M" ou "F") vers l'énum SexEnum interne.
     * @param sexe "M" / "F" (FCC)
     * @return SexEnum.MASCULIN / SexEnum.FEMININ ou null si inconnu.
     */
    private SexEnum mapFCCSexType(final String sexe) {
        if (MASCULIN.equals(sexe)) {
            return SexEnum.MASCULIN;
        } else if (FEMININ.equals(sexe)) {
            return SexEnum.FEMININ;
        }
        return null; // Code non-renseigné ou inattendu
    }

    /**
     * Mappe GLOBAL (PP) vers Personne + création d'un Incident.
     *
     * Cas 1 : aucun compte dans GLOBAL → on déduit le nombre d'incidents de la présence/absence de dates.
     * Cas 2 : au moins un compte → on lit le 1er compte et on renseigne les champs d'incident.
     *
     * @param global GLOBAL FCC
     * @param pp     objet Personne (côté domaine) à enrichir
     */
    private void mapGlobal(final Global global, final Personne pp) {
        final Incident incident = new Incident();     // on crée un "slot" d'incident à enrichir
        pp.addIncidentsItem(incident);

        if (null == global.getComptes() || global.getComptes().isEmpty()) {
            // (Bug/contrainte ISO mentionné dans le code d'origine)
            global.setDateDerRCB(StringUtils.defaultString(global.getDateDerRCB()));

            // Si toutes les dates clés sont absentes, 0 incident ; sinon 1 incident minimum
            if (global.getDateDerRCB() == null && global.getDateExpIB() == null && global.getDateExpIJ() == null) {
                pp.setNumberOfIncident(Integer.valueOf(0));
            } else {
                pp.setNumberOfIncident(Integer.valueOf(1));
            }

            // Trois dates importantes dans GLOBAL :
            if (global.getDateDerRCB() != null) {
                incident.setIncidentStatus(global.getDateDerRCB());
            }
            if (global.getDateExpIB() != null) {
                incident.setDateEffect(mapLocalDate(global.getDateExpIB()));
            }
            if (global.getDateExpIJ() != null) {
                incident.setIncidentDate(mapLocalDate(global.getDateExpIJ()));
            }

        } else {
            // Au moins un compte → on s'appuie sur le 1er compte
            final Compte compte = global.getComptes().get(0);

            // Nb incidents = nb chèques si disponible, sinon 0
            if (!StringUtils.isEmpty(compte.getNbChq())) {
                pp.setNumberOfIncident(Integer.valueOf(compte.getNbChq()));
            } else {
                pp.setNumberOfIncident(Integer.valueOf(0));
            }

            // Code "origine" interne basé sur la taille de la liste courante
            final int numIncident = pp.getIncidents().size();
            incident.setOriginCode(String.valueOf(numIncident));

            // Dates (INB/IJ/RCB) -> map vers Incident
            incident.setDateEffect(mapLocalDate(global.getDateExpIB()));
            incident.setIncidentDate(mapLocalDate(global.getDateExpIJ()));
            incident.setIncidentStatus(global.getDateDerRCB());

            // Informations de compte : nombre comptes, nb chèques, montants, type de compte
            incident.setIncidentUO(compte.getNbCpte());
            if (!StringUtils.isEmpty(compte.getNbChq())) {
                // Nettoyage des espaces éventuels avant parsing
                incident.setNumberOfIncidentDeclared(Integer.parseInt(compte.getNbChq().replaceAll("\\s+", "")));
            }
            if (!StringUtils.isEmpty(compte.getMtInsufCum())) {
                // Nota: le nom "numberOfDeclarers" vient du modèle Incident
                incident.setNumberOfDeclarers(Integer.parseInt(compte.getMtInsufCum().replaceAll("\\s+", "")));
            }
            incident.setCompteType(compte.getType());
        }
    }

    /**
     * Mapping GLOBAL (PM) -> Personne (PM) + Incident, champs spécifiques PM.
     * @param global GLOBAL FCC
     * @param pm     objet Personne (PM) à enrichir
     */
    private void mapGlobalMorale(final Global global, final Personne pm) {
        final Incident inc = new Incident();
        // Champs orientés PM (noms donnés par l'équipe métier)
        inc.setAccountType(global.getComptes().get(0).getType());
        inc.setDateFinINB(global.getDateExpIB());
        inc.setDateFinING(global.getDateExpIJ());
        inc.setLastCardWithdraw(global.getDateDerRCB());
        inc.setComptesPM(global.getComptes().get(0).getNbCpte());
        inc.setChequesPM(global.getComptes().get(0).getNbChq());
        inc.setRetraitCBPM(global.getComptes().get(0).getNbRCB());
        pm.addIncidentsItem(inc);
    }

    /**
     * Parse une date FCC "dd.MM.yyyy" en Joda LocalDate.
     * @param stringDate date FCC (ex: "12.03.2020")
     * @return LocalDate ou null si vide
     */
    private LocalDate mapLocalDate(final String stringDate) {
        if (StringUtils.isEmpty(stringDate)) {
            return null;
        }
        return LocalDate.parse(stringDate, DateTimeFormat.forPattern("dd.MM.yyyy"));
    }

    /**
     * Mapping NAISSANCE -> Personne (PP).
     * Particularité : FCC peut retourner une date de naissance sans siècle, on force la date de la requête.
     *
     * @param naissanceType bloc naissance FCC
     * @param pp            personne à enrichir
     * @param psr           requête d'origine (utilisée pour corriger birthDate)
     */
    private void mapNaissance(final Naissance naissanceType, final Personne pp, final PersonSearchRequest psr) {
        if (naissanceType != null) {
            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("received birthDate without century", naissanceType.getDateNaiss());
                LOGGER.debug("replaced by request birthDate", psr.getBirthDate());
            }
            // Correction : on remplace la date de naissance par celle de la requête (ISO)
            pp.setBirthDate(psr.getBirthDate());

            // Construction "code + libellé" pour la commune de naissance, si présents
            String communeCode = "";
            if (null != naissanceType.getCommune().getCode() && null != naissanceType.getCommune().getLibelle()) {
                communeCode = String.format("%s %s", naissanceType.getCommune().getCode(),
                        naissanceType.getCommune().getLibelle());
            } else if (null != naissanceType.getCommune().getCode()) {
                communeCode = naissanceType.getCommune().getCode();
            } else if (null != naissanceType.getCommune().getLibelle()) {
                communeCode = naissanceType.getCommune().getLibelle();
            }
            pp.setBirthCity(communeCode);

            // Département de naissance
            final String birthDepCode = naissanceType.getDepartement().getCode();
            pp.setBirthDepartment(birthDepCode);
        }
    }

    /**
     * Mapping PP FCC -> Personne (domaine).
     * @param ppType bloc PP FCC
     * @param pp     personne à enrichir
     * @param psr    requête d'origine (utilisée pour la clé BDF et la date de naissance corrigée)
     */
    private void mapPersonnePhysique(final PersonnePhysique ppType, final Personne pp, final PersonSearchRequest psr) {
        if (ppType != null) {
            pp.setLastname(ppType.getNom());
            pp.setFirstname(ppType.getPrenoms());
            pp.setCivility(mapFCCSexType(ppType.getSexe()));
            pp.setMarriedName(ppType.getNomMarital());
            // FRUP (identifiant interne FCC)
            pp.setUsuIDFCC(ppType.getFRUP().getLibelle());
            // Naissance (corrige la date si FCC renvoie sans siècle)
            mapNaissance(ppType.getNaissance(), pp, psr);
            // IMPORTANT : on réutilise la clé BDF calculée en amont (pas de recompute ici)
            // pp.setBdfkey(BDFKeyGenerator.computeBDFKey(...)); // version commentée d'origine
            pp.setBdfkey(psr.getBdfKey());
        }
    }

    /**
     * Mapping PM FCC -> Personne (PM) domaine.
     * @param pmType bloc PM FCC
     * @param pm     personne (PM) à enrichir
     */
    private void mapPersonneMorale(final PersonneMorale pmType, final Personne pm) {
        if (pmType != null) {
            pm.setBusinessName(pmType.getDenom());               // Raison sociale
            pm.setLegalName(pmType.getCatJur().getLibelle());    // Libellé forme juridique
            pm.setCodeLegalName(pmType.getCatJur().getCode());   // Code forme juridique
            pm.setPostalCode(pmType.getAdresse().getCP());
            pm.setFiscalAdress1(pmType.getAdresse().getLig1());
            pm.setFiscalAdress2(pmType.getAdresse().getLig2());
            pm.setFiscalAdress3(pmType.getAdresse().getLig3());
            pm.setImmatID(pmType.getNumImmat());                 // N° immatriculation
            pm.setImmatType(pmType.getNatImmat());               // Type immatriculation
        }
    }

    /**
     * Transforme une réponse FCC (PP) en liste Personne (PP).
     * @param gppi réponse FCC brute
     * @param psr  requête d'origine
     * @return liste de Personne (PP)
     */
    private List<Personne> mapFCCResponsePP(final FCCResponse gppi, final PersonSearchRequest psr) {
        final List<Personne> result = new ArrayList<Personne>();
        final List<PersonneBdf> list = gppi.getMessage().getReponse().getPersonnes();
        if (list == null) {
            return result;
        }
        for (final PersonneBdf personneType : list) {
            final Personne pp = new Personne();
            mapPersonnePhysique(personneType.getPP(), pp, psr);
            mapGlobal(personneType.getGlobal(), pp);
            // mapDetail(personneType.getDetail(), pp); // En attente d'info mapping (conservé commenté)
            result.add(pp);
        }
        return result;
    }

    /**
     * Transforme une réponse FCC (PM) en liste Personne (PM).
     * @param gppi réponse FCC brute
     * @param psr  requête d'origine
     * @return liste de Personne (PM)
     */
    private List<Personne> mapFCCResponsePM(final FCCResponse gppi, final PersonSearchRequest psr) {
        final List<Personne> result = new ArrayList<Personne>();
        final List<PersonneBdf> list = gppi.getMessage().getReponse().getPersonnes();
        if (list == null) {
            return result;
        }
        for (final PersonneBdf personneType : list) {
            final Personne pm = new Personne();
            pm.setBdfkey(psr.getBdfKey());            // On propage la clé BDF de la requête
            pm.setPersonId(psr.getPersonId());        // ...et l'identifiant RP si présent
            mapPersonneMorale(personneType.getPM(), pm);
            mapGlobalMorale(personneType.getGlobal(), pm);
            // mapDetail(personneType.getDETAIL(), pm); // non spécifié (conservé commenté)
            result.add(pm);
        }
        return result;
    }

    // =========================================================================
    // ==========================  ORCHESTRATIONS  =============================
    // =========================================================================

    /**
     * Orchestration de recherche FCC pour Personnes Physiques (PP).
     *
     * 1) Pour chaque personne :
     *    - si RequestType != BNP_ONLY, appel fccClient.searchGlobalPP(bdfKey)
     *    - envoi d'une trace stats (callStaticsService)
     *    - mapping de la réponse FCC vers Personne (mapFCCResponsePP)
     *
     * @param incidentsSearchRequest liste d'entrées (avec bdfKey calculée en amont)
     * @return liste de Personne enrichies depuis FCC (PP)
     */
    public List<Personne> searchIncident(final List<PersonSearchRequest> incidentsSearchRequest,
                                         final String channel,
                                         final String caller,
                                         String userId) {
        final List<Personne> result = new ArrayList<Personne>();
        try {
            for (final PersonSearchRequest personSearchRequest : incidentsSearchRequest) {
                // On appelle FCC sauf si on a explicitement demandé BNP_ONLY
                if (!personSearchRequest.getRequestType().equals(RequestTypeEnum.BNP_ONLY)) {
                    final FCCResponse gppi = fccClient.searchGlobalPP(personSearchRequest.getBdfKey());

                    // Traçabilité statistiques : canal, appelant, clé, erreurs...
                    callStaticsService(channel, caller, personSearchRequest, gppi, userId);

                    // Mapping réponse -> modèle domaine
                    result.addAll(mapFCCResponsePP(gppi, personSearchRequest));
                }
            }
            return result;

        } catch (final ApiException apie) {
            LOGGER.error("API Exception", apie);
            throw new ApiException(1, apie.getMessage());

        } catch (final Exception e) {
            LOGGER.error("Service Call Exception", e);
            throw new ApiException(1, e.getMessage());
        }
    }

    /**
     * Envoie une trace statistique (KPI) pour l’appel FCC réalisé.
     * - Construit la clé BDF si absente (fallback avec dateNaissance + 5 1ères lettres du nom).
     * - Renseigne le canal, l’appelant tronqué (<=8), le type de requête, etc.
     * - Log l’erreur éventuelle issue de la réponse FCC.
     *
     * @return "OK" si post réussi, "KO" si échec (les exceptions sont absorbées ici pour ne pas bloquer le flux principal).
     */
    private String callStaticsService(String channel,
                                      String caller,
                                      PersonSearchRequest personSearchRequest,
                                      FCCResponse gppi,
                                      String userId) throws Exception {
        try {
            StatisticsRequestDto statisticsRequestDto = new StatisticsRequestDto();

            // Clé BDF : si absente, on reconstruit un substitut minimal (fallback)
            if (StringUtils.isNotBlank(personSearchRequest.getBdfKey())) {
                statisticsRequestDto.setiCleBdf(personSearchRequest.getBdfKey());
            } else {
                String dateCle = "";
                if (StringUtils.isNotBlank(personSearchRequest.getBirthDate())) {
                    String[] split = personSearchRequest.getBirthDate().split("-");
                    dateCle = new StringBuilder()
                            .append(split[2])
                            .append(split[1])
                            .append(split[0].substring(2))
                            .toString();
                }
                String cleBdf = new StringBuilder()
                        .append(dateCle)
                        .append(!StringUtils.isNotBlank(personSearchRequest.getLastname()) ? "" :
                                personSearchRequest.getLastname().length() < 5 ?
                                        personSearchRequest.getLastname() :
                                        personSearchRequest.getLastname().substring(0, 5))
                        .toString();
                statisticsRequestDto.setiCleBdf(cleBdf);
            }

            // Métadonnées de contexte
            statisticsRequestDto.setCcanalOri(channel);
            statisticsRequestDto.setcTypeAppel("FCC");

            // Appelant (tronqué à 8 chars si besoin)
            String tempCaller = caller;
            if (StringUtils.isNotBlank(caller) && caller.length() > 8) {
                tempCaller = caller.substring(0, 8);
            }
            statisticsRequestDto.setcTransApp(tempCaller);

            // Divers champs quantitatifs (null-safe)
            statisticsRequestDto.setiIkpi(Optional.ofNullable(personSearchRequest.getPersonId()).orElse(""));
            statisticsRequestDto.setnCptes(StringUtils.isNotBlank(personSearchRequest.getNbCptesDossier())
                    ? Integer.valueOf(personSearchRequest.getNbCptesDossier()) : 0);
            statisticsRequestDto.setnPersFicp(StringUtils.isNotBlank(personSearchRequest.getNbPersFicp())
                    ? Integer.valueOf(personSearchRequest.getNbPersFicp()) : 0);
            statisticsRequestDto.setcReqTyp(personSearchRequest.getRequestType().toString());
            statisticsRequestDto.setiUserId(userId);

            // Code erreur de la réponse FCC (si présent) ; "0" sinon
            String error = "500";
            if (gppi != null) {
                error = Optional.ofNullable(gppi.getMessage())
                        .map(e -> Optional.ofNullable(e.getErreur())
                                .map(f -> f.getErrCode()).orElse("0"))
                        .orElse("0");
            }
            statisticsRequestDto.setcErrorCode(error);

            // Dates d'insertion / timestamp
            String pattern = "yyyyMMdd";
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern);
            String date = simpleDateFormat.format(new Date());
            statisticsRequestDto.setdInsert(date.toString());
            statisticsRequestDto.setdTimeStamp(LocalDateTime.now().toString());

            // Envoi vers le service de statistiques
            statisticsService.post(statisticsRequestDto);

            // Si l'appel FCC a échoué (gppi null), on le signale par une ApiException
            if (gppi == null) {
                throw new ApiException(1, "pobicall error");
            }
            return "OK";

        } catch (final Exception e) {
            // La collecte des statistiques ne doit pas casser le flux principal
            LOGGER.error("Statistic Service Call Exception", e);
            return "KO";
        }
    }

    /**
     * Orchestration de recherche FCC pour Personnes Morales (PM).
     * - Appel fccClient.searchGlobalPM(bdfKey, immatType, immatId) pour chaque entrée.
     * - Traçabilité statistique.
     * - Mapping réponse -> Personne (PM).
     *
     * @param incidentsSearchRequest entrées (doivent contenir bdfKey + immatType + immatId)
     * @return liste Personne (PM) enrichies depuis FCC
     */
    public List<Personne> searchIncidentMoral(final List<PersonSearchRequest> incidentsSearchRequest,
                                              final String channel,
                                              final String caller,
                                              String userId) {
        final List<Personne> result = new ArrayList<Personne>();
        try {
            for (final PersonSearchRequest personSearchRequest : incidentsSearchRequest) {
                final FCCResponse gppi = fccClient.searchGlobalPM(
                        personSearchRequest.getBdfKey(),
                        personSearchRequest.getImmatType(),
                        personSearchRequest.getImmatId());

                callStaticsService(channel, caller, personSearchRequest, gppi, userId);

                result.addAll(mapFCCResponsePM(gppi, personSearchRequest));
            }
            return result;

        } catch (final ApiException apie) {
            LOGGER.error("API Exception", apie);

            // Messages d'erreur explicites si des champs obligatoires PM sont manquants
            for (final PersonSearchRequest personSearchRequest : incidentsSearchRequest) {
                if (personSearchRequest.getBdfKey() == null) {
                    throw new ApiException(1, "BDF KEY est obligatoire ou mal renseignée pour faire l'appel FCC PM");
                } else if (personSearchRequest.getImmatType() == null) {
                    throw new ApiException(1, "Type Immatriculation est obligatoire ou mal renseignée faire l'appel FCC PM");
                } else if (personSearchRequest.getImmatId() == null) {
                    throw new ApiException(1, "Id Immatriculation est obligatoire ou mal renseignée faire l'appel FCC PM");
                }
            }
            throw new ApiException(1, apie.getMessage());

        } catch (final Exception e) {
            LOGGER.error("Service Call Exception", e);
            throw new ApiException(1, e.getMessage());
        }
    }

    // -------------------------------------------------------------------------
    // NOTE sur mapDetail(...) :
    // La méthode d'origine existe mais est volontairement commentée par l'équipe,
    // en attente d’informations de mapping. On la conserve telle quelle afin de
    // ne pas introduire de comportement partiel/erroné.
    // -------------------------------------------------------------------------

    /*
    private void mapDetail(final Detail detail, final Personne pp) {
        // TODO en attente d'information sur le mapping
        // Exemple (issu du code commenté d'origine) :
        // final String dateOfSubmission = detail.getDetailIJ().getDateExpIJ();
        // pp.setDateOfSubmission(LocalDate.parse(dateOfSubmission));
        // ...
    }
    */
}
