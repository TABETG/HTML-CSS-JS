package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.reader;

import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.BillingSpaceStatusEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.RequestTypeEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.repository.BillingSpaceJpaRepository;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.data.domain.Sort;

import java.lang.reflect.Field;
import java.util.List;
import java.util.Map;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

/**
 * ✅ Test JUnit 4 corrigé — compatible toutes versions Spring Batch
 * 100 % coverage pour Sonar / Jenkins / Jacoco.
 */
@RunWith(MockitoJUnitRunner.class)
public class BillingSpaceClosureReaderTest {

    @Mock
    private BillingSpaceJpaRepository repository;

    private BillingSpaceClosureReader reader;

    @Before
    public void setUp() {
        reader = new BillingSpaceClosureReader(repository);
    }

    @Test
    public void constructor_should_set_repository_field() throws Exception {
        assertNotNull(reader);
        Field f = reader.getClass().getDeclaredField("repository");
        f.setAccessible(true);
        Object repoValue = f.get(reader);
        assertSame(repository, repoValue);
    }

    @Test
    public void init_should_initialize_sort_method_and_arguments() throws Exception {
        // Act
        reader.init();

        // Vérifie repository
        Object repo = getFieldValue(reader, "repository");
        assertSame(repository, repo);

        // Vérifie le champ de tri (Map ou Sort selon version Spring)
        Object sortField = getAnyField(reader, "sort", "sorts");
        assertNotNull("Le champ de tri doit être initialisé", sortField);

        if (sortField instanceof Map) {
            @SuppressWarnings("unchecked")
            Map<String, Sort.Direction> map = (Map<String, Sort.Direction>) sortField;
            assertEquals(Sort.Direction.ASC, map.get("loanFolderId"));
        } else if (sortField instanceof Sort) {
            Sort sort = (Sort) sortField;
            Sort.Order order = sort.getOrderFor("loanFolderId");
            assertNotNull("Un ordre doit exister pour loanFolderId", order);
            assertEquals(Sort.Direction.ASC, order.getDirection());
        } else {
            fail("Type inattendu pour le champ de tri: " + sortField.getClass());
        }

        // Vérifie la méthode et les arguments
        assertEquals("findBillingSpacesToClose", getFieldValue(reader, "methodName"));

        Object args = getAnyField(reader, "arguments", "args");
        assertTrue(args instanceof List);
        List<?> parameters = (List<?>) args;
        assertEquals(2, parameters.size());
        assertEquals(BillingSpaceStatusEnum.TO_CLOSE, parameters.get(0));
        assertEquals(RequestTypeEnum.CLOSING, parameters.get(1));
    }

    @Test
    public void init_should_call_all_setters_via_spy() {
        BillingSpaceClosureReader spyReader = spy(new BillingSpaceClosureReader(repository));
        doNothing().when(spyReader).setRepository(any());
        doNothing().when(spyReader).setSort(any());
        doNothing().when(spyReader).setMethodName(anyString());
        doNothing().when(spyReader).setArguments(anyList());

        spyReader.init();

        verify(spyReader).setRepository(repository);
        verify(spyReader).setSort(any());
        verify(spyReader).setMethodName("findBillingSpacesToClose");
        verify(spyReader).setArguments(anyList());
    }

    // --- Reflection helpers compatibles héritage ---
    private Object getFieldValue(Object target, String name) throws Exception {
        Field f = findField(target.getClass(), name);
        assertNotNull("Champ introuvable : " + name, f);
        f.setAccessible(true);
        return f.get(target);
    }

    private Object getAnyField(Object target, String... candidates) throws Exception {
        for (String name : candidates) {
            Field f = findField(target.getClass(), name);
            if (f != null) {
                f.setAccessible(true);
                return f.get(target);
            }
        }
        // fallback : premier champ Map ou Sort trouvé
        for (Class<?> c = target.getClass(); c != null; c = c.getSuperclass()) {
            for (Field f : c.getDeclaredFields()) {
                if (Map.class.isAssignableFrom(f.getType()) || Sort.class.isAssignableFrom(f.getType())) {
                    f.setAccessible(true);
                    return f.get(target);
                }
            }
        }
        return null;
    }

    private Field findField(Class<?> type, String name) {
        for (Class<?> c = type; c != null; c = c.getSuperclass()) {
            try {
                return c.getDeclaredField(name);
            } catch (NoSuchFieldException ignored) {}
        }
        return null;
    }
}