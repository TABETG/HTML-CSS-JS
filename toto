package com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.tasklet;

import com.bnpparibas.dsibddf.ap00420.streamfact.application.cos.CosService;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.core.ExitStatus;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.test.util.ReflectionTestUtils;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.mockito.Mockito.*;

/**
 * Tests JUnit 4 pour SendToBMDUploadCOSTasklet.
 *
 * Objectifs de couverture :
 *  - afterPropertiesSet() : pas d'effet attendu (aucune exception).
 *  - execute() en mode mock (mock=true) : FINISHED sans appel au CosService.
 *  - execute() en mode réel (mock=false) avec succès : appel COS et ExitStatus.COMPLETED.
 *  - execute() en mode réel (mock=false) avec exception : ExitStatus.FAILED.
 *
 * Contraintes :
 *  - JUnit 4 uniquement (org.junit.*).
 *  - Mockito runner : @RunWith(MockitoJUnitRunner.class).
 *  - Pas de Jupiter, pas d'AssertJ.
 *  - verifyNoInteractions(...) au lieu de verifyZeroInteractions(...).
 */
@RunWith(MockitoJUnitRunner.class)
public class SendToBMDUploadCOSTaskletTest {

    /** SUT : le tasklet à tester. */
    @InjectMocks
    private SendToBMDUploadCOSTasklet tasklet;

    /** Dépendance externe simulée : service COS. */
    @Mock
    private CosService cosService;

    /** Contexte réel Spring Batch pour valider les ExitStatus. */
    private StepExecution stepExecution;
    private StepContribution contribution;

    /**
     * Prépare un StepExecution/Contribution réels pour que le tasklet
     * puisse poser un ExitStatus sans qu'on ait à le simuler.
     */
    @Before
    public void setUp() {
        JobExecution jobExecution = new JobExecution(1L);
        stepExecution = new StepExecution("sendToBMDUpload", jobExecution);
        contribution = new StepContribution(stepExecution);
    }

    /**
     * afterPropertiesSet() : la classe déclare "Nothing to do",
     * l'appel ne doit produire aucune exception ni effet. 
     * (Couverture simple de la méthode.) 
     */
    @Test
    public void afterPropertiesSet_should_do_nothing() throws Exception {
        tasklet.afterPropertiesSet();
    }

    /**
     * Branche mock=true :
     *  - Le nom de fichier est lu dans le JobExecutionContext sous "encryptedFileName".
     *  - Aucune interaction avec CosService n'est attendue.
     *  - Le tasklet doit renvoyer RepeatStatus.FINISHED.
     */
    @Test
    public void execute_when_mock_true_should_finish_without_cos_call() throws Exception {
        // Injection des propriétés
        ReflectionTestUtils.setField(tasklet, "mock", true);
        ReflectionTestUtils.setField(tasklet, "pathGenerateFile", "/tmp");
        ReflectionTestUtils.setField(tasklet, "prefix", "arch-");
        // La classe lit "encryptedFileName" depuis le JobExecutionContext
        putEncryptedFileNameInContext("file.enc");

        ChunkContext chunkContext = new ChunkContext(new StepContext(stepExecution));

        RepeatStatus status = tasklet.execute(contribution, chunkContext);

        assertEquals(RepeatStatus.FINISHED, status);
        verifyNoInteractions(cosService); // pas d'appel en mode mock
    }

    /**
     * Branche mock=false avec succès :
     *  - Appel à cosService.pushArchiveFileToNewCOS(path, fileName, prefix)
     *    tel que défini dans la classe métier.
     *  - ExitStatus posé à COMPLETED sur le StepExecution.
     *  - RepeatStatus reste FINISHED.
     */
    @Test
    public void execute_when_mock_false_and_push_ok_should_set_completed() throws Exception {
        ReflectionTestUtils.setField(tasklet, "mock", false);
        ReflectionTestUtils.setField(tasklet, "pathGenerateFile", "/opt/export");
        ReflectionTestUtils.setField(tasklet, "prefix", "bkp-");
        putEncryptedFileNameInContext("daily.enc");

        ChunkContext chunkContext = new ChunkContext(new StepContext(stepExecution));

        RepeatStatus status = tasklet.execute(contribution, chunkContext);

        assertEquals(RepeatStatus.FINISHED, status);
        assertEquals(ExitStatus.COMPLETED, stepExecution.getExitStatus());
        verify(cosService, times(1)).pushArchiveFileToNewCOS("/opt/export", "daily.enc", "bkp-");
        verifyNoMoreInteractions(cosService);
    }

    /**
     * Branche mock=false avec exception lors du push :
     *  - Si CosService lève une exception, le tasklet doit poser ExitStatus.FAILED.
     *  - L'exécution du tasklet termine tout de même en FINISHED (contrat d'un Tasklet).
     */
    @Test
    public void execute_when_mock_false_and_push_throws_should_set_failed() throws Exception {
        ReflectionTestUtils.setField(tasklet, "mock", false);
        ReflectionTestUtils.setField(tasklet, "pathGenerateFile", "/data/out");
        ReflectionTestUtils.setField(tasklet, "prefix", "pref-");
        putEncryptedFileNameInContext("broken.enc");

        // Simulation de panne du service COS
        doThrow(new RuntimeException("cos down"))
                .when(cosService).pushArchiveFileToNewCOS("/data/out", "broken.enc", "pref-");

        ChunkContext chunkContext = new ChunkContext(new StepContext(stepExecution));

        RepeatStatus status = tasklet.execute(contribution, chunkContext);

        assertEquals(RepeatStatus.FINISHED, status);
        assertEquals(ExitStatus.FAILED, stepExecution.getExitStatus());
        verify(cosService, times(1)).pushArchiveFileToNewCOS("/data/out", "broken.enc", "pref-");
        verifyNoMoreInteractions(cosService);
    }

    /**
     * Place la valeur attendue par le tasklet dans le JobExecutionContext,
     * sous la clé "encryptedFileName".
     * La classe sous test récupère exactement cette clé au début de execute().
     */
    private void putEncryptedFileNameInContext(String fileName) {
        assertNotNull(stepExecution);
        assertNotNull(stepExecution.getJobExecution());
        stepExecution.getJobExecution().getExecutionContext().put("encryptedFileName", fileName);
    }
}