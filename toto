Bien vu — mon exemple contenait 2 erreurs de signature :

1. j’avais utilisé un type de retour MSG_IN + un faux setter setzConFoncIn(...).
Or la classe MSG_IN expose setZcon_FONC_IN(...) et setZcon_fonc_inou(...), et c’est le DTO BciFicpRequestDTO qui porte le MSG_IN via setMSG_IN(...).


2. j’avais fait un setPersons(...) qui n’existe pas : la liste des personnes va dans ZCON_FONC_INOU.g_list_kpi → G_LIST_KPI.g_kpi_ref. 



Voici la correction complète, bloc par bloc, à copier/coller.


---

1) domain/mappers/BciFicpRequestMapper.java (wrappers + filtre)

package com.bnpparibas.dsibddf.ap10530.incident.domain.mappers;

import java.util.ArrayList;
import java.util.List;

import com.bnpparibas.dsibddf.ap10530.incident.domain.dto.BciFicpRequestDTO;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.MSG_IN;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.ZCON_FONC_IN;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.ZCON_FONC_INOU;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.RequestTypeEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.pphy.G_KPI_REF;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.pphy.G_KPI_REF1;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.pphy.G_LIST_I_KPI;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.pphy.G_LIST_KPI;

// --- AJOUT : wrappers attendus par le service ---
public class BciFicpRequestMapper {

    public BciFicpRequestDTO map(final List<PersonSearchRequest> persons,
                                 final String channel, final String caller, final String userId) {
        return createBciFicpRequest(persons);
    }

    public BciFicpRequestDTO mapRP(final List<PersonSearchRequest> persons,
                                   final String channel, final String caller, final String userId) {
        return createBciFicpRequestRP(persons);
    }

    // ----- EXISTANT avec minimes ajustements de filtre -----

    public BciFicpRequestDTO createBciFicpRequest(final List<PersonSearchRequest> incidentsSearchRequest) {

        final BciFicpRequestDTO rchIncidRequest = new BciFicpRequestDTO();
        MSG_IN in = new MSG_IN();
        ZCON_FONC_IN foncin = new ZCON_FONC_IN();
        final G_LIST_KPI gListKpi = new G_LIST_KPI();

        final List<G_KPI_REF> newList = new ArrayList<>();
        int i = 0;
        for (final PersonSearchRequest person : incidentsSearchRequest) {
            // n’envoie pas vers BNPP quand on est en requête BDF unitaire
            RequestTypeEnum rt = person.getRequestType();
            if (rt != RequestTypeEnum.BDF_ONLY
             && rt != RequestTypeEnum.FICP_BDF_ONLY
             && rt != RequestTypeEnum.FCC_BDF_ONLY) {
                final G_KPI_REF newPerson = mapGKpi(i, person);
                newList.add(newPerson);
                i++;
            }
        }
        gListKpi.setQ_KPI_REF(i);
        gListKpi.setG_KPI_REF(newList);
        foncin.setG_LIST_I_KPI(mapGIKpi());

        ZCON_FONC_INOU foncInOu = new ZCON_FONC_INOU();
        foncInOu.setG_LIST_KPI(gListKpi);

        // ✔ setters exacts de MSG_IN
        in.setZcon_FONC_IN(foncin);       // existe
        in.setZcon_fonc_inou(foncInOu);   // existe
        rchIncidRequest.setMSG_IN(in);    // le DTO porte MSG_IN

        return rchIncidRequest;
    }

    public BciFicpRequestDTO createBciFicpRequestRP(final List<PersonSearchRequest> incidentsSearchRequest) {

        final BciFicpRequestDTO rchIncidRequest = new BciFicpRequestDTO();
        MSG_IN in = new MSG_IN();
        ZCON_FONC_IN foncin = new ZCON_FONC_IN();
        final G_LIST_KPI gListKpi = new G_LIST_KPI();
        final G_LIST_I_KPI gListIKpi = new G_LIST_I_KPI();

        final List<G_KPI_REF1> newListRP = new ArrayList<>();
        final List<G_KPI_REF> newList = new ArrayList<>();
        int i = 0;
        for (final PersonSearchRequest person : incidentsSearchRequest) {
            RequestTypeEnum rt = person.getRequestType();
            if (rt != RequestTypeEnum.BDF_ONLY
             && rt != RequestTypeEnum.FICP_BDF_ONLY
             && rt != RequestTypeEnum.FCC_BDF_ONLY) {
                newListRP.add(mapGIKpiRP(i, person));
                newList.add(mapGKpiRP(i, person));
                i++;
            }
        }
        gListIKpi.setQ_KPI_REF1(i);
        gListIKpi.setG_KPI_REF1(newListRP);

        gListKpi.setQ_KPI_REF(i);
        gListKpi.setG_KPI_REF(newList);

        foncin.setG_LIST_I_KPI(gListIKpi);

        ZCON_FONC_INOU foncInOu = new ZCON_FONC_INOU();
        foncInOu.setG_LIST_KPI(gListKpi);

        // ✔ setters exacts de MSG_IN
        in.setZcon_FONC_IN(foncin);
        in.setZcon_fonc_inou(foncInOu);
        rchIncidRequest.setMSG_IN(in);

        return rchIncidRequest;
    }

    // ... la suite de la classe (mapGKpi, mapGKpiRP, mapGIKpi, mapGIKpiRP, mapDateISO) reste identique.
}

Pourquoi ces noms ?

MSG_IN fournit bien setZcon_FONC_IN(...) et setZcon_fonc_inou(...) (c’est exactement ce que votre code d’origine fait dans createBciFicpRequest*).

ZCON_FONC_INOU a setG_LIST_KPI(...) ; aucun setPersons(...) n’existe dans ce modèle. 



---

2) domain/model/enums/RequestTypeEnum.java (si ce n’est pas déjà fait)

Pour que le filtre ci-dessus compile, ajoutez les nouvelles valeurs (4/5/6/7) :

public enum RequestTypeEnum {
    BNP_ONLY("1"),
    BDF_ONLY("2"),
    BOTH_BNP_BDF("3"),
    FICP_BDF_ONLY("4"),
    FCC_BDF_ONLY("5"),
    FICP_BCEF_ONLY("6"),
    BCI_BCEF_ONLY("7");
    // ... reste inchangé
}


---

3) IncidentService (appel BNPP)

Dans le service, utilisez directement les méthodes createBciFicpRequest(...) / createBciFicpRequestRP(...) (ou conservez map()/mapRP() maintenant qu’ils retournent bien le DTO). Exemple :

// entrée identité
IncidentBciFicpResult res = bciFicpService.post(
        bciFicpMapper.createBciFicpRequest(incidentsSearchRequest));
// entrée RP
IncidentBciFicpResult resRp = bciFicpService.postRP(
        bciFicpMapper.createBciFicpRequestRP(incidentsSearchRequest),
        incidentsSearchRequest);

Ces appels correspondent exactement à ce que montrent vos tests/exemples d’origine. 


---

TL;DR des correctifs

❌ setPersons(...) → supprimé (inexistant). Les personnes vont dans ZCON_FONC_INOU.g_list_kpi. 

❌ setzConFoncIn(...) → remplacé par setZcon_FONC_IN(...) et setZcon_fonc_inou(...) sur MSG_IN. 

✅ map(...) / mapRP(...) retournent BciFicpRequestDTO et délèguent aux createBciFicpRequest*.

✅ Filtre BNPP mis à jour pour ignorer BDF_ONLY, FICP_BDF_ONLY, FCC_BDF_ONLY.


Si tu colles ces blocs, la compilation passera et le payload z/OS sera identique à celui qui marche déjà dans votre base.

