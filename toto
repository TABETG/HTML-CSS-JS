package com.bnpparibas.dsibddf.ap00420.streamfact.batch.maestrostatuspaymentrequest.writer;

import com.bnpparibas.dsibddf.ap00420.streamfact.batch.maestrostatuspaymentrequest.MaestroStatusPaymentRequestConfiguration;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.MaestroPaymentRequestStatusEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.MaestroPaymentRequestEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.repository.MaestroPaymentRequestJpaRepository;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
    import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.item.Chunk;
import org.springframework.test.util.ReflectionTestUtils;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

@RunWith(MockitoJUnitRunner.class)
public class MajReglementNonConformeWriterTest {

    private MajReglementNonConformeWriter writer;

    @Mock
    private MaestroPaymentRequestJpaRepository maestroPaymentRequestJpaRepository;

    @Before
    public void setUp() {
        MaestroStatusPaymentRequestConfiguration.cptprupd = 0;
        writer = new MajReglementNonConformeWriter();
        ReflectionTestUtils.setField(writer, "maestroPaymentRequestJpaRepository", maestroPaymentRequestJpaRepository);
    }

    @Test
    public void write_should_update_status_and_date_save_each_and_increment_counter_per_item() throws Exception {
        MaestroPaymentRequestEntity e1 = mock(MaestroPaymentRequestEntity.class);
        MaestroPaymentRequestEntity e2 = mock(MaestroPaymentRequestEntity.class);
        List<MaestroPaymentRequestEntity> items = Arrays.asList(e1, e2);
        Chunk<MaestroPaymentRequestEntity> chunk = new Chunk<MaestroPaymentRequestEntity>(items);

        writer.write(chunk);

        String expectedLabel = MaestroPaymentRequestStatusEnum.PAYMENT_REQUEST_UPDATED.getLabel();
        verify(e1).setStatus(expectedLabel);
        verify(e2).setStatus(expectedLabel);

        ArgumentCaptor<LocalDateTime> c1 = ArgumentCaptor.forClass(LocalDateTime.class);
        ArgumentCaptor<LocalDateTime> c2 = ArgumentCaptor.forClass(LocalDateTime.class);
        verify(e1).setUpdateDate(c1.capture());
        verify(e2).setUpdateDate(c2.capture());
        assertNotNull(c1.getValue());
        assertEquals(c1.getValue(), c2.getValue());

        verify(maestroPaymentRequestJpaRepository).save(e1);
        verify(maestroPaymentRequestJpaRepository).save(e2);
        verifyNoMoreInteractions(maestroPaymentRequestJpaRepository);

        // Typage explicite
        assertEquals(2, (int) MaestroStatusPaymentRequestConfiguration.cptprupd);
    }

    @Test
    public void write_should_do_nothing_and_not_touch_counter_when_chunk_is_empty() throws Exception {
        Chunk<MaestroPaymentRequestEntity> empty =
                new Chunk<MaestroPaymentRequestEntity>(Collections.<MaestroPaymentRequestEntity>emptyList());

        writer.write(empty);

        verifyNoInteractions(maestroPaymentRequestJpaRepository);
        // Typage explicite
        assertEquals(0, (int) MaestroStatusPaymentRequestConfiguration.cptprupd);
    }
}