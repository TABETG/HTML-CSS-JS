package com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.tasklet;

import com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.service.batch.security.openpgp.OnePassSignatureProcessor;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.service.batch.security.openpgp.PartnerPublicKeyPair;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.service.batch.security.openpgp.PrivateKeyPair;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentMatchers;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.UnexpectedJobExecutionException;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.scope.context.StepContext;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.List;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

/**
 * Tests JUnit 4 pour la classe CypherPGPTasklet.
 *
 * Objectifs de couverture (100 %) :
 *  - afterPropertiesSet() : méthode sans effet (no-op).
 *  - initializeValues() : construction des chemins et sélection des secrets (keystore prioritaire).
 *  - execute() :
 *       * mock == true  -> aucun appel au processeur, FINISHED.
 *       * mock == false -> succès : appel encryptOnePassSignature(...), FINISHED.
 *       * mock == false -> exception IOException : levée en UnexpectedJobExecutionException.
 *  - checkParameters() :
 *       * needSignature == true sans privateKey/passphrase -> IllegalArgumentException.
 *
 * Contraintes :
 *  - JUnit 4 uniquement (org.junit.*).
 *  - Mockito JUnit 4 runner (@RunWith(MockitoJUnitRunner.class)).
 *  - Pas d’AssertJ, pas de JUnit Jupiter.
 *  - verifyNoInteractions(...) au lieu de verifyZeroInteractions(...).
 */
@RunWith(MockitoJUnitRunner.class)
public class CypherPGPTaskletTest {

    /** SUT : le tasklet à tester. */
    @InjectMocks
    private CypherPGPTasklet tasklet;

    /** Dépendance de chiffrement PGP simulée. */
    @Mock
    private OnePassSignatureProcessor onePassSignatureProcessor;

    /** Contexte Spring Batch réel pour valider ExitStatus et RepeatStatus. */
    private StepExecution stepExecution;
    private StepContribution contribution;

    @Before
    public void setUp() {
        JobExecution jobExecution = new JobExecution(1L);
        stepExecution = new StepExecution("cypherPgpStep", jobExecution);
        contribution = new StepContribution(stepExecution);
    }

    /**
     * Vérifie que la méthode d'initialisation ne produit aucun effet ni exception.
     */
    @Test
    public void afterPropertiesSet_should_do_nothing() throws Exception {
        tasklet.afterPropertiesSet();
    }

    /**
     * Vérifie la construction des champs par initializeValues(...) :
     *  - priorisation du keystore (privateKeyStorePath) par rapport à privateKeyPath.
     *  - passphrase choisie en cohérence (keystorePassphrase prioritaire).
     *  - construction des chemins complet pour originalFilePath et encryptedFilePath.
     */
    @Test
    public void initializeValues_should_set_paths_and_secrets_from_context() {
        // Contexte : noms de fichiers fournis par un step précédent
        putInContext("originalFileName", "in.txt");
        putInContext("encryptedFileName", "in.txt.pgp");

        // Propriétés : keystore présent -> prime sur privateKeyPath
        ReflectionTestUtils.setField(tasklet, "filePath", "/base/");
        ReflectionTestUtils.setField(tasklet, "privateKeyStorePath", "/keys/keystore.p12");
        ReflectionTestUtils.setField(tasklet, "privateKeyPath", "/keys/private.asc");
        ReflectionTestUtils.setField(tasklet, "keystorePassphrase", "storePass");
        ReflectionTestUtils.setField(tasklet, "keyPassphrase", "keyPass");

        // Appel de l'initialisation
        tasklet.initializeValues(new ChunkContext(new StepContext(stepExecution)));

        // Vérifications : keystore prioritaire
        assertEquals("/keys/keystore.p12", ReflectionTestUtils.getField(tasklet, "privateKeyPath"));
        assertEquals("storePass", ReflectionTestUtils.getField(tasklet, "passphrase"));

        // Chemins d'entrée/sortie
        assertEquals("/base/in.txt", ReflectionTestUtils.getField(tasklet, "originalFilePath"));
        assertEquals("/base/in.txt.pgp", ReflectionTestUtils.getField(tasklet, "encryptedFilePath"));
    }

    /**
     * Branche mock=true :
     *  - aucune interaction avec le processeur PGP,
     *  - RepeatStatus.FINISHED attendu.
     */
    @Test
    public void execute_when_mock_true_should_finish_without_encrypt_call() throws Exception {
        ReflectionTestUtils.setField(tasklet, "mock", true);
        ReflectionTestUtils.setField(tasklet, "filePath", "/tmp/");
        putInContext("originalFileName", "a.csv");
        putInContext("encryptedFileName", "a.csv.pgp");

        RepeatStatus status = tasklet.execute(contribution, new ChunkContext(new StepContext(stepExecution)));

        assertEquals(RepeatStatus.FINISHED, status);
        verifyNoInteractions(onePassSignatureProcessor);
    }

    /**
     * Branche mock=false, needSignature=false :
     *  - succès de l'appel encryptOnePassSignature(...),
     *  - RepeatStatus.FINISHED attendu,
     *  - vérification des paramètres transmis (chemins, flags).
     */
    @Test
    public void execute_when_mock_false_and_no_signature_success_should_finish_and_call_encrypt() throws Exception {
        // Configuration du tasklet
        ReflectionTestUtils.setField(tasklet, "mock", false);
        ReflectionTestUtils.setField(tasklet, "needSignature", false); // pas d'exigence de clé privée
        ReflectionTestUtils.setField(tasklet, "useTextMode", true);
        ReflectionTestUtils.setField(tasklet, "amor", true);
        ReflectionTestUtils.setField(tasklet, "filePath", "/data/");
        ReflectionTestUtils.setField(tasklet, "partnerPublicKeyPath", "/keys/partner.pub");
        ReflectionTestUtils.setField(tasklet, "renewedPartnerPublicKeyPath", "/keys/partner2.pub");

        // Contexte
        putInContext("originalFileName", "report.json");
        putInContext("encryptedFileName", "report.json.pgp");

        // Exécution
        RepeatStatus status = tasklet.execute(contribution, new ChunkContext(new StepContext(stepExecution)));

        // Vérifications
        assertEquals(RepeatStatus.FINISHED, status);

        verify(onePassSignatureProcessor, times(1)).encryptOnePassSignature(
                // Chemin de sortie (fichier chiffré), puis chemin d'entrée (fichier clair)
                eq("/data/report.json.pgp"),
                eq("/data/report.json"),
                // Matcher typé : List<PartnerPublicKeyPair>
                org.mockito.Mockito.<List<PartnerPublicKeyPair>>any(),
                // Paire de clés privées construite par le tasklet (peut être null si needSignature=false)
                any(PrivateKeyPair.class),
                eq(false), // needSignature
                eq(true),  // useTextMode
                eq(true)   // amor
        );
        verifyNoMoreInteractions(onePassSignatureProcessor);
    }

    /**
     * Branche mock=false, needSignature=true :
     *  - le processeur lève IOException,
     *  - le tasklet doit encapsuler en UnexpectedJobExecutionException.
     */
    @Test(expected = UnexpectedJobExecutionException.class)
    public void execute_when_mock_false_with_signature_and_encrypt_throws_should_wrap_exception() throws Exception {
        // Le fait d'exiger une signature impose la présence d'une clé privée et de sa passphrase
        ReflectionTestUtils.setField(tasklet, "mock", false);
        ReflectionTestUtils.setField(tasklet, "needSignature", true);
        ReflectionTestUtils.setField(tasklet, "filePath", "/secure/");
        ReflectionTestUtils.setField(tasklet, "partnerPublicKeyPath", "/keys/partner.pub");
        ReflectionTestUtils.setField(tasklet, "renewedPartnerPublicKeyPath", "/keys/partner2.pub");
        // Sélection keystore prioritaire
        ReflectionTestUtils.setField(tasklet, "privateKeyStorePath", "/keys/keystore.p12");
        ReflectionTestUtils.setField(tasklet, "keystorePassphrase", "storePass");

        putInContext("originalFileName", "x.txt");
        putInContext("encryptedFileName", "x.txt.pgp");

        // Le processeur lève une IOException -> le tasklet doit wrapper en UnexpectedJobExecutionException
        doThrow(new IOException("IO error")).when(onePassSignatureProcessor).encryptOnePassSignature(
                anyString(),
                anyString(),
                // Matcher typé : List<PartnerPublicKeyPair>
                org.mockito.Mockito.<List<PartnerPublicKeyPair>>any(),
                any(PrivateKeyPair.class),
                anyBoolean(),
                anyBoolean(),
                anyBoolean()
        );

        tasklet.execute(contribution, new ChunkContext(new StepContext(stepExecution)));
    }

    /**
     * checkParameters() : needSignature=true mais privateKeyPath/passphrase manquants -> IllegalArgumentException.
     * Appel via réflexion si la méthode n'est pas publique.
     */
    @Test(expected = IllegalArgumentException.class)
    public void checkParameters_should_require_privateKey_and_passphrase_when_needSignature_true() {
        // Champs nécessaires pour passer les autres validations
        ReflectionTestUtils.setField(tasklet, "needSignature", true);
        ReflectionTestUtils.setField(tasklet, "onePassSignatureProcessor", onePassSignatureProcessor);
        ReflectionTestUtils.setField(tasklet, "encryptedFilePath", "/f.enc");
        ReflectionTestUtils.setField(tasklet, "originalFilePath", "/f.txt");
        ReflectionTestUtils.setField(tasklet, "partnerPublicKeyPath", "/keys/partner.pub");
        // Volontairement absents
        ReflectionTestUtils.setField(tasklet, "privateKeyPath", null);
        ReflectionTestUtils.setField(tasklet, "passphrase", null);

        // Appel direct si la méthode est visible, sinon réflexion
        try {
            Method m = CypherPGPTasklet.class.getDeclaredMethod("checkParameters");
            m.setAccessible(true);
            m.invoke(tasklet);
        } catch (InvocationTargetException ite) {
            // Rélève la cause réelle (IllegalArgumentException attendue)
            if (ite.getCause() instanceof RuntimeException) {
                throw (RuntimeException) ite.getCause();
            }
            throw new RuntimeException(ite.getCause());
        } catch (NoSuchMethodException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    /* ======================= Utilitaires ======================= */

    /**
     * Place une clé/valeur dans le JobExecutionContext du step en cours,
     * utilisé ici pour fournir "originalFileName" et "encryptedFileName".
     */
    private void putInContext(String key, String value) {
        assertNotNull(stepExecution);
        assertNotNull(stepExecution.getJobExecution());
        stepExecution.getJobExecution().getExecutionContext().put(key, value);
    }
}