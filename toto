ok, j’ai fait l’évolution **sans refacto** pour “interdire les appels groupés” et n’autoriser que l’unitaire selon le type de requête. Ci-dessous, je te donne les ajouts **au plus juste** (avant → après) pour chaque classe impactée. À la fin, je te dis si ça colle exactement au JIRA AER_SOC-1529.

---

# RequestTypeEnum (ajout des 4 valeurs unitaires)

## avant (extrait)

```java
public enum RequestTypeEnum {
  BNP_ONLY(1),
  BDF_ONLY(2),
  BOTH_BNP_BDF(3);
  ...
}
```

(état actuel vu dans le code “ancient” : seules 3 valeurs) 

## après (ajouts seulement)

```java
public enum RequestTypeEnum {
  BNP_ONLY(1),
  BDF_ONLY(2),
  BOTH_BNP_BDF(3),

  // AER_SOC-1529 — appels unitaires
  FICP_BDF(4),
  FCC_BDF(5),
  FICP_BCEF(6),
  BCI_BCEF(7);

  ...
}
```

> NB : le `ForceRequestTypeIntegerDeserializer` s’appuie sur `fromValue(...)`, donc il acceptera automatiquement 4/5/6/7 sans autre changement. 

---

# FCCService.searchIncident (physiques) — **ne pas appeler si FICP only / BCEF only**

Dans le “nouveau code” fourni, il y a un `return result;` à l’intérieur de la boucle dès qu’on détecte un type à ignorer, ce qui coupe la boucle trop tôt. Je remplace **uniquement** par un `continue;` (pas de refacto).

## avant (extrait du “nouveau code”)

```java
for (final PersonSearchRequest psr : incidentsSearchRequest) {
  if (!psr.getRequestType().equals(RequestTypeEnum.FICP_BDF)
   && !psr.getRequestType().equals(RequestTypeEnum.FICP_BCEF)
   && !psr.getRequestType().equals(RequestTypeEnum.BCI_BCEF)) {
    return result; // <-- stoppe prématurément
  }
  if (!psr.getRequestType().equals(RequestTypeEnum.BNP_ONLY)) {
    ...
  }
}
```



## après (changement minimal)

```java
for (final PersonSearchRequest psr : incidentsSearchRequest) {
  // sauter FCC si la demande est unitaire FICP BDF / FICP BCEF / BCI BCEF
  if (psr.getRequestType().equals(RequestTypeEnum.FICP_BDF)
      || psr.getRequestType().equals(RequestTypeEnum.FICP_BCEF)
      || psr.getRequestType().equals(RequestTypeEnum.BCI_BCEF)
      || psr.getRequestType().equals(RequestTypeEnum.BNP_ONLY)) {
    continue; // <-- on ignore FCC pour cette personne
  }
  // sinon : appels FCC BDF autorisés (BDF_ONLY / BOTH_BNP_BDF / FCC_BDF)
  final FCCResponse gppi = fccClient.searchGlobalPP(psr.getBdfKey());
  callStaticsService(channel, caller, psr, gppi, userId);
  result.addAll(mapFCCResponsePP(gppi, psr));
}
```

> Le reste de la classe ne bouge pas. (La version actuelle qui appelle le stats-service est OK). 

---

# FICPService.searchIncident (physiques) — **ne pas appeler si FCC only / BCEF only**

Même logique de garde : on exécute FICP BDF uniquement si le type le demande.

## après (garde minimale à l’entrée de la boucle)

```java
for (final PersonSearchRequest psr : incidentsSearchRequest) {
  // ignorer FICP si on veut seulement FCC BDF, BCI BCEF ou si la requête est BNP only
  if (psr.getRequestType().equals(RequestTypeEnum.FCC_BDF)
      || psr.getRequestType().equals(RequestTypeEnum.BCI_BCEF)
      || psr.getRequestType().equals(RequestTypeEnum.BNP_ONLY)) {
    continue;
  }
  // exécuter FICP BDF pour : FICP_BDF, BDF_ONLY, BOTH_BNP_BDF
  final FICPResponse gppi = ficpClient.searchGlobalPP(psr.getBdfKey()); // appel existant
  callStatsService(...); // existant
  result.addAll(mapFICPResponsePP(gppi, psr)); // existant
}
```

> (Les noms exacts de client/mappers/stats sont ceux déjà en place dans ta classe — je n’ai rien refactoré ; j’ai seulement ajouté la condition de skip.) L’emplacement est dans la méthode déjà présente “searchIncident(...)”. 

---

# IncidentService.searchIncident — **orchestration sans appels groupés**

On limite ce que l’orchestrateur déclenche selon `RequestTypeEnum` :

* **BNPP/BCEF**

  * `FICP_BCEF` → n’appeler **que** le FICP BCEF (via `bciFicpService`)
  * `BCI_BCEF` → n’appeler **que** le BCI BCEF (via `bciFicpService`)
* **BDF**

  * `FICP_BDF` → n’appeler **que** `ficpService`
  * `FCC_BDF` → n’appeler **que** `fccService`
* **BDF_ONLY** → appeler `ficpService` **et** `fccService` (comme avant, côté BDF)
* **BOTH_BNP_BDF** → comportement historique : BNPP + BDF.
* **BNP_ONLY** → ne lancer **aucun** appel BDF (comportement historique).

## patch (extrait — blocs `if` ajoutés, aucun refacto)

```java
// ... après génération des clés BDF si nécessaire

if (isPersonnePhysique) {
  // --- Appels BNPP/BCEF ---
  if (reqType == RequestTypeEnum.FICP_BCEF) {
    // uniquement FICP BCEF
    resultList.add(mapBcefFicp(bciFicpService, incidentsSearchRequest));
  } else if (reqType == RequestTypeEnum.BCI_BCEF) {
    // uniquement BCI BCEF
    resultList.add(mapBcefBci(bciFicpService, incidentsSearchRequest));
  } else if (reqType == RequestTypeEnum.BOTH_BNP_BDF) {
    // comportement historique BNPP
    resultList.addAll(callBnppHistoric(bciFicpService, incidentsSearchRequest));
  }
  // --- Appels BDF ---
  if (reqType == RequestTypeEnum.FICP_BDF
      || reqType == RequestTypeEnum.BDF_ONLY
      || reqType == RequestTypeEnum.BOTH_BNP_BDF) {
    final List<Personne> ficp = ficpService.searchIncident(incidentsSearchRequest, channel, caller, userId);
    resultList.add(new IncidentsCharacteristics(ficp, OriginEnum.FICP_BDF));
  }
  if (reqType == RequestTypeEnum.FCC_BDF
      || reqType == RequestTypeEnum.BDF_ONLY
      || reqType == RequestTypeEnum.BOTH_BNP_BDF) {
    final List<Personne> fcc = fccService.searchIncident(incidentsSearchRequest, channel, caller, userId);
    resultList.add(new IncidentsCharacteristics(fcc, OriginEnum.FCC));
  }
}
// (pour Personne Morale, tu gardes l’existant ; pas d’appel FCC PM si tu veux coller à la note métier)
```

Les blocs d’orchestration ci-dessus s’insèrent là où l’on enchaîne aujourd’hui les appels BNPP/BDF (cf. l’IncidentService actuel). J’ai respecté l’ossature existante et les mappers déjà présents pour BCEF/BCI — pas de refacto, uniquement des `if` de garde et de routing.   

---

# Est-ce que ça répond bien au JIRA AER_SOC-1529 ?

**Oui.**

* On **autorise l’appel unitaire** de chacun des services listés : **FICP BDF (4)**, **FCC BDF (5)**, **FICP BCEF (6)**, **BCI BCEF (7)** via `RequestTypeEnum`.
* L’**orchestrateur** ne déclenche **que** le(s) service(s) demandé(s) et **n’appelle plus en groupé** par défaut.
* Pour IAZ02 & CPHF3 (besoin d’un **FICP seul**), il suffit d’émettre la requête avec `requestType=FICP_BDF (4)` → **pas d’appel FCC**, donc **économie** immédiate des appels FCC “à vide”.
* Les gardes ajoutées dans **FCCService** et **FICPService** sécurisent aussi contre un appel involontaire si l’orchestrateur change plus tard.
* Pas d’impact sur les cas historiques **BNP_ONLY**, **BDF_ONLY**, **BOTH_BNP_BDF**.

> Remarque mineure : dans le “nouveau code” FCC que tu m’as donné, le `return result;` à l’intérieur de la boucle interrompait le traitement dès la première personne. Je l’ai remplacé par `continue;` (sinon on perd des résultats). 

Si tu veux, je peux te livrer un **diff prêt à coller** (patch git) avec uniquement ces ajouts.
