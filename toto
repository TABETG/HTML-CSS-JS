@echo off
setlocal EnableExtensions EnableDelayedExpansion
chcp 65001 >nul

set "ROOT=%~dp0"
cd /d "%ROOT%"

set "IN=input.sql"
set "OUT=output_ansi.sql"

if not exist "%IN%" (
  for %%F in (*.sql) do (
    set "IN=%%F"
    goto :FOUND
  )
  echo [ERREUR] Aucun fichier .sql trouvé dans "%ROOT%"
  pause
  exit /b 1
)

:FOUND
echo [INFO] Fichier source: "%ROOT%%IN%"
echo [INFO] Fichier cible : "%ROOT%%OUT%"
echo.

set "PS1=%TEMP%\utf8_to_ansi_sql_%RANDOM%.ps1"

> "%PS1%" (
  echo param([string]$InFile,[string]$OutFile^)
  echo if(-not (Test-Path $InFile^)) { Write-Host "[ERREUR] Introuvable: $InFile"; exit 1 }
  echo $bytes = [IO.File]::ReadAllBytes($InFile^)
  echo $hasBom = ($bytes.Length -ge 3 -and $bytes[0] -eq 0xEF -and $bytes[1] -eq 0xBB -and $bytes[2] -eq 0xBF^)
  echo if($hasBom^) {
  echo ^  $utf8NoBom = New-Object System.Text.UTF8Encoding($false^)
  echo ^  $text = $utf8NoBom.GetString($bytes, 3, $bytes.Length-3^)
  echo } else {
  echo ^  $text = [Text.Encoding]::UTF8.GetString($bytes^)
  echo }
  echo $enc = [Text.Encoding]::GetEncoding(1252^)
  echo [IO.File]::WriteAllBytes($OutFile, $enc.GetBytes($text^)^)
  echo Write-Host "[OK] Conversion terminée -> $OutFile"
)

powershell -NoProfile -ExecutionPolicy Bypass -File "%PS1%" -InFile "%ROOT%%IN%" -OutFile "%ROOT%%OUT%"
set "RC=%ERRORLEVEL%"

del /f /q "%PS1%" >nul 2>&1

if not "%RC%"=="0" (
  echo.
  echo [ERREUR] La conversion a échoué.
  pause
  exit /b %RC%
)

echo.
echo [OK] Fichier créé : "%ROOT%%OUT%"
pause
exit /b 0