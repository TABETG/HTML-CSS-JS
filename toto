package com.bnpparibas.dsibddf.ap00420.streamfact.batch.maestrostatuspaymentrequest.writer;

import com.bnpparibas.dsibddf.ap00420.streamfact.application.cos.CosService;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.maestrostatuspaymentrequest.dto.PaymentRequestInfosForDocaposte;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.repository.docaposte.DocaposteRepository;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.repository.docaposte.model.DocaposteResponse;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.MaestroPaymentRequestEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.PaymentRequestEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.history.model.DocaposteEventHistoryEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.history.repository.DocaposteEventHistoryJpaRepository;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.*;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.item.Chunk;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.File;
import java.nio.file.Files;
import java.util.Collections;

import static org.junit.Assert.*;
import static org.mockito.Mockito.*;

/**
 * Tests JUnit 4 pour PrepareAndSendDocaposteNotifWriter.
 *
 * Couverture visée (100%) :
 *  - write() en chemin succès : envoi Docaposte OK, création du rapport, push vers COS.
 *  - write() en chemin erreur : exception Docaposte, création du rapport quand même, push vers COS.
 *
 * Conformité :
 *  - JUnit 4 uniquement (org.junit.*), pas de Jupiter/AssertJ.
 *  - @RunWith(MockitoJUnitRunner.class).
 */
@RunWith(MockitoJUnitRunner.class)
public class PrepareAndSendDocaposteNotifWriterTest {

    /** SUT créé manuellement (pas un bean Spring dans ce test). */
    private PrepareAndSendDocaposteNotifWriter writer;

    /** Dépendances externes mockées. */
    @Mock private DocaposteRepository docaposteRepository;
    @Mock private DocaposteEventHistoryJpaRepository docaposteEventHistoryJpaRepository;
    @Mock private CosService cosService;

    /** Données d’entrée et entités liées. */
    @Mock private PaymentRequestInfosForDocaposte info;
    @Mock private PaymentRequestEntity paymentRequestEntity;
    @Mock private MaestroPaymentRequestEntity maestroPaymentRequestEntity; // <- évite le NPE (mpr)
    @Mock private DocaposteEventHistoryEntity docaposteEventHistoryEntity;

    /** Dossier temporaire pour générer le rapport. */
    private File tempDir;

    @Before
    public void setUp() throws Exception {
        writer = new PrepareAndSendDocaposteNotifWriter();

        // Répertoire temporaire d'écriture (vérifié plus bas)
        tempDir = Files.createTempDirectory("docaposte-test-").toFile();
        assertTrue(tempDir.isDirectory());

        // Injection des champs @Value / @Autowired
        ReflectionTestUtils.setField(writer, "serialNumber", "SERIAL-001");
        ReflectionTestUtils.setField(writer, "docaposteRepository", docaposteRepository);
        ReflectionTestUtils.setField(writer, "docaposteEventHistoryJpaRepository", docaposteEventHistoryJpaRepository);
        ReflectionTestUtils.setField(writer, "cosService", cosService); // <- injection nécessaire
        ReflectionTestUtils.setField(writer, "pathGenerateFile", tempDir.getAbsolutePath() + File.separator);
        ReflectionTestUtils.setField(writer, "fileName", "StreamfactMaestroPaymentRequestsReport.%s.csv");
        ReflectionTestUtils.setField(writer, "prefix", "cos/prefix");

        // Stubs de l'item fourni au writer
        when(info.getDocaposteEventHistory()).thenReturn(docaposteEventHistoryEntity);
        when(info.getPaymentRequest()).thenReturn(paymentRequestEntity);

        // Identifiants de la demande
        when(paymentRequestEntity.getPaymentRequestId()).thenReturn("PR-1");
        when(paymentRequestEntity.getIdDn()).thenReturn("DN-1");

        // Correction du NPE : la classe lit un MaestroPaymentRequestEntity (mpr) depuis la PaymentRequest
        // on fournit donc un mock non-null et un getter minimal.
        when(paymentRequestEntity.getMaestroPaymentRequest()).thenReturn(maestroPaymentRequestEntity);
        when(maestroPaymentRequestEntity.getNumCptCont()).thenReturn("CPT-001");

        // Sauvegardes JPA renvoient l'entity en retour
        when(docaposteEventHistoryJpaRepository.save(any(DocaposteEventHistoryEntity.class)))
                .thenAnswer(inv -> inv.getArgument(0));
    }

    /**
     * Chemin succès :
     *  - docaposteRepository.sendDossierBox(...) renvoie une liste non vide (avec groupId).
     *  - La méthode write() met à jour l'historique, génère le CSV, puis déclenche le push COS.
     */
    @Test
    public void write_should_send_to_docaposte_and_push_report_to_cos_on_success() throws Exception {
        // Réponse Docaposte simulée
        DocaposteResponse response = mock(DocaposteResponse.class);
        when(response.getGroupId()).thenReturn("G-12345");
        when(docaposteRepository.sendDossierBox(anyList()))
                .thenReturn(Collections.singletonList(response));

        // Un chunk d’un seul élément suffit à couvrir la boucle interne
        Chunk<PaymentRequestInfosForDocaposte> chunk = new Chunk<>(Collections.singletonList(info));

        // Act
        writer.write(chunk);

        // Assert principaux
        verify(docaposteRepository, times(1)).sendDossierBox(anyList());
        verify(docaposteEventHistoryJpaRepository, atLeastOnce()).save(any(DocaposteEventHistoryEntity.class));

        // Vérifie le push COS : prefix + filename calculé
        ArgumentCaptor<String> fileNameCaptor = ArgumentCaptor.forClass(String.class);
        verify(cosService, times(1))
                .pushArchiveFileToCOS(eq("cos/prefix"), fileNameCaptor.capture(), isNull());

        String producedFileName = fileNameCaptor.getValue();
        assertNotNull(producedFileName);

        // Le fichier doit exister dans le dossier temporaire
        File generated = new File(tempDir, producedFileName);
        assertTrue("Le rapport CSV doit exister", generated.exists());
        assertTrue("Le rapport CSV doit être un fichier", generated.isFile());
    }

    /**
     * Chemin erreur :
     *  - docaposteRepository.sendDossierBox(...) lève une exception.
     *  - Le writer trace l’erreur, persiste l’historique, crée malgré tout le rapport et effectue le push COS.
     *  - Le test vérifie l’absence d’exception et la présence du fichier.
     */
    @Test
    public void write_should_handle_exception_from_docaposte_and_still_generate_and_push_report() throws Exception {
        // Simule une erreur côté Docaposte
        when(docaposteRepository.sendDossierBox(anyList()))
                .thenThrow(new RuntimeException("Docaposte indisponible"));

        Chunk<PaymentRequestInfosForDocaposte> chunk = new Chunk<>(Collections.singletonList(info));

        // Act (ne doit pas lever)
        writer.write(chunk);

        // La persistance d'historique est au moins appelée
        verify(docaposteEventHistoryJpaRepository, atLeastOnce()).save(any(DocaposteEventHistoryEntity.class));

        // Le push COS a lieu même en cas d'erreur d'envoi
        ArgumentCaptor<String> fileNameCaptor = ArgumentCaptor.forClass(String.class);
        verify(cosService, times(1))
                .pushArchiveFileToCOS(eq("cos/prefix"), fileNameCaptor.capture(), isNull());

        String producedFileName = fileNameCaptor.getValue();
        assertNotNull(producedFileName);
        assertTrue(new File(tempDir, producedFileName).exists());
    }
}