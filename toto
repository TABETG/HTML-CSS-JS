Super clair. Pour te donner une réponse exploitable tout de suite, je te liste tout ce qui doit avoir des tests pour faire monter la couverture Sonar, module par module, sous forme de chemins/patterns exacts. Je m’appuie sur ton POM parent et l’arbo fournie. 


---

Ce qu’il faut tester (à garder dans la couverture)

1) stream-fact-batch

Readers / Processors / Writers / Tasklets (toute la logique de traitement)

**/batch/**/reader/**.java

**/batch/**/processor/**.java

**/batch/**/writer/**.java (sauf Header/Footer callbacks “décoratifs”)

**/batch/**/tasklet/**.java


Listeners avec logique (modif d’ExitStatus, enrichissement contexte, retries, compteurs…)

**/batch/**/listener/**.java (sauf listeners purement log, voir exclusions de couverture)


RowMappers / Converters utilisés par les steps (format de dates, null-safety, parsing)

**/batch/**/rowmapper/**.java

**/batch/**/converter/**.java


Services et adaptateurs appelés par les steps (COS/CFT/Docaposte/PGP…)

**/batch/**/service/**.java

**/batch/**/adapter/**.java


Utilitaires avec logique utilisés par le batch

**/batch/**/util/**.java



> Exemples typiques de classes à tester dans ce module : Readers/Processors/Writers de synchro/closure/purge, Tasklets d’envoi (COS, chiffrement, CFT), RowMappers avec formatage, listeners qui ajustent l’ExitStatus.




---

2) stream-fact-domain

Services/Use-cases contenant des règles (même simples)

**/domain/**/service/**.java

**/domain/**/usecase/**.java


Logique “métier” hors DTO/enum/mapper

**/domain/**/helper/**.java

**/domain/**/util/**.java



> Ne testent pas : DTO/POJO, Enums, Mappers purs, interfaces de repository (cf. exclusions de couverture plus bas).




---

3) stream-fact-application

Orchestrations / Façades / Command handlers qui enchaînent des appels et gèrent des erreurs

**/application/**/service/**.java

**/application/**/command/**.java

**/application/**/facade/**.java


Intégration applicative avec logique (validation, mapping enrichi, décisions)

**/application/**/adapter/**.java




---

4) stream-fact-exposition

JMS/REST processors avec logique (filtrage, validation, routage, mapping non trivial)

**/exposition/**/jms/**/processor/**.java

**/exposition/**/rest/**/controller/**.java (si logique interne; sinon tester via tests d’intégration web)


Filtres/Intercepteurs qui modifient la requête/réponse ou le contexte

**/exposition/**/web/**/filter/**.java

**/exposition/**/web/**/interceptor/**.java



> Ne testent pas : DTO d’expo “plats”. Ils restent analysés mais peuvent être exclus de la couverture.




---

5) stream-fact-infra-sql

Implémentations personnalisées / logique SQL (au-delà des interfaces Spring Data)

**/infra-sql/**/repository/**/impl/**.java

**/infra-sql/**/dao/**.java

**/infra-sql/**/rowmapper/**.java


Converters (type handlers)

**/infra-sql/**/converter/**.java



> Ne testent pas : interfaces de repository, entités JPA (sauf logique particulière dans getters/custom methods).




---

6) stream-fact-infra-rest-clients / stream-fact-infra-soap-clients / stream-fact-infra-smtp / stream-fact-infra-static-filestore / stream-fact-infra-jms

Clients/Adapters avec logique de transformation/récupération/erreurs

**/infra-*/**/client/**.java

**/infra-*/**/adapter/**.java

**/infra-*/**/service/**.java


Wrappers PGP/COS/CFT si tu ne couvres pas ces flux via un test d’intégration de niveau batch

**/infra-*/**/security/**.java

**/infra-*/**/storage/**.java

**/infra-*/**/transfer/**.java



> Astuce : soit tu testes ces wrappers unitairement (write/close/erreurs), soit tu les couvres indirectement par un test de Tasklet/Writer qui les utilise.




---

Rappel — Ce qu’on peut retirer du calcul de couverture (mais garder analysé)

Ces classes restent analysées par Sonar (bugs/smells), mais ne plombent pas la couverture :

Wiring/Configuration sans logique :
**/*Application.java, **/*Configuration.java, **/*Config.java,
**/batch/**/job/**.java, **/batch/**/config/**.java.

Callbacks décoratifs :
**/batch/**/writer/*HeaderCallback*.java, **/batch/**/writer/*FooterCallback*.java.

Artefacts structurels “peu testables” :
**/exposition/**/dto/**.java,
**/domain/commons/**.java (enums/constantes),
**/domain/**/model/**.java (POJO),
**/domain/mapper/**/**.java (mappers purs),
**/domain/**/repository/**/**.java (interfaces).

Listeners purement log/no-op :
**/*Logging*Listener.java, **/*NoOp*Listener.java.


(ces patterns sont déjà intégrés dans le POM parent corrigé que je t’ai fourni.)


---

Ce qu’on exclut complètement du scan (donc pas à tester)

Répertoires de build et code généré :
**/target/**, **/build/**, **/out/**,
**/generated-sources/**, **/generated-test-sources/**,
schémas/artefacts : **/com/bnp/schema/**/**, **/xsd/**/**, **/wsdl/**/**, **/openapi/**/**, **/swagger/**/**, **/proto/**/**, **/jooq/**/**.
(déjà en place dans le POM parent que je t’ai envoyé). 



---

En deux phrases

Fais des tests partout où il y a de la logique (Readers/Processors/Writers/Tasklets, listeners non triviaux, RowMappers/Converters, services/adapters avec décisions ou gestion d’erreurs) dans tous les modules cités plus haut.

Ne perds pas de temps à tester le wiring (jobs/config), les DTO/Enums/Mappers purs/Repos interfaces, et les callbacks décoratifs : on les retire du calcul de couverture mais on garde leur analyse Sonar.



oooooooooo

Top—voici la liste précise (packages + noms de classes) de ce que tu dois cibler avec des tests pour faire monter la couverture Sonar, en te basant sur l’arbo et les sources fournis.

stream-fact-batch — à tester

Synchro UPDATE (BillingSpace)

com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.update.reader.BillingSpaceSynchroItemReader 

com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.update.processor.BillingSpaceSynchroItemProcessor 

com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.update.writer.BillingSpaceSynchroItemWriter 

com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.update.writer.EventHistorySynchroItemWriter (appelé par la conf) 

com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.update.writer.LoanFolderSynchroItemWriter (appelé par la conf) 


> NB : la classe ...update.job.JobConfigurationBillingSpaceSynchro est de la conf (DSL Spring Batch) → pas une cible de tests unitaires (exclue de couverture), mais les 5 classes ci-dessus oui. 



Synchro SENDER (envoi)

com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.sender.processor.BillingSpaceSendSynchroItemProcessor 

com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.sender.writer.BillingSpaceSendSynchroItemWriter 
(Le ...sender.reader.EventHistorySynchroItemReaderConfig est une config : pas une cible de test unitaire.) 


Replay – Payment Request Processed

com.bnpparibas.dsibddf.ap00420.streamfact.batch.replay.sendpaymentrequestprocessed.reader.SendPaymentRequestProcessedReader 

com.bnpparibas.dsibddf.ap00420.streamfact.batch.replay.sendpaymentrequestprocessed.processor.SendPaymentRequestProcessedProcessor 

com.bnpparibas.dsibddf.ap00420.streamfact.batch.replay.sendpaymentrequestprocessed.writer.SendPaymentRequestProcessedWriter 


Stock integration / creation & envoi

com.bnpparibas.dsibddf.ap00420.streamfact.batch.stockintegration.writer.CompleteLoanFoldersAndCreateBillingSpacesItemWriter 

com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.creation.writer.SendBillingSpaceWriter 


Tasklets / Sécurité / Flux

com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.tasklet.CypherPGPTasklet (la classe métier visée par le test présent ; écrire des TU directs sur le tasklet pour couvrir la logique happy-path / erreurs). 


File management (Daily Meteor)

com.bnpparibas.dsibddf.ap00420.streamfact.batch.dailymeteorintegration.manager.LocalFileManager (contient de la logique : validation @Value, scan de fichiers, cas bord → à tester). 



---

stream-fact-infra-sql — à tester (si logique au-delà des interfaces)

RowMappers/Converters personnalisés et implémentations (quand présentes).

Exemple d’éléments du module pour repérage (là, JPAConfig et BillingSpaceEntity/*Mapper* existent, mais les mappers purs sont plutôt exclus de la couverture) :

com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.config.JPAConfig (configuration → pas cible de tests unitaires)

com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.mapper.BillingSpaceMapperToDomain (mapper pur → généralement retiré de la couverture)

com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.mapper.BillingSpaceMapperToJpa (mapper pur → idem) 




---

Rappel — à ne pas cibler par des tests unitaires (mais gardés à l’analyse Sonar)

Configurations / DSL Spring Batch : ...job.*, ...config.* (ex. JobConfiguration*).

Readers “Config” (fabrique de ItemReader par @Bean), ex. EventHistorySynchroItemReaderConfig. 

DTO/POJO, Enums, Mappers purs, Repositories (interfaces) (déjà retirés de couverture via POM parent corrigé). 



---

Si tu veux un plan d’attaque (ordre de priorité)

1. BillingSpaceSynchroItemProcessor, BillingSpaceSynchroItemReader, BillingSpaceSynchroItemWriter. 


2. BillingSpaceSendSynchroItemProcessor, BillingSpaceSendSynchroItemWriter. 


3. SendPaymentRequestProcessedReader/Processor/Writer. 


4. CompleteLoanFoldersAndCreateBillingSpacesItemWriter, SendBillingSpaceWriter.


5. CypherPGPTasklet (tests unitaires ciblés + cas d’erreur). 


6. LocalFileManager (paths manquants, préfixe, dossier vide…). 



Si tu me donnes le dump complet des sources (ou si je dois extraire d’autres noms précis par module), je peux te générer la checklist exhaustive en CSV (classe ; package ; type ; priorité de test).

ooppppppppppppp