package com.bnpparibas.dsibddf.ap00420.streamfact.batch.maestrostatuspaymentrequest.writer;

import com.bnpparibas.dsibddf.ap00420.streamfact.batch.maestrostatuspaymentrequest.MaestroStatusPaymentRequestConfiguration;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.MaestroPaymentRequestStatusEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.MaestroPaymentRequestEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.repository.MaestroPaymentRequestJpaRepository;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import org.springframework.batch.item.Chunk;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.mockito.Mockito.*;

/**
 * Tests JUnit 4 pour MaestroPaymentNonConformeWriter.
 *
 * Contraintes respectées :
 * - JUnit 4 uniquement (org.junit.*), pas de JUnit Jupiter.
 * - Mockito JUnit 4 runner (@RunWith(MockitoJUnitRunner.class)).
 * - Pas d’AssertJ ; assertions JUnit (assertEquals, assertTrue).
 * - verifyNoInteractions(...) utilisé si besoin ; jamais verifyZeroInteractions(...).
 *
 * Ce writer :
 * - parcourt les items du Chunk,
 * - positionne le statut PAYMENT_REQUEST_UPDATED et la date d’update courante,
 * - sauvegarde la liste via maestroPaymentRequestJpaRepository.saveAll(...),
 * - incrémente MaestroStatusPaymentRequestConfiguration.count.
 */
@RunWith(MockitoJUnitRunner.class)
public class MaestroPaymentNonConformeWriterTest {

    @InjectMocks
    private MaestroPaymentNonConformeWriter writer;

    @Mock
    private MaestroPaymentRequestJpaRepository maestroPaymentRequestJpaRepository;

    @Before
    public void resetCounter() {
        // Sécurise les tests en repartant d’une base connue
        MaestroStatusPaymentRequestConfiguration.count = 0;
    }

    /**
     * Scénario principal : deux entités dans le chunk.
     * On vérifie :
     *  - setStatus appelé avec le bon label sur chaque entité,
     *  - setUpdateDate appelé avec la même valeur temporelle pour chaque entité,
     *  - saveAll appelé avec la liste telle quelle,
     *  - le compteur a été incrémenté d'une unité.
     */
    @Test
    public void write_should_update_status_and_date_then_save_and_increment_counter() throws Exception {
        // Arrange
        MaestroPaymentRequestEntity e1 = mock(MaestroPaymentRequestEntity.class);
        MaestroPaymentRequestEntity e2 = mock(MaestroPaymentRequestEntity.class);
        List<MaestroPaymentRequestEntity> items = Arrays.asList(e1, e2);
        Chunk<MaestroPaymentRequestEntity> chunk = new Chunk<MaestroPaymentRequestEntity>(items);

        int before = MaestroStatusPaymentRequestConfiguration.count;

        // Act
        writer.write(chunk);

        // Assert : statut appliqué
        String expectedLabel = MaestroPaymentRequestStatusEnum.PAYMENT_REQUEST_UPDATED.getLabel();
        verify(e1, times(1)).setStatus(expectedLabel);
        verify(e2, times(1)).setStatus(expectedLabel);

        // Assert : même timestamp pour les deux entités
        ArgumentCaptor<LocalDateTime> t1 = ArgumentCaptor.forClass(LocalDateTime.class);
        ArgumentCaptor<LocalDateTime> t2 = ArgumentCaptor.forClass(LocalDateTime.class);
        verify(e1, times(1)).setUpdateDate(t1.capture());
        verify(e2, times(1)).setUpdateDate(t2.capture());
        assertEquals("Les deux entités doivent être marquées avec la même date", t1.getValue(), t2.getValue());

        // Assert : repository.saveAll appelé avec la liste d'origine
        verify(maestroPaymentRequestJpaRepository, times(1)).saveAll(items);
        verifyNoMoreInteractions(maestroPaymentRequestJpaRepository);

        // Assert : compteur incrémenté d'une unité (par exécution de write)
        assertEquals(before + 1, MaestroStatusPaymentRequestConfiguration.count);
    }

    /**
     * Scénario chunk vide :
     * On vérifie :
     *  - saveAll est appelé avec une liste vide,
     *  - aucun setStatus/setUpdateDate n'est appelé (aucun item),
     *  - le compteur est tout de même incrémenté d'une unité (éxécution du writer).
     */
    @Test
    public void write_should_handle_empty_chunk_and_still_increment_counter() throws Exception {
        // Arrange
        Chunk<MaestroPaymentRequestEntity> emptyChunk =
                new Chunk<MaestroPaymentRequestEntity>(Collections.<MaestroPaymentRequestEntity>emptyList());
        int before = MaestroStatusPaymentRequestConfiguration.count;

        // Act
        writer.write(emptyChunk);

        // Assert : capture de la liste passée au repository et vérification qu’elle est vide
        ArgumentCaptor<List> listCaptor = ArgumentCaptor.forClass(List.class);
        verify(maestroPaymentRequestRequestJpaRepository(), times(1)).saveAll(listCaptor.capture());
        assertTrue("La liste sauvegardée doit être vide", listCaptor.getValue().isEmpty());
        verifyNoMoreInteractions(maestroPaymentRequestJpaRepository);

        // Compteur incrementé d'une unité
        assertEquals(before + 1, MaestroStatusPaymentRequestConfiguration.count);
    }

    /**
     * Petit helper pour lever précocement une faute de frappe sur le champ mocké.
     * Permet d'éviter une NullPointerException si le mock n'est pas correctement injecté.
     */
    private MaestroPaymentRequestJpaRepository maestroPaymentRequestRequestJpaRepository() {
        assertTrue("Le mock du repository doit être injecté", maestroPaymentRequestJpaRepository != null);
        return maestroPaymentRequestJpaRepository;
    }
}