package com.bnpparibas.dsibddf.ap10530.incident.infrastructure.ficp.service;

// --- Imports standards Java / réseau / encodage ---
import java.io.InputStream; // lecture de la réponse HTTP
import java.io.OutputStream; // écriture du corps de requête
import java.net.URL; // construction de l'URL d'appel
import java.net.URLEncoder; // encodage des paramètres de requête et credentials
import java.net.HttpURLConnection; // codes HTTP et constantes
import java.util.Base64; // encodage Basic Auth

// --- Logs / Spring ---
import org.slf4j.Logger; // logging
import org.slf4j.LoggerFactory; // logging
import org.springframework.beans.factory.annotation.Autowired; // injection de dépendances
import org.springframework.beans.factory.annotation.Qualifier; // sélectionner le bean SSL
import org.springframework.beans.factory.annotation.Value; // propriétés externes (application.properties)
import org.springframework.beans.factory.config.ConfigurableBeanFactory; // portée de bean
import org.springframework.context.annotation.Scope; // définir la portée prototype
import org.springframework.stereotype.Component; // stéréotype Spring

// --- Modèle / DTO / JSON ---
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.ApiException; // exception métier standardisée
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.ficp.dto.FICPResponse; // DTO réponse FICP
import com.fasterxml.jackson.core.JsonProcessingException; // sérialisation logging debug
import com.fasterxml.jackson.databind.DeserializationFeature; // options de désérialisation
import com.fasterxml.jackson.databind.ObjectMapper; // JSON <-> objets

// --- HTTPS ---
import javax.net.ssl.HttpsURLConnection; // connexion HTTPS spécifique
import javax.net.ssl.SSLSocketFactory; // fabrique de sockets SSL (Z/OS certs, etc.)

/**
 * PobiFicp Client Web Service.
 *
 * Rôle : gérer les appels HTTP(S) REST vers le service FICP (Banque de France) via POBI,
 * en construisant la requête (Basic Auth + query params) et en désérialisant la réponse JSON.
 */
@Component
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) // ASAP 523 : bean instancié à chaque injection
public class PobiFicpClient {

    private static final Logger LOGGER = LoggerFactory.getLogger(PobiFicpClient.class);

    // URL racine du service (ex: https://host:port/context)
    @Value("${ficp.ws.resturl}")
    private String address;

    // Identifiant de profil pour l'authentification Basic (partie login)
    @Value("${ficp.ws.login.idprofil}")
    private String idProfil;

    // Données utilisateur pour l'authentification Basic (partie mot de passe / user data)
    @Value("${ficp.ws.login.userdata}")
    private String userData;

    // Fabrique de sockets SSL (certificats / protocole TLS) fournie par la conf Z/OS
    @Autowired
    @Qualifier("zosSSLFactory")
    SSLSocketFactory sslFactory;

    /** @return the address */
    public String getAddress() { return address; }

    /** @param address the address to set */
    public void setAddress(final String address) { this.address = address; }

    /** @return the idProfil */
    public String getIdProfil() { return idProfil; }

    /** @param idProfil the idProfil to set */
    public void setIdProfil(final String idProfil) { this.idProfil = idProfil; }

    /** @return the userData */
    public String getUserData() { return userData; }

    /** @param userData the userData to set */
    public void setUserData(final String userData) { this.userData = userData; }

    // Construit la chaîne "idProfil:userData" encodée URL pour l'entête Basic Auth (puis Base64)
    private String getCredentials() {
        final StringBuilder creds = new StringBuilder();
        // NB: URLEncoder.encode utilise le charset par défaut (JDK), ici cohérent avec getBytes("ISO8859-1") plus loin
        creds.append(URLEncoder.encode(idProfil));
        creds.append(':');
        creds.append(URLEncoder.encode(userData));
        return creds.toString();
    }

    // Exécute l'appel HTTPS : construit l'URL complète, pose les en-têtes, envoie le corps "req" et parse la réponse JSON
    private FICPResponse ficpSend(final String path, final String req) {
        HttpsURLConnection conn = null; // connexion HTTPS (fermée en finally si erreur)
        FICPResponse result = null;     // résultat (reste null si erreur avant lecture)
        final String fullAddress = address + path; // URL complète
        LOGGER.debug("URL = " + fullAddress);
        try {
            // Ouverture de la connexion HTTPS
            final URL url = new URL(fullAddress);
            conn = (HttpsURLConnection) url.openConnection();
            conn.setSSLSocketFactory(sslFactory); // impose la factory SSL fournie (certs, ciphers)

            // Prépare les en-têtes HTTP (Basic Auth + Accept JSON)
            final String creds = Base64.getEncoder().encodeToString(getCredentials().getBytes("ISO8859-1"));
            conn.setDoOutput(true); // on va écrire un corps de requête
            conn.setRequestProperty("Authorization", "Basic " + creds);
            conn.setRequestProperty("Accept", "application/json");

            // Envoi du corps de requête (form-urlencoded, construit par l'appelant)
            try (final OutputStream os = conn.getOutputStream()) {
                os.write(req.getBytes("ISO8859-1")); // envoi en ISO-8859-1 côté POBI
            }

            // Vérifie le code HTTP
            final int responseCode = conn.getResponseCode();
            if (responseCode != HttpURLConnection.HTTP_OK) {
                // On lève une ApiException si le code n'est pas 200
                throw new ApiException(1, "Invalid HTTP response code");
            }

            // Lecture et désérialisation de la réponse JSON
            try (final InputStream is = conn.getInputStream()) {
                final ObjectMapper mapper = new ObjectMapper();
                // Certaines réponses peuvent renvoyer un champ unique au lieu d'un tableau
                mapper.enable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY);
                result = mapper.readValue(is, FICPResponse.class);
                conn = null; // marque la connexion comme "consommée" pour éviter disconnect inutile
                return result;
            }
        } catch (Exception e) {
            // Log complet + message d'erreur contextualisé, on renvoie (potentiellement) null
            LOGGER.error(String.format("Error during call to REST service %s, message : %s", fullAddress, e.getMessage()), e);
            return result;
        } finally {
            if (conn != null) {
                // Quelque chose s'est mal passé pendant la requête, on coupe la connexion
                conn.disconnect();
            }
        }
    }

    /**
     * Effectue l'opération WS "globalePersonnePhysique" côté FICP.
     *
     * Construit les paramètres de requête (clé BDF, motif, type crédit, CIB/ETC),
     * puis appelle ficpSend sur le chemin "/ficp/pp/global".
     *
     * @param bdfKey    Clé BDF de la personne physique
     * @param motif     Motif de consultation
     * @param cibEtc    Code CIB/ETC (audit/traçabilité)
     * @param typeCredit Type de crédit
     * @return FICPResponse désérialisée (peut être null si erreur en amont)
     */
    public FICPResponse searchGlobalPP(final String bdfKey, final String motif, final String cibEtc, final String typeCredit) {
        LOGGER.debug("Requesting FICP GlobalePersonnePhysique for {}", bdfKey);
        // LOGGER.info("Input for FICP {} - {} - {} - {}", bdfKey, motif, cibEtc, typeCredit);

        // Construction du corps (clé=valeur encodées) attendu par le service FICP
        final StringBuilder req = new StringBuilder();
        req.append("cleBdf=").append(URLEncoder.encode(bdfKey));
        req.append("&motifConsult=").append(URLEncoder.encode(motif));
        req.append("&typeCredit=").append(URLEncoder.encode(typeCredit));
        req.append("&cibEtc=").append(URLEncoder.encode(cibEtc));

        // Envoi via HTTPS et parsing JSON
        final FICPResponse response = ficpSend("/ficp/pp/global", req.toString());

        // Si debug activé, on tente de logguer la réponse JSON complète (à manipuler prudemment en prod)
        if (LOGGER.isDebugEnabled()) {
            try {
                ObjectMapper mapper = new ObjectMapper();
                LOGGER.debug("response {}", mapper.writeValueAsString(response));
            } catch (JsonProcessingException jpe) {
                LOGGER.debug("Failed to serialize response as JSON", jpe);
            }
        }
        return response;
    }
}
