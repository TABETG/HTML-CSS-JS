Yes ! Pour booster la couverture (>80%) sans toucher à l’existant, voici **des classes de tests prêtes à coller** qui couvrent des zones simples et peu testées (tasklets, writer “orchestrateur”, gestion de fichiers). Elles respectent vos packages et lib déjà présentes (JUnit4/Mockito/Spring Test), d’après le PDF du projet.

> Ciblage des classes à couvrir
> • `DeleteDpoTableImageTasklet` (tasklet simple, facile à couvrir) 
> • `LocalFileManager` (branches: nulls, vide, fichiers trouvés, méthodes no-op) 
> • `CompleteLoanFoldersAndCreateBillingSpacesItemWriter` (orchestration de 2 commandes) 

---

### 1) `DeleteDpoTableImageTaskletTest.java`

Couvre l’appel repo + le retour `RepeatStatus.FINISHED`.

```java
package com.bnpparibas.dsibddf.ap00420.streamfact.batch.common.tasklet;

import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.ProblemNatureEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.history.repository.DPOMailToSendRepository;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.batch.core.StepContribution;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.test.util.ReflectionTestUtils;

import static org.junit.Assert.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

public class DeleteDpoTableImageTaskletTest {

    @Mock
    private DPOMailToSendRepository dpoMailToSendRepository;

    private DeleteDpoTableImageTasklet tasklet;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        // on évite d’hardcoder une constante d’enum inconnue
        ProblemNatureEnum nature = ProblemNatureEnum.values()[0];
        tasklet = new DeleteDpoTableImageTasklet(nature);
        ReflectionTestUtils.setField(tasklet, "dpoMailToSendRepository", dpoMailToSendRepository);
    }

    @Test
    public void execute_shouldDeleteAndReturnFinished() throws Exception {
        when(dpoMailToSendRepository.deleteWithSendFalseAndProblemeNature2(any(ProblemNatureEnum.class)))
                .thenReturn(3);

        RepeatStatus status = tasklet.execute(mock(StepContribution.class), mock(ChunkContext.class));

        ArgumentCaptor<ProblemNatureEnum> captor = ArgumentCaptor.forClass(ProblemNatureEnum.class);
        verify(dpoMailToSendRepository, times(1))
                .deleteWithSendFalseAndProblemeNature2(captor.capture());
        // on vérifie bien l’appel et le status
        assertEquals(RepeatStatus.FINISHED, status);
    }
}
```

> Classe testée : `DeleteDpoTableImageTasklet` (package/impl vus dans le dépôt). 

---

### 2) `LocalFileManagerTest.java`

Couvre toutes les branches de `getFiles()` + les méthodes `archiveFile(...)` (no-op/log).

```java
package com.bnpparibas.dsibddf.ap00420.streamfact.batch.dailymeteorintegration.manager;

import com.bnpparibas.dsibddf.ap00420.streamfact.batch.dailymeteorintegration.model.MeteorFile;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.springframework.test.util.ReflectionTestUtils;

import java.io.File;
import java.nio.file.Files;
import java.util.List;

import static org.hamcrest.CoreMatchers.*;
import static org.junit.Assert.*;

public class LocalFileManagerTest {

    private LocalFileManager manager;
    private File tempDir;

    @Before
    public void setUp() throws Exception {
        manager = new LocalFileManager();
        tempDir = Files.createTempDirectory("meteor-test").toFile();
        // injecte les @Value
        ReflectionTestUtils.setField(manager, "path", tempDir.getAbsolutePath());
        ReflectionTestUtils.setField(manager, "prefix", "METEOR_");
    }

    @After
    public void tearDown() throws Exception {
        if (tempDir != null && tempDir.exists()) {
            for (File f : tempDir.listFiles()) { if (f != null) f.delete(); }
            tempDir.delete();
        }
    }

    @Test(expected = IllegalArgumentException.class)
    public void getFiles_shouldThrow_whenPathIsNull() {
        ReflectionTestUtils.setField(manager, "path", null);
        manager.getFiles();
    }

    @Test(expected = IllegalArgumentException.class)
    public void getFiles_shouldThrow_whenPrefixIsNull() {
        ReflectionTestUtils.setField(manager, "prefix", null);
        manager.getFiles();
    }

    @Test
    public void getFiles_shouldReturnEmpty_whenNoFileMatches() {
        List<MeteorFile> files = manager.getFiles();
        assertNotNull(files);
        assertTrue(files.isEmpty());
    }

    @Test
    public void getFiles_shouldReturnUnmodifiableList_withMappedNames() throws Exception {
        // crée des fichiers dont 1 seul matche le prefix
        File ok = new File(tempDir, "METEOR_20250101.dat");
        File ko = new File(tempDir, "OTHER_20250101.dat");
        assertTrue(ok.createNewFile());
        assertTrue(ko.createNewFile());

        List<MeteorFile> files = manager.getFiles();
        assertThat(files.size(), is(1));
        assertThat(files.get(0).getKey(), is("METEOR_20250101.dat"));
        assertThat(files.get(0).getFile().getName(), is("METEOR_20250101.dat"));

        // liste non modifiable
        try {
            files.add(new MeteorFile(ok, ok.getName()));
            fail("list should be unmodifiable");
        } catch (UnsupportedOperationException expected) {}
    }

    @Test
    public void archiveFile_shouldNotThrow() {
        manager.archiveFile("whatever");
        manager.archiveFile(new MeteorFile(new File("x"), "x"));
    }
}
```

> Classe testée : `LocalFileManager` (profil `test`, lecture de `path`/`prefix`, construction des `MeteorFile`). 

---

### 3) `CompleteLoanFoldersAndCreateBillingSpacesItemWriterTest.java`

Vérifie l’orchestration des deux commandes exécutées par le writer.

```java
package com.bnpparibas.dsibddf.ap00420.streamfact.batch.stockintegration.writer;

import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.complete.CompleteLoanFoldersCommand;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.complete.CompleteLoanFoldersRequest;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.createbilling.CreateBillingSpaceCommand;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.createbilling.CreateBillingSpaceRequest;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.billingspace.model.BillingSpace;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.loanfolder.model.LoanFolder;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.shared.CommandExecutorV2;
import org.junit.Before;
import org.junit.Test;
import org.mockito.ArgumentMatchers;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.batch.item.Chunk;

import java.util.Arrays;
import java.util.Collections;

import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

public class CompleteLoanFoldersAndCreateBillingSpacesItemWriterTest {

    @Mock
    private CommandExecutorV2 commandExecutor;

    private CompleteLoanFoldersAndCreateBillingSpacesItemWriter writer;

    @Before
    public void setUp() {
        MockitoAnnotations.initMocks(this);
        writer = new CompleteLoanFoldersAndCreateBillingSpacesItemWriter();
        // inject mock
        // champ package-private ? sinon utiliser ReflectionTestUtils
        org.springframework.test.util.ReflectionTestUtils.setField(writer, "commandExecutor", commandExecutor);
    }

    @Test
    public void write_shouldExecuteCompleteThenCreateBillingSpace() throws Exception {
        // on mocke des LoanFolder / BillingSpace sans connaître leurs builders
        LoanFolder lf1 = mock(LoanFolder.class);
        LoanFolder lf2 = mock(LoanFolder.class);
        BillingSpace bs = mock(BillingSpace.class);

        when(commandExecutor.execute(eq(CompleteLoanFoldersCommand.class), any(CompleteLoanFoldersRequest.class)))
                .thenReturn(Arrays.asList(lf1, lf2));

        when(commandExecutor.execute(eq(CreateBillingSpaceCommand.class), any(CreateBillingSpaceRequest.class)))
                .thenReturn(Collections.singletonList(bs));

        Chunk<LoanFolder> chunk = new Chunk<>(Arrays.asList(lf1, lf2));
        writer.write(chunk);

        verify(commandExecutor, times(1))
                .execute(eq(CompleteLoanFoldersCommand.class), any(CompleteLoanFoldersRequest.class));
        verify(commandExecutor, times(1))
                .execute(eq(CreateBillingSpaceCommand.class), any(CreateBillingSpaceRequest.class));
    }
}
```

> Classe testée : `CompleteLoanFoldersAndCreateBillingSpacesItemWriter` (enchaîne `CompleteLoanFoldersCommand` puis `CreateBillingSpaceCommand`). 

---

## Où les poser ?

Placez ces fichiers dans `src/test/java` sous les mêmes packages que ci-dessus (ils sont déjà prêts). Le projet a déjà des tests de processeurs/écrivains et des steps Cucumber, mais ceux-ci ciblent des zones peu couvertes (tasklet/manager/orchestrateur) pour **gagner rapidement des points de couverture** sans I/O ni refacto (ex. tests actuels : `ClosedBillingSpaceProcessorTest`, `EventHistorySynchroItemWriterTest`, etc.).

---

## Astuces rapides pour grapiller encore (optionnel)

* **Désactiver `@Ignore` sur les tests unitaires légers** (ex. `CypherPGPTaskletTest`) si vous pouvez stubber l’I/O (déjà un `spy` + `doNothing().when(...).initializeValues(...)`). Gardez néanmoins les tests chiffrage “lourds” ignorés si non déterministes. 
* Ajouter un test négatif simple sur `LocalFileManager` quand le répertoire n’existe pas (retourne liste vide via `listFiles()==null`). 

Si tu veux, je peux aussi te générer des tests pour d’autres classes ciblées (par ex. `LoanFolderSynchro…Writer`, d’autres tasklets) selon le rapport Jacoco/IDEA pour aller chercher les lignes manquantes en priorité.
