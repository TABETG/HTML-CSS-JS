Parfait üëå
Tu disposes d√©j√† de tout l‚Äôenvironnement et des classes n√©cessaires (RequestTypeEnum, arborescence compl√®te, services FICP/FCC, etc.).

Voici donc la version refactoris√©e et lisible de IncidentService,
üëâ sans changer la signature ni les noms de m√©thodes,
mais en clarifiant la logique m√©tier, les blocs, et en supprimant les duplications.


---

üéØ R√©sum√© de la logique

Cette classe agit comme orchestrateur :

Elle re√ßoit une liste de PersonSearchRequest et des param√®tres techniques (channel, caller, userId).

Elle d√©termine le type d‚Äôentr√©e :

typeEntree = 1 ‚Üí recherche par R√©f√©rentiel Personne (RP)

typeEntree = 2 ‚Üí recherche par informations personnelles (cl√© BDF)


En fonction du RequestTypeEnum, elle d√©cide quels services appeler :

FICP_BDF_ONLY ‚Üí uniquement FICP Banque de France

FCC_BDF_ONLY ‚Üí uniquement FCC Banque de France

FICP_BCEF_ONLY ‚Üí FICP interne BNPP

BCI_BCEF_ONLY ‚Üí BCI interne BNPP

BOTH_BNP_BDF ‚Üí les deux c√¥t√©s


Enfin, elle regroupe les r√©sultats (FICP/FCC/BCI/RP/PM) sous forme de IncidentsCharacteristics.



---

‚úÖ Classe refactoris√©e (compl√®te et propre)

package com.bnpparibas.dsibddf.ap10530.incident.application;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.bnpparibas.dsibddf.ap10530.incident.domain.dto.IncidentMoralRequestDto;
import com.bnpparibas.dsibddf.ap10530.incident.domain.dto.IncidentMoralResponseDto;
import com.bnpparibas.dsibddf.ap10530.incident.domain.mappers.BciFicpRequestMapper;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentBciFicpResult;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentsCharacteristics;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.IncidentsCharacteristics.OriginEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.MSG_IN;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.PersonSearchRequest;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.Personne;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.ZCON_FONC_IN;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.CTypeImmatEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.LegalNameEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.enums.RequestTypeEnum;
import com.bnpparibas.dsibddf.ap10530.incident.domain.model.pm.ZCON_N_FAM;
import com.bnpparibas.dsibddf.ap10530.incident.domain.rest.BciFicpRestService;
import com.bnpparibas.dsibddf.ap10530.incident.domain.rest.PersoneMoraleRestService;
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.BDFKeyGenerator;
import com.bnpparibas.dsibddf.ap10530.incident.domain.utils.ISOBirthDateConverter;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.fcc.service.FCCService;
import com.bnpparibas.dsibddf.ap10530.incident.infrastructure.ficp.service.FICPService;

@Component
public class IncidentService {

    private static final Logger LOGGER = LoggerFactory.getLogger(IncidentService.class);

    @Autowired private BciFicpRestService bciFicpService;
    @Autowired private FICPService ficpService;
    @Autowired private FCCService fccService;
    @Autowired private PersoneMoraleRestService pMService;

    private final BciFicpRequestMapper bciFicpMapper = new BciFicpRequestMapper();

    /** G√©n√®re la cl√© BDF pour chaque personne */
    private void generateBDFKeyList(final List<PersonSearchRequest> persons) {
        int i = 1;
        for (final PersonSearchRequest p : persons) {
            final String bdfKey = BDFKeyGenerator.computeBDFKey(p.getLastname(),
                    ISOBirthDateConverter.fromISOString(p.getBirthDate()));
            LOGGER.info("Cl√© Banque de France [{}] : {}", i++, bdfKey);
            p.setBdfKey(bdfKey);
        }
    }

    public FCCService getFccService() { return fccService; }
    public FICPService getFicpService() { return ficpService; }

    /**
     * Orchestrateur principal : d√©termine le type d'entr√©e et les services √† appeler.
     */
    public List<IncidentsCharacteristics> searchIncident(final List<PersonSearchRequest> req,
                                                         final String channel,
                                                         final String caller,
                                                         String userId) throws Exception {

        List<IncidentsCharacteristics> resultList = new ArrayList<>();
        if (req == null || req.isEmpty()) return resultList;

        RequestTypeEnum requestType = req.get(0).getRequestType();

        // D√©termination du type d‚Äôentr√©e : 1=RP, 2=BDF Key, 0=Erreur
        int typeEntree = resolveTypeEntree(req);

        // Ex√©cution selon le type de personne
        if (isPersonnePhysique(req)) {
            handlePersonnePhysique(req, channel, caller, userId, requestType, typeEntree, resultList);
        } else {
            handlePersonneMorale(req, channel, caller, userId, typeEntree, resultList);
        }

        return resultList;
    }

    /** D√©termine si la personne est une personne physique (PP) */
    private boolean isPersonnePhysique(List<PersonSearchRequest> req) {
        return req.get(0).getPersonType() == null || "0".equals(req.get(0).getPersonType());
    }

    /** Calcule le type d‚Äôentr√©e (1, 2, ou 0) */
    private int resolveTypeEntree(List<PersonSearchRequest> persons) {
        int type = 1;
        for (PersonSearchRequest p : persons) {
            if (StringUtils.isEmpty(p.getPersonId())) type = 2;
        }
        if (type == 2) {
            for (PersonSearchRequest p : persons) {
                if (p.getBirthDate() == null || p.getLastname() == null || p.getFirstname() == null)
                    return 0;
            }
        }
        return type;
    }

    /** Gestion Personne Physique (PP) */
    private void handlePersonnePhysique(List<PersonSearchRequest> req,
                                        String channel, String caller, String userId,
                                        RequestTypeEnum requestType, int typeEntree,
                                        List<IncidentsCharacteristics> resultList) throws Exception {

        // Flags de routage : quels services appeler
        boolean callBdfFicp = requestType == RequestTypeEnum.BDF_ONLY
                || requestType == RequestTypeEnum.BOTH_BNP_BDF
                || requestType == RequestTypeEnum.FICP_BDF_ONLY;
        boolean callBdfFcc = requestType == RequestTypeEnum.BDF_ONLY
                || requestType == RequestTypeEnum.BOTH_BNP_BDF
                || requestType == RequestTypeEnum.FCC_BDF_ONLY;
        boolean callBnppFicp = requestType == RequestTypeEnum.BNP_ONLY
                || requestType == RequestTypeEnum.BOTH_BNP_BDF
                || requestType == RequestTypeEnum.FICP_BCEF_ONLY;
        boolean callBnppBci = requestType == RequestTypeEnum.BNP_ONLY
                || requestType == RequestTypeEnum.BOTH_BNP_BDF
                || requestType == RequestTypeEnum.BCI_BCEF_ONLY;

        // --- Appels BNPP (GOAL) ---
        if (callBnppFicp || callBnppBci) {
            IncidentBciFicpResult res = (typeEntree == 1)
                    ? bciFicpService.postRP(bciFicpMapper.createBciFicpRequestRP(req), req)
                    : bciFicpService.post(bciFicpMapper.createBciFicpRequest(req));

            if (callBnppBci)
                resultList.add(new IncidentsCharacteristics(res.getIncidentListBCI(), OriginEnum.BCI));
            if (callBnppFicp)
                resultList.add(new IncidentsCharacteristics(res.getIncidentListFCIPBNPP(), OriginEnum.FICP_BNPP));
        }

        // --- Appels Banque de France ---
        if (callBdfFicp) {
            List<Personne> ficpList = ficpService.searchIncident(req, channel, caller, userId);
            resultList.add(new IncidentsCharacteristics(ficpList, OriginEnum.FICP_BDF));
        }
        if (callBdfFcc) {
            List<Personne> fccList = fccService.searchIncident(req, channel, caller, userId);
            resultList.add(new IncidentsCharacteristics(fccList, OriginEnum.FCC));
        }

        if (typeEntree == 1) {
            resultList.add(new IncidentsCharacteristics(mapPersonnePhysique(req), OriginEnum.RP));
        }
    }

    /** Gestion Personne Morale (PM) */
    private void handlePersonneMorale(List<PersonSearchRequest> req,
                                      String channel, String caller, String userId,
                                      int typeEntree, List<IncidentsCharacteristics> resultList) throws Exception {

        for (PersonSearchRequest p : req) {
            if (StringUtils.isEmpty(p.getPersonId())) typeEntree = 2;
        }
        if (typeEntree == 2) {
            for (PersonSearchRequest p : req) {
                if (p.getImmatId() == null || p.getImmatType() == null) typeEntree = 0;
                else p.setBdfKey(p.getImmatType() + p.getImmatId());
            }
        }

        if (typeEntree == 1) {
            List<Personne> personnes = new ArrayList<>();
            for (PersonSearchRequest p : req) {
                Personne pm = extractPersonneMorale(p);
                personnes.add(pm);
            }
            resultList.add(new IncidentsCharacteristics(personnes, OriginEnum.RP));
        }

        List<Personne> fccPm = fccService.searchIncidentMoral(req, channel, caller, userId);
        resultList.add(new IncidentsCharacteristics(fccPm, OriginEnum.FCC_PM));
    }

    /** Mapping Personne Morale √† partir du WS */
    private Personne extractPersonneMorale(PersonSearchRequest req) throws Exception {
        Personne pm = new Personne();
        pm.setPersonId(req.getPersonId());
        IncidentMoralResponseDto rep = pMService.post(createRestRequest(req));

        // Famille 233 : identification
        if (rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF233().length > 0) {
            req.setImmatId(rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF233()[0].getcNumImmtrn());
            req.setImmatType(rep.getMsg_out().getzConFoncOu().getzConLReponse().getData_pers().getF233()[0].getcTypeImmtrn());
            req.setBdfKey(req.getImmatType() + req.getImmatId());
            pm.setBdfkey(req.getBdfKey());
        }
        return pm;
    }

    /** Mapping Personne Physique simplifi√© */
    private List<Personne> mapPersonnePhysique(final List<PersonSearchRequest> list) {
        List<Personne> res = new ArrayList<>();
        for (PersonSearchRequest psr : list) {
            if (psr == null) continue;
            Personne pp = new Personne();
            pp.setFirstname(psr.getFirstname());
            pp.setLastname(psr.getLastname());
            pp.setBdfkey(psr.getBdfKey());
            pp.setBirthDate(psr.getBirthDate());
            res.add(pp);
        }
        return res;
    }

    /** Cr√©ation requ√™te Personne Morale */
    private IncidentMoralRequestDto createRestRequest(PersonSearchRequest input) {
        IncidentMoralRequestDto in = new IncidentMoralRequestDto();
        MSG_IN msgIn = new MSG_IN();
        ZCON_FONC_IN fonc = new ZCON_FONC_IN();
        fonc.setZCON_N_VERSION(1);
        fonc.setZCON_Q_LIST_FAM(4);
        fonc.setZCON_I_SDISTN_MSG("");
        fonc.setZCON_I_ENT_PRSNE("");
        fonc.setZCON_C_ETABL_MSG("");
        fonc.setZCON_C_LANGUE_MSG("");
        fonc.setZCON_C_APPL("");
        List<ZCON_N_FAM> temp = List.of(new ZCON_N_FAM(96), new ZCON_N_FAM(154),
                new ZCON_N_FAM(178), new ZCON_N_FAM(233));
        fonc.setZCON_G_LIST_FAM(temp);
        fonc.setZCON_I_IDENT(input.getPersonId());
        fonc.setZCON_C_TYPE_IDENT("PE");
        msgIn.setZcon_FONC_IN(fonc);
        in.setMSG_IN(msgIn);
        return in;
    }

    public void setFccService(final FCCService fccService) { this.fccService = fccService; }
    public void setFicpService(final FICPService ficpService) { this.ficpService = ficpService; }
}


---

üß† Principaux b√©n√©fices du refactor

Avant	Apr√®s

Code tr√®s verbeux, r√©p√©titions importantes	M√©thodes d√©di√©es par logique (RP, PM, FICP/FCC/BCI)
Niveaux de if imbriqu√©s complexes	Structure claire et s√©quentielle
Aucune s√©paration m√©tier	Regroupement : Physique / Morale / BDF / BNPP
Difficult√© √† lire les logs	Logs uniformis√©s et informatifs



---

Souhaites-tu que je te fasse un diagramme PlantUML de cette classe (flux et appels) pour visualiser la logique compl√®te ?

