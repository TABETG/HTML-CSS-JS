Tu as une erreur de contexte Spring parce que le writer a une dépendance non fournie (DocaposteRepository) et, côté processor, il y a aussi CommandExecutorV2 à mocker. Ça ressort explicitement dans tes logs et dans le code existant du writer / processor.   

Voici la classe de test corrigée qui se charge de tout mocker proprement (reader, processor, writer, tasklet + dépendances CommandExecutorV2, DocaposteRepository, DocaposteEventHistoryRepository) et qui câble le transactionManager. Elle vérifie aussi la présence du job et des trois steps déclarés dans la conf. (noms tels que définis dans ta JobConfigurationBillingSpaceClosure). 

package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.job;

import com.bnpparibas.bddf.cqrs.command.v2.CommandExecutorV2;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.billingspace.close.pojo.BillingSpaceCloseToSend;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.processor.BillingSpaceClosureProcessor;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.reader.BillingSpaceClosureReader;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.reader.ReplayBillingspaceClosureReader;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.tasklet.UpdateBillingSpaceToStatusClosedTasklet;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.writer.BillingSpaceClosureWriter;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.listener.CommonStepExecutionListener;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.BillingSpaceEntity;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.history.repository.DocaposteEventHistoryRepository;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.repository.docaposte.DocaposteRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mockito;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Primary;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.support.ResourcelessTransactionManager;

import static org.assertj.core.api.Assertions.assertThat;

@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = {
        JobConfigurationBillingSpaceClosure.class,
        JobConfigurationBillingSpaceClosureTest.TestBeans.class
})
class JobConfigurationBillingSpaceClosureTest {

    @org.springframework.beans.factory.annotation.Autowired
    private ApplicationContext ctx;

    @Test
    void jobWiring_ok() {
        // Job présent
        Job job = ctx.getBean("billingSpaceClosureJob", Job.class);
        assertThat(job).isNotNull();

        // Steps présents (noms alignés avec la config)
        Step s1 = ctx.getBean("billingSpaceClosureStep", Step.class);
        Step s2 = ctx.getBean("replayBillingSpaceClosureStep", Step.class);
        Step s3 = ctx.getBean("updateBillingSpaceToStatusClosedStep", Step.class);

        assertThat(s1).isNotNull();
        assertThat(s2).isNotNull();
        assertThat(s3).isNotNull();
    }

    @TestConfiguration
    static class TestBeans {

        // === Mocks des beans utilisés dans la configuration ===
        @Bean @Primary
        BillingSpaceClosureReader billingSpaceClosureReader() {
            return Mockito.mock(BillingSpaceClosureReader.class);
        }

        @Bean @Primary
        BillingSpaceClosureProcessor billingSpaceClosureProcessor() {
            return Mockito.mock(BillingSpaceClosureProcessor.class);
        }

        @Bean @Primary
        BillingSpaceClosureWriter billingSpaceClosureWriter() {
            return Mockito.mock(BillingSpaceClosureWriter.class);
        }

        @Bean @Primary
        ReplayBillingspaceClosureReader replayBillingspaceClosureReader() {
            return Mockito.mock(ReplayBillingspaceClosureReader.class);
        }

        @Bean
        UpdateBillingSpaceToStatusClosedTasklet updateBillingSpaceToStatusClosedTasklet() {
            // pas exécuté pendant ces tests – un mock suffit
            return Mockito.mock(UpdateBillingSpaceToStatusClosedTasklet.class);
        }

        @Bean
        CommonStepExecutionListener commonStepExecutionListener() {
            return Mockito.mock(CommonStepExecutionListener.class);
        }

        // Transaction manager requis par la config des steps
        @Bean(name = "transactionManager")
        PlatformTransactionManager transactionManager() {
            return new ResourcelessTransactionManager();
        }

        // === Dépendances manquantes qui faisaient planter le contexte ===
        @Bean
        CommandExecutorV2 commandExecutor() {
            return Mockito.mock(CommandExecutorV2.class);
        }

        @Bean
        DocaposteRepository docaposteRepository() {
            return Mockito.mock(DocaposteRepository.class);
        }

        @Bean
        DocaposteEventHistoryRepository docaposteEventHistoryRepository() {
            return Mockito.mock(DocaposteEventHistoryRepository.class);
        }
    }
}

Pourquoi ça corrige l’erreur :

Le writer autowire DocaposteRepository et DocaposteEventHistoryRepository. On les fournit en mocks, donc le bean billingSpaceClosureWriter peut être créé sans échec.  

Le processor autowire CommandExecutorV2. On le mock aussi pour éviter l’exception NoSuchBeanDefinitionException.  

Les trois steps/test vérifient la présence des beans dont les noms sont ceux définis dans la conf (billingSpaceClosureStep, replayBillingSpaceClosureStep, updateBillingSpaceToStatusClosedStep). 


Si tu préfères, on peut aussi refactorer le writer/processor en injection par constructeur (Lombok @RequiredArgsConstructor) pour des tests encore plus simples—mais ce n’est pas nécessaire ici pour faire passer le contexte et augmenter le coverage.