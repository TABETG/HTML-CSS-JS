package com.bnpparibas.dsibddf.ap00420.streamfact.batch.sendtobmd.service.batch.security.openpgp;

import org.bouncycastle.openpgp.*;
import org.bouncycastle.openpgp.operator.PublicKeyDataDecryptorFactory;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.junit.MockitoJUnitRunner;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileWriter;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

import static org.junit.Assert.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

/**
 * JUnit 4 – 100% lignes couvertes pour EncryptedInputStream (compatible Sonar/Jacoco/Jenkins).
 * Aucun import JUnit 5 / AssertJ.
 */
@RunWith(MockitoJUnitRunner.class)
public class EncryptedInputStreamTest {

    private PGPPrivateKey privateKey;
    private PGPPublicKey publicKey;
    private InputStream baseStream;

    @Before
    public void init() {
        privateKey = mock(PGPPrivateKey.class);
        publicKey = mock(PGPPublicKey.class);
        baseStream = new ByteArrayInputStream("abc".getBytes());
    }

    // ----- Constructeur : aucun encrypted data correspondant -> IllegalArgumentException
    @Test(expected = IllegalArgumentException.class)
    public void constructor_should_throw_when_no_matching_key() throws Exception {
        PGPObjectFactory objFactory = mock(PGPObjectFactory.class);
        PGPEncryptedDataList dataList = mock(PGPEncryptedDataList.class);
        when(objFactory.nextObject()).thenReturn(dataList);
        when(dataList.getEncryptedDataObjects()).thenReturn(Collections.<PGPEncryptedData>emptyList().iterator());
        setStaticFactory(objFactory);

        new EncryptedInputStream(baseStream, Collections.singletonList(privateKey), Collections.singletonList(publicKey));
    }

    // ----- Constructeur : PGPMarker ignoré + données compressées + literal OK (parcours nominal)
    @Test
    public void constructor_should_skip_marker_and_handle_compressed_data() throws Exception {
        PGPMarker marker = mock(PGPMarker.class);
        PGPEncryptedDataList list = mock(PGPEncryptedDataList.class);
        PGPPublicKeyEncryptedData enc = mock(PGPPublicKeyEncryptedData.class);
        PGPPrivateKey priv = mock(PGPPrivateKey.class);
        when(priv.getKeyID()).thenReturn(123L);
        when(enc.getKeyID()).thenReturn(123L);

        InputStream decStream = new ByteArrayInputStream("clear".getBytes());
        when(enc.getDataStream(any(PublicKeyDataDecryptorFactory.class))).thenReturn(decStream);

        PGPCompressedData comp = mock(PGPCompressedData.class);
        when(comp.getDataStream()).thenReturn(decStream);

        PGPLiteralData literal = mock(PGPLiteralData.class);
        when(literal.getDataStream()).thenReturn(new ByteArrayInputStream("ok".getBytes()));

        PGPObjectFactory factory = mock(PGPObjectFactory.class);
        when(factory.nextObject()).thenReturn(marker).thenReturn(list).thenReturn(comp).thenReturn(literal);
        when(list.getEncryptedDataObjects()).thenReturn(Arrays.asList((PGPEncryptedData) enc).iterator());
        setStaticFactory(factory);

        EncryptedInputStream s = new EncryptedInputStream(baseStream, Collections.singletonList(priv), Collections.emptyList());
        s.close();
    }

    // ----- Constructeur : signature présente mais clé publique non trouvée -> IllegalArgumentException
    @Test(expected = IllegalArgumentException.class)
    public void constructor_should_throw_when_signature_key_not_found() throws Exception {
        PGPEncryptedDataList encList = mock(PGPEncryptedDataList.class);
        PGPPublicKeyEncryptedData enc = mock(PGPPublicKeyEncryptedData.class);
        when(encList.getEncryptedDataObjects()).thenReturn(Arrays.asList((PGPEncryptedData) enc).iterator());
        when(enc.getKeyID()).thenReturn(1L);

        PGPPrivateKey priv = mock(PGPPrivateKey.class);
        when(priv.getKeyID()).thenReturn(1L);

        when(enc.getDataStream(any(PublicKeyDataDecryptorFactory.class)))
                .thenReturn(new ByteArrayInputStream("x".getBytes()));

        PGPOnePassSignatureList sigList = mock(PGPOnePassSignatureList.class);
        PGPOnePassSignature sig = mock(PGPOnePassSignature.class);
        when(sigList.iterator()).thenReturn(Arrays.asList(sig).iterator());
        when(sig.getKeyID()).thenReturn(999L); // ne correspond à aucune public key

        PGPObjectFactory f = mock(PGPObjectFactory.class);
        when(f.nextObject()).thenReturn(encList).thenReturn(sigList);
        setStaticFactory(f);

        new EncryptedInputStream(baseStream, Collections.singletonList(priv), Collections.singletonList(publicKey));
    }

    // ----- Constructeur : PGPLiteralData avec stream null -> IllegalArgumentException
    @Test(expected = IllegalArgumentException.class)
    public void constructor_should_throw_when_literal_stream_is_null() throws Exception {
        PGPEncryptedDataList encList = mock(PGPEncryptedDataList.class);
        PGPPublicKeyEncryptedData enc = mock(PGPPublicKeyEncryptedData.class);
        when(encList.getEncryptedDataObjects()).thenReturn(Arrays.asList((PGPEncryptedData) enc).iterator());
        when(enc.getKeyID()).thenReturn(1L);

        PGPPrivateKey priv = mock(PGPPrivateKey.class);
        when(priv.getKeyID()).thenReturn(1L);

        when(enc.getDataStream(any(PublicKeyDataDecryptorFactory.class)))
                .thenReturn(new ByteArrayInputStream("y".getBytes()));

        PGPLiteralData literal = mock(PGPLiteralData.class);
        when(literal.getDataStream()).thenReturn(null);

        PGPObjectFactory f = mock(PGPObjectFactory.class);
        when(f.nextObject()).thenReturn(encList).thenReturn(literal);
        setStaticFactory(f);

        new EncryptedInputStream(baseStream, Collections.singletonList(priv), Collections.singletonList(publicKey));
    }

    // ----- read() et read(byte[],off,len) déléguent au clearTextInputStream
    @Test
    public void read_methods_should_delegate_to_clear_stream() throws Exception {
        EncryptedInputStream s = new EncryptedInputStream(baseStream, Collections.emptyList(), Collections.emptyList());
        Field clear = EncryptedInputStream.class.getDeclaredField("clearTextInputStream");
        clear.setAccessible(true);
        clear.set(s, new ByteArrayInputStream("data".getBytes()));

        assertTrue(s.read() >= 0);
        byte[] buf = new byte[4];
        int n = s.read(buf, 0, 2);
        assertTrue(n >= 0);
        s.close();
    }

    // ----- calculateSignature() met à jour la signature si initialisée
    @Test
    public void calculateSignature_should_update_if_initialized() throws Exception {
        EncryptedInputStream s = new EncryptedInputStream(baseStream, Collections.emptyList(), Collections.emptyList());

        PGPOnePassSignature calc = mock(PGPOnePassSignature.class);
        Field fCalc = EncryptedInputStream.class.getDeclaredField("calculatedSignature");
        Field fPk = EncryptedInputStream.class.getDeclaredField("targetPartnerPGPPublicKey");
        fCalc.setAccessible(true);
        fPk.setAccessible(true);
        fCalc.set(s, calc);
        fPk.set(s, mock(PGPPublicKey.class));

        s.calculateSignature("abc".getBytes(), 0, 3);
        verify(calc, times(1)).update(any(byte[].class), anyInt(), anyInt());
    }

    // ----- verifySignature() : succès puis échec (PGPException)
    @Test
    public void verifySignature_should_cover_success_and_failure() throws Exception {
        EncryptedInputStream s = new EncryptedInputStream(baseStream, Collections.emptyList(), Collections.emptyList());

        PGPSignatureList list = mock(PGPSignatureList.class);
        PGPSignature messageSig = mock(PGPSignature.class);
        when(list.iterator()).thenReturn(Arrays.asList(messageSig).iterator());

        PGPOnePassSignature calc = mock(PGPOnePassSignature.class);
        when(calc.getKeyID()).thenReturn(7L);
        when(messageSig.getKeyID()).thenReturn(7L);

        Field fCalc = EncryptedInputStream.class.getDeclaredField("calculatedSignature");
        Field fPk = EncryptedInputStream.class.getDeclaredField("targetPartnerPGPPublicKey");
        Field fFactory = EncryptedInputStream.class.getDeclaredField("objectFactory");
        fCalc.setAccessible(true);
        fPk.setAccessible(true);
        fFactory.setAccessible(true);

        fCalc.set(s, calc);
        fPk.set(s, mock(PGPPublicKey.class));

        PGPObjectFactory factory = mock(PGPObjectFactory.class);
        fFactory.set(s, factory);
        when(factory.nextObject()).thenReturn(list);

        when(calc.verify(any(PGPSignature.class))).thenReturn(true);
        s.verifySignature();

        when(calc.verify(any(PGPSignature.class))).thenReturn(false);
        try {
            s.verifySignature();
            fail();
        } catch (PGPException expected) {
            assertTrue(true);
        }
    }

    // ----- verifyIntegrity() : protégé OK, protégé KO, non protégé
    @Test
    public void verifyIntegrity_should_cover_all_paths() throws Exception {
        EncryptedInputStream s = new EncryptedInputStream(baseStream, Collections.emptyList(), Collections.emptyList());
        PGPPublicKeyEncryptedData enc = mock(PGPPublicKeyEncryptedData.class);

        Field fEnc = EncryptedInputStream.class.getDeclaredField("publicKeyEncryptedData");
        fEnc.setAccessible(true);
        fEnc.set(s, enc);

        when(enc.isIntegrityProtected()).thenReturn(true);
        when(enc.verify()).thenReturn(true);
        s.verifyIntegrity();

        when(enc.verify()).thenReturn(false);
        try {
            s.verifyIntegrity();
            fail();
        } catch (PGPException expected) {
            assertTrue(true);
        }

        when(enc.isIntegrityProtected()).thenReturn(false);
        s.verifyIntegrity();
        s.close();
    }

    // ----- utilitaire pour injecter une factory statique si la classe en expose une
    private void setStaticFactory(PGPObjectFactory factory) throws Exception {
        try {
            Field f = EncryptedInputStream.class.getDeclaredField("objectFactory");
            f.setAccessible(true);
            f.set(null, factory);
        } catch (NoSuchFieldException ignored) {
            // si la classe ne possède pas de factory statique, on ignore
        }
    }
}