package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.reader;

import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.BillingSpaceStatusEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.RequestTypeEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.commons.RequestTypeStatusEnum;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.repository.BillingSpaceJpaRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.data.domain.Sort;

import java.lang.reflect.Field;
import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

class ReplayBillingspaceClosureReaderTest {

    @Mock
    private BillingSpaceJpaRepository repository;

    private ReplayBillingspaceClosureReader reader;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        reader = new ReplayBillingspaceClosureReader(repository);
    }

    @Test
    void constructor_setsRepositoryField() throws Exception {
        // Vérifie le champ privé final du reader
        assertSame(repository, getField(reader, "repository"));
    }

    @Test
    void init_configuresRepositorySortMethodAndArguments() throws Exception {
        // When
        reader.init();

        // repository propagé
        assertSame(repository, getField(reader, "repository"));

        // ----- Tri: compatible Map<String,Direction> ou Sort -----
        Object sortField = getAnyField(reader, "sort", "sorts");
        assertNotNull(sortField, "Le champ de tri doit être initialisé");

        if (sortField instanceof Map) {
            @SuppressWarnings("unchecked")
            Map<String, Sort.Direction> sorts = (Map<String, Sort.Direction>) sortField;
            assertEquals(Sort.Direction.ASC, sorts.get("loanFolderId"));
        } else if (sortField instanceof Sort) {
            Sort sort = (Sort) sortField;
            Sort.Order order = sort.getOrderFor("loanFolderId");
            assertNotNull(order, "Un ordre doit exister pour loanFolderId");
            assertEquals(Sort.Direction.ASC, order.getDirection());
        } else {
            fail("Type de champ 'sort' inattendu: " + sortField.getClass());
        }

        // methodName
        assertEquals("findReplayBillingSpacesToClose", getField(reader, "methodName"));

        // arguments: [ [TO_CLOSE, CLOSED], CLOSING, [CLOSURE_TO_SEND, CLOSURE_REJECTED] ]
        @SuppressWarnings("unchecked")
        List<Object> args = (List<Object>) getAnyField(reader, "arguments", "args");
        assertNotNull(args);
        assertEquals(3, args.size());

        // 1) List<BillingSpaceStatusEnum>
        assertTrue(args.get(0) instanceof List, "arg[0] doit être une List de statuts");
        @SuppressWarnings("unchecked")
        List<?> statuses = (List<?>) args.get(0);
        assertTrue(statuses.contains(BillingSpaceStatusEnum.TO_CLOSE));
        assertTrue(statuses.contains(BillingSpaceStatusEnum.CLOSED));

        // 2) RequestTypeEnum
        assertEquals(RequestTypeEnum.CLOSING, args.get(1));

        // 3) List<RequestTypeStatusEnum>
        assertTrue(args.get(2) instanceof List, "arg[2] doit être une List de statuses");
        @SuppressWarnings("unchecked")
        List<?> reqStatuses = (List<?>) args.get(2);
        assertTrue(reqStatuses.contains(RequestTypeStatusEnum.CLOSURE_TO_SEND));
        assertTrue(reqStatuses.contains(RequestTypeStatusEnum.CLOSURE_REJECTED));
    }

    // --- Helpers réflexion : parcourent la hiérarchie (superclasses comprises) ---
    private Object getField(Object target, String name) throws Exception {
        Field f = findField(target.getClass(), name);
        assertNotNull(f, "Champ introuvable: " + name);
        f.setAccessible(true);
        return f.get(target);
    }

    private Object getAnyField(Object target, String... candidates) throws Exception {
        for (String name : candidates) {
            Field f = findField(target.getClass(), name);
            if (f != null) {
                f.setAccessible(true);
                return f.get(target);
            }
        }
        // fallback : premier champ Map ou Sort trouvé (selon version Spring Batch)
        for (Class<?> c = target.getClass(); c != null; c = c.getSuperclass()) {
            for (Field f : c.getDeclaredFields()) {
                if (Map.class.isAssignableFrom(f.getType()) || Sort.class.isAssignableFrom(f.getType())) {
                    f.setAccessible(true);
                    return f.get(target);
                }
            }
        }
        return null;
    }

    private Field findField(Class<?> type, String name) {
        for (Class<?> c = type; c != null; c = c.getSuperclass()) {
            try {
                return c.getDeclaredField(name);
            } catch (NoSuchFieldException ignored) {}
        }
        return null;
    }
}