Voici un test unitaire (JUnit 5 + Mockito, sans modifier le **pom** ni la classe existante) qui couvre à 100% les lignes de `PaymentRequestPaidItemProcessor` en injectant un mock du `CommandExecutorV2` par réflexion. Il vérifie le chemin nominal et la propagation d’une exception. Code basé sur le fichier fourni. 

Place ce fichier sous :
`src/test/java/com/bnpparibas/dsibddf/ap00420/streamfact/batch/paymentrequestpaid/processor/PaymentRequestPaidItemProcessorTest.java`

```java
package com.bnpparibas.dsibddf.ap00420.streamfact.batch.paymentrequestpaid.processor;

import com.bnpparibas.bddf.cqrs.command.v2.CommandExecutorV2;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.billingspace.paymentrequest.UpdatePaymentRequest;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.billingspace.paymentrequest.UpdatePaymentRequestCommand;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.engines.UpdatePaymentRequestResult;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.billingspace.model.BillingSpaceEntity;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.lang.reflect.Field;

class PaymentRequestPaidItemProcessorTest {

    @Test
    void process_should_call_executor_and_return_its_result() throws Exception {
        // Arrange
        PaymentRequestPaidItemProcessor processor = new PaymentRequestPaidItemProcessor();

        @SuppressWarnings("unchecked")
        CommandExecutorV2 commandExecutor = Mockito.mock(CommandExecutorV2.class);

        // Injection via réflexion pour ne pas toucher au code de prod ni au pom
        injectPrivate(processor, "commandExecutor", commandExecutor);

        UpdatePaymentRequestResult expected = Mockito.mock(UpdatePaymentRequestResult.class);

        Mockito.when(commandExecutor.execute(
                Mockito.eq(UpdatePaymentRequestCommand.class),
                Mockito.any(UpdatePaymentRequest.class))
        ).thenReturn(expected);

        // BillingSpaceEntity minimal ; le mapper interne se débrouille avec les valeurs par défaut
        BillingSpaceEntity entity = new BillingSpaceEntity();

        // Act
        UpdatePaymentRequestResult actual = processor.process(entity);

        // Assert
        Assertions.assertSame(expected, actual, "Le résultat doit être celui retourné par le CommandExecutor");
        Mockito.verify(commandExecutor, Mockito.times(1))
                .execute(Mockito.eq(UpdatePaymentRequestCommand.class), Mockito.any(UpdatePaymentRequest.class));
        Mockito.verifyNoMoreInteractions(commandExecutor);
    }

    @Test
    void process_should_propagate_executor_exception() throws Exception {
        // Arrange
        PaymentRequestPaidItemProcessor processor = new PaymentRequestPaidItemProcessor();

        @SuppressWarnings("unchecked")
        CommandExecutorV2 commandExecutor = Mockito.mock(CommandExecutorV2.class);
        injectPrivate(processor, "commandExecutor", commandExecutor);

        Mockito.when(commandExecutor.execute(
                Mockito.eq(UpdatePaymentRequestCommand.class),
                Mockito.any(UpdatePaymentRequest.class))
        ).thenThrow(new RuntimeException("boom"));

        BillingSpaceEntity entity = new BillingSpaceEntity();

        // Act + Assert
        Assertions.assertThrows(RuntimeException.class, () -> processor.process(entity),
                "L'exception levée par l'executor doit être propagée");
    }

    /**
     * Injection d'un champ private sans dépendre de Spring Test.
     */
    private static void injectPrivate(Object target, String fieldName, Object value) {
        try {
            Field f = target.getClass().getDeclaredField(fieldName);
            f.setAccessible(true);
            f.set(target, value);
        } catch (Exception e) {
            throw new RuntimeException("Impossible d'injecter le champ '" + fieldName + "'", e);
        }
    }
}
```

Notes rapides :

* Pas de modification du `pom.xml` ni de la classe de prod.
* Le test n’a pas besoin de mocker la méthode statique du mapper : on crée un `BillingSpaceEntity` minimal et on se contente de vérifier l’appel au `CommandExecutorV2` et la valeur de retour.
* Le second test assure que la signature `throws Exception` est effectivement utile (propagation d’erreur), tout en exécutant les lignes concernées.
