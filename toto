package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.job;

import com.bnpparibas.bddf.cqrs.command.v2.CommandExecutorV2;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.processor.BillingSpaceClosureProcessor;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.reader.BillingSpaceClosureReader;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.reader.ReplayBillingspaceClosureReader;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.tasklet.UpdateBillingSpaceToStatusClosedTasklet;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.close.writer.BillingSpaceClosureWriter;
import com.bnpparibas.dsibddf.ap00420.streamfact.batch.listener.CommonStepExecutionListener;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.billingspace.repository.BillingSpaceRepository;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.entity.history.repository.DocaposteEventHistoryRepository;
import com.bnpparibas.dsibddf.ap00420.streamfact.domain.repository.docaposte.DocaposteRepository;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.Step;
import org.springframework.batch.core.job.flow.FlowJob;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.core.step.tasklet.TaskletStep;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.TestConfiguration;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.Primary;
import org.springframework.test.context.junit.jupiter.SpringJUnitConfig;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.transaction.PlatformTransactionManager;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Couvre la conf @Configuration JobConfigurationBillingSpaceClosure :
 * - @Bean billingSpaceClosureJob(.)
 * - @Bean billingSpaceClosureStep(.)
 * - @Bean replayBillingSpaceClosureStep(.)
 * - @Bean updateBillingSpaceToStatusClosedStep(.)
 */
@SpringJUnitConfig
@Import({ JobConfigurationBillingSpaceClosure.class, JobConfigurationBillingSpaceClosureTest.TestBeans.class })
class JobConfigurationBillingSpaceClosureTest {

    @Autowired private ApplicationContext ctx;

    @Autowired private Job job; // bean "billingSpaceClosureJob"

    @Autowired @Qualifier("billingSpaceClosureStep")
    private Step billingSpaceClosureStepBean;

    @Autowired @Qualifier("replayBillingSpaceClosureStep")
    private Step replayBillingSpaceClosureStepBean;

    // Bean name = updateBillingSpaceToStatusClosedStep, step name = "updateBillingSpaceToStatusClosed"
    @Autowired @Qualifier("updateBillingSpaceToStatusClosedStep")
    private Step updateBillingSpaceToStatusClosedStepBean;

    @Autowired private CommonStepExecutionListener commonStepExecutionListener;

    @Test
    @DisplayName("Contexte OK : job + 3 steps présents")
    void context_ok() {
        assertThat(job).isNotNull();
        assertThat(billingSpaceClosureStepBean).isNotNull();
        assertThat(replayBillingSpaceClosureStepBean).isNotNull();
        assertThat(updateBillingSpaceToStatusClosedStepBean).isNotNull();
    }

    @Nested
    @DisplayName("Job wiring & flow")
    class JobWiring {

        @Test
        @DisplayName("Nom du job + RunIdIncrementer")
        void job_has_name_and_incrementer() {
            assertThat(job).isInstanceOf(FlowJob.class);
            FlowJob fj = (FlowJob) job;
            assertThat(fj.getName()).isEqualTo("billingSpaceClosureJob");
            assertThat(fj.getJobParametersIncrementer()).isInstanceOf(RunIdIncrementer.class);
        }

        @Test
        @DisplayName("Le flow référence bien les 3 steps (par leurs noms de step)")
        void job_contains_expected_steps_in_flow() {
            FlowJob fj = (FlowJob) job;
            assertThat(fj.getStep("billingSpaceClosureStep")).isNotNull();
            assertThat(fj.getStep("replayBillingSpaceClosureStep")).isNotNull();
            assertThat(fj.getStep("updateBillingSpaceToStatusClosed")).isNotNull();
        }
    }

    @Nested
    @DisplayName("Steps chunkés : chunk=100, allowStartIfComplete=true, listener commun")
    class ChunkedStepsProperties {

        @Test
        void billingSpaceClosureStep_properties() {
            assertChunkStep(billingSpaceClosureStepBean, 100);
        }

        @Test
        void replayBillingSpaceClosureStep_properties() {
            assertChunkStep(replayBillingSpaceClosureStepBean, 100);
        }
    }

    @Nested
    @DisplayName("Step tasklet : allowStartIfComplete=true")
    class TaskletStepProperties {
        @Test
        void updateBillingSpaceToStatusClosed_allowStartIfComplete_true() {
            assertThat(updateBillingSpaceToStatusClosedStepBean).isInstanceOf(TaskletStep.class);
            TaskletStep ts = (TaskletStep) updateBillingSpaceToStatusClosedStepBean;
            Object allow = ReflectionTestUtils.getField(ts, "allowStartIfComplete");
            assertThat(allow).isInstanceOf(Boolean.class);
            assertThat((Boolean) allow).isTrue();
        }
    }

    // ---------- Helpers reflection ----------

    private void assertChunkStep(Step step, int expectedChunk) {
        assertThat(step).isInstanceOf(TaskletStep.class);
        TaskletStep ts = (TaskletStep) step;

        // allowStartIfComplete
        Object allow = ReflectionTestUtils.getField(ts, "allowStartIfComplete");
        assertThat(allow).isInstanceOf(Boolean.class);
        assertThat((Boolean) allow).isTrue();

        // listener commun présent
        Object compositeListener = ReflectionTestUtils.getField(ts, "stepExecutionListener");
        Object listeners = ReflectionTestUtils.getField(compositeListener, "listeners");
        assertThat(listeners).isInstanceOfAny(java.util.Collection.class);
        assertThat((java.util.Collection<?>) listeners).anyMatch(l -> l == commonStepExecutionListener);

        // chunk size = expectedChunk (essaye différents chemins internes SB4/SB5)
        Tasklet tasklet = (Tasklet) ReflectionTestUtils.getField(ts, "tasklet");
        assertThat(tasklet).isNotNull();

        Integer chunkSize = tryFindChunkSize(tasklet);
        assertThat(chunkSize)
                .as("chunk size via réflexion")
                .isEqualTo(expectedChunk);
    }

    /**
     * Essaie plusieurs chemins candidats selon les versions Spring Batch 4/5
     */
    private Integer tryFindChunkSize(Object tasklet) {
        String[][] candidates = new String[][]{
                // SB4 historique
                {"chunkProvider", "completionPolicy", "chunkSize"},
                {"chunkProvider", "chunkOperations", "completionPolicy", "chunkSize"},
                // SB5 / variantes
                {"chunkOperations", "completionPolicy", "chunkSize"},
                {"chunkOperations", "repeatOperations", "completionPolicy", "chunkSize"},
                {"repeatOperations", "completionPolicy", "chunkSize"}
        };
        for (String[] path : candidates) {
            Object v = deepGet(tasklet, path);
            if (v instanceof Integer) {
                return (Integer) v;
            }
        }
        // Dernière chance : parfois completionPolicy est SimpleCompletionPolicy directement au niveau du tasklet
        Object v = ReflectionTestUtils.getField(tasklet, "completionPolicy");
        if (v != null) {
            Object size = ReflectionTestUtils.getField(v, "chunkSize");
            if (size instanceof Integer) {
                return (Integer) size;
            }
        }
        return null; // fera échouer l'assertion avec un message explicite
    }

    private Object deepGet(Object obj, String... fields) {
        Object cur = obj;
        for (String f : fields) {
            if (cur == null) return null;
            cur = ReflectionTestUtils.getField(cur, f);
        }
        return cur;
    }

    // ---------- Beans de test (mocks) ----------
    @TestConfiguration
    static class TestBeans {

        // Mocks métier utilisés par la conf
        @Bean @Primary BillingSpaceClosureReader billingSpaceClosureReader() {
            return Mockito.mock(BillingSpaceClosureReader.class);
        }
        @Bean @Primary ReplayBillingspaceClosureReader replayBillingSpaceClosureReader() {
            return Mockito.mock(ReplayBillingspaceClosureReader.class);
        }
        @Bean @Primary BillingSpaceClosureProcessor billingSpaceClosureProcessor() {
            return Mockito.mock(BillingSpaceClosureProcessor.class);
        }
        @Bean @Primary BillingSpaceClosureWriter billingSpaceClosureWriter() {
            return Mockito.mock(BillingSpaceClosureWriter.class);
        }
        @Bean UpdateBillingSpaceToStatusClosedTasklet updateBillingSpaceToStatusClosedTasklet() {
            return Mockito.mock(UpdateBillingSpaceToStatusClosedTasklet.class);
        }
        @Bean CommonStepExecutionListener commonStepExecutionListener() {
            return Mockito.mock(CommonStepExecutionListener.class);
        }

        // Dépendances autowirées ailleurs
        @Bean CommandExecutorV2 commandExecutor() {
            return Mockito.mock(CommandExecutorV2.class);
        }
        @Bean DocaposteRepository docaposteRepository() {
            return Mockito.mock(DocaposteRepository.class);
        }
        @Bean DocaposteEventHistoryRepository docaposteEventHistoryRepository() {
            return Mockito.mock(DocaposteEventHistoryRepository.class);
        }
        @Bean BillingSpaceRepository billingSpaceRepository() {
            return Mockito.mock(BillingSpaceRepository.class);
        }

        // Infra minimale requise par les builders
        @Bean(name = "transactionManager")
        PlatformTransactionManager transactionManager() {
            return Mockito.mock(PlatformTransactionManager.class);
        }
        @Bean
        JobRepository jobRepository() {
            return Mockito.mock(JobRepository.class);
        }
    }
}