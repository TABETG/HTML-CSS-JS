package com.bnpparibas.dsibddf.ap00420.streamfact.batch.billingspace.synchro.update.writer;

import java.util.Arrays;
import java.util.Collections;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.MockitoJUnitRunner;

import org.springframework.batch.item.Chunk;

// Imports du code métier (adapte uniquement si ton package exact diffère)
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.SynchroResult;
import com.bnpparibas.dsibddf.ap00420.streamfact.application.loanfolder.synchro.pojo.LoanFolderSynchroResult;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.loanfolder.mapper.LoanFolderMapperToJpa;
import com.bnpparibas.dsibddf.ap00420.streamfact.infrastructure.sql.entities.loanfolder.repository.LoanFolderAnswerJpaRepository;

import static org.junit.Assert.assertTrue;
import static org.mockito.ArgumentMatchers.anyList;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoInteractions;

/**
 * Tests unitaires JUnit 4 pour LoanFolderSynchroItemWriter.
 *
 * Objectif : couvrir la logique de filtrage (présence/absence de synchronisation)
 * et la persistance via le repository. Les commentaires indiquent les intentions
 * et ce qu'on cherche à valider pour Sonar/Jacoco.
 */
@RunWith(MockitoJUnitRunner.class)
public class LoanFolderSynchroItemWriterTest {

    @Mock
    private LoanFolderMapperToJpa loanFolderMapperToJpa;

    @Mock
    private LoanFolderAnswerJpaRepository loanFolderAnswerJpaRepository;

    @InjectMocks
    private LoanFolderSynchroItemWriter writer;

    @Before
    public void setUp() {
        // Pas de configuration spécifique : @InjectMocks injecte les @Mock dans le writer.
        assertTrue(true);
    }

    /**
     * Cas 1 : au moins un SynchroResult contient une synchronisation (getLoanFolderSynchroResult() != null).
     * Attendu : la liste filtrée n'est pas vide → le repository est appelé (saveAll).
     */
    @Test
    public void write_shouldPersist_whenAtLeastOneItemHasSynchronisation() throws Exception {
        // GIVEN
        SynchroResult withSync = Mockito.mock(SynchroResult.class);
        SynchroResult withoutSync = Mockito.mock(SynchroResult.class);
        LoanFolderSynchroResult syncResult = Mockito.mock(LoanFolderSynchroResult.class);

        // Simule un item "avec synchronisation" et un item "sans synchronisation"
        Mockito.when(withSync.getLoanFolderSynchroResult()).thenReturn(syncResult);
        Mockito.when(withoutSync.getLoanFolderSynchroResult()).thenReturn(null);

        Chunk<SynchroResult> chunk = new Chunk<>(Arrays.asList(withSync, withoutSync));

        // WHEN
        writer.write(chunk);

        // THEN
        // On ne vérifie pas ici le contenu précis mappé (il dépend du mapper),
        // mais bien que la persistance est déclenchée si au moins un item a une synchro.
        verify(loanFolderAnswerJpaRepository).saveAll(anyList());
        // Le mapper peut être invoqué ; on ne fait pas d'assertion sur son nombre d'appels exact.
    }

    /**
     * Cas 2 : aucun SynchroResult n’a de synchronisation (tous renvoient null).
     * Attendu : aucun appel au mapper ni au repository.
     */
    @Test
    public void write_shouldDoNothing_whenNoItemHasSynchronisation() throws Exception {
        // GIVEN
        SynchroResult noSync1 = Mockito.mock(SynchroResult.class);
        SynchroResult noSync2 = Mockito.mock(SynchroResult.class);

        Mockito.when(noSync1.getLoanFolderSynchroResult()).thenReturn(null);
        Mockito.when(noSync2.getLoanFolderSynchroResult()).thenReturn(null);

        Chunk<SynchroResult> chunk = new Chunk<>(Arrays.asList(noSync1, noSync2));

        // WHEN
        writer.write(chunk);

        // THEN
        // S'il n'y a rien à synchroniser, l'ItemWriter ne doit rien persister ni mapper.
        verifyNoInteractions(loanFolderAnswerJpaRepository);
        verifyNoInteractions(loanFolderMapperToJpa);
    }

    /**
     * Cas 3 : chunk vide (aucun item).
     * Attendu : aucun appel au mapper ni au repository (chemin "pas d’items" bien géré).
     */
    @Test
    public void write_shouldHandleEmptyChunk() throws Exception {
        // GIVEN
        Chunk<SynchroResult> emptyChunk = new Chunk<>(Collections.emptyList());

        // WHEN
        writer.write(emptyChunk);

        // THEN
        verifyNoInteractions(loanFolderAnswerJpaRepository);
        verifyNoInteractions(loanFolderMapperToJpa);
    }
}